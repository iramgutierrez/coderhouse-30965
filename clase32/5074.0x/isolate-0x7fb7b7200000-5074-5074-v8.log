v8-version,9,4,146,24,-node.14,0
v8-platform,macos,macos
shared-library,/Users/iramgutierrez/.nvm/versions/node/v16.13.2/bin/node,0x10700b000,0x1083f5747,117481472
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x7ff803ecdce0,0x7ff80408e905,62275584
shared-library,/usr/lib/libobjc.A.dylib,0x7ff803d12e40,0x7ff803d39ecf,62275584
shared-library,/usr/lib/liboah.dylib,0x7ff80ec4d350,0x7ff80ec52eba,62275584
shared-library,/usr/lib/libfakelink.dylib,0x7ff80ec80e20,0x7ff80ec83bc5,62275584
shared-library,/usr/lib/libicucore.A.dylib,0x7ff80622e800,0x7ff8064518f2,62275584
shared-library,/usr/lib/libSystem.B.dylib,0x7ff80ec7f722,0x7ff80ec7fcee,62275584
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x7ff80ec84c33,0x7ff80ec84ebe,62275584
shared-library,/usr/lib/libc++abi.dylib,0x7ff803e32020,0x7ff803e43e20,62275584
shared-library,/usr/lib/libc++.1.dylib,0x7ff803ddcf20,0x7ff803e27021,62275584
shared-library,/usr/lib/system/libcache.dylib,0x7ff80ec79a4c,0x7ff80ec7c4af,62275584
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x7ff80ec35f60,0x7ff80ec3fefc,62275584
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x7ff80ec5ecbc,0x7ff80ec63c47,62275584
shared-library,/usr/lib/system/libcopyfile.dylib,0x7ff80ec54aa0,0x7ff80ec5c430,62275584
shared-library,/usr/lib/system/libcorecrypto.dylib,0x7ff803c0e180,0x7ff803c7c442,62275584
shared-library,/usr/lib/system/libdispatch.dylib,0x7ff803ccc900,0x7ff803d018f2,62275584
shared-library,/usr/lib/system/libdyld.dylib,0x7ff803e8bdc0,0x7ff803e95fe0,62275584
shared-library,/usr/lib/system/libkeymgr.dylib,0x7ff80ec70ad9,0x7ff80ec70f18,62275584
shared-library,/usr/lib/system/libmacho.dylib,0x7ff80ec1466c,0x7ff80ec18969,62275584
shared-library,/usr/lib/system/libquarantine.dylib,0x7ff80e295079,0x7ff80e296ce2,62275584
shared-library,/usr/lib/system/libremovefile.dylib,0x7ff80ec6e930,0x7ff80ec6fd9b,62275584
shared-library,/usr/lib/system/libsystem_asl.dylib,0x7ff808e21328,0x7ff808e35706,62275584
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x7ff803bb72cb,0x7ff803bb7834,62275584
shared-library,/usr/lib/system/libsystem_c.dylib,0x7ff803d500a0,0x7ff803dd1477,62275584
shared-library,/usr/lib/system/libsystem_collections.dylib,0x7ff80ec6700b,0x7ff80ec6a9dc,62275584
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x7ff80d549044,0x7ff80d54b8c7,62275584
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x7ff80c7f2298,0x7ff80c8082cf,62275584
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x7ff80e94be60,0x7ff80e94f420,62275584
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x7ff8064c21a0,0x7ff8064c8423,62275584
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x7ff80ec722e8,0x7ff80ec773ce,62275584
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x7ff803d4cf43,0x7ff803d4ec7c,62275584
shared-library,/usr/lib/system/libsystem_info.dylib,0x7ff803ea1e80,0x7ff803ec79c0,62275584
shared-library,/usr/lib/system/libsystem_m.dylib,0x7ff80ebb2240,0x7ff80ebe7009,62275584
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x7ff803ca0530,0x7ff803cc2980,62275584
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x7ff808dbc670,0x7ff808dcdb08,62275584
shared-library,/usr/lib/system/libsystem_notify.dylib,0x7ff8068e7cd4,0x7ff8068f4ed5,62275584
shared-library,/usr/lib/system/libsystem_product_info_filter.dylib,0x7ff814eed000,0x7ff814eed000,62275584
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x7ff80d54d6f8,0x7ff80d5513b8,62275584
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x7ff80ec6befe,0x7ff80ec6d4c0,62275584
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x7ff803e48680,0x7ff803e6e03f,62275584
shared-library,/usr/lib/system/libsystem_platform.dylib,0x7ff803e98000,0x7ff803e9f082,62275584
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x7ff803e80010,0x7ff803e887e5,62275584
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x7ff80a66ee51,0x7ff80a6744ce,62275584
shared-library,/usr/lib/system/libsystem_trace.dylib,0x7ff803bf5630,0x7ff803c0a316,62275584
shared-library,/usr/lib/system/libunwind.dylib,0x7ff80ec46480,0x7ff80ec4b49a,62275584
shared-library,/usr/lib/system/libxpc.dylib,0x7ff803bb9610,0x7ff803be5591,62275584
shared-library-end
tick,0x7ff803e489b6,947,0,0x0,6
profiler,begin,1000
new,CodeRange,0x10f87b000,0
new,MemoryChunk,0x3157e45c0000,262144
tick,0x107484a97,2212,0,0x0,6
new,MemoryChunk,0x315790700000,262144
new,MemoryChunk,0x31575dac0000,262144
new,MemoryChunk,0x31572c380000,262144
new,MemoryChunk,0x315710b00000,262144
heap-capacity,1031072
heap-available,4346136384
new,MemoryChunk,0x31575b540000,262144
new,MemoryChunk,0x31576ed00000,262144
new,MemoryChunk,0x315735240000,262144
tick,0x1077b483d,3304,0,0x0,6
new,MemoryChunk,0x315715840000,262144
new,MemoryChunk,0x3157dbec0000,262144
tick,0x1077b2e02,4306,0,0x0,6
new,MemoryChunk,0x31572ee40000,262144
new,MemoryChunk,0x31577c040000,262144
new,MemoryChunk,0x10f880000,262144
tick,0x1077b54bd,5584,0,0x0,6
new,MemoryChunk,0x31573d940000,262144
tick,0x1077b7376,6642,0,0x0,6
tick,0x7ff803e4b5ae,7819,0,0x0,6
code-creation,Builtin,2,7912,0x107aba1e0,1340,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,7953,0x107aba720,452,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,7967,0x107aba900,620,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,7978,0x107abab80,208,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,7989,0x107abac60,352,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,7999,0x107abade0,116,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,8009,0x107abae60,60,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,8058,0x107abaea0,360,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,8072,0x107abb020,416,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,8084,0x107abb1e0,444,CallFunction_ReceiverIsAny
code-creation,Builtin,2,8095,0x107abb3a0,104,CallBoundFunction
code-creation,Builtin,2,8105,0x107abb420,120,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,8116,0x107abb4a0,120,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,8127,0x107abb520,120,Call_ReceiverIsAny
code-creation,Builtin,2,8138,0x107abb5a0,988,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,8150,0x107abb980,984,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,8162,0x107abbd60,1072,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,8176,0x107abc1a0,1072,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,8188,0x107abc5e0,1072,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,8199,0x107abca20,1072,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,8210,0x107abce60,944,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,8222,0x107abd220,944,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,8234,0x107abd5e0,944,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,8245,0x107abd9a0,736,CallProxy
code-creation,Builtin,2,8254,0x107abdca0,148,CallVarargs
code-creation,Builtin,2,8263,0x107abdd40,940,CallWithSpread
code-creation,Builtin,2,8272,0x107abe100,1948,CallWithSpread_Baseline
code-creation,Builtin,2,8282,0x107abe8a0,1920,CallWithSpread_WithFeedback
code-creation,Builtin,2,8292,0x107abf040,864,CallWithArrayLike
code-creation,Builtin,2,8302,0x107abf3c0,1812,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,8312,0x107abfae0,156,CallForwardVarargs
code-creation,Builtin,2,8322,0x107abfb80,156,CallFunctionForwardVarargs
code-creation,Builtin,2,8332,0x107abfc20,132,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,8343,0x107abfcc0,228,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,8355,0x107abfdc0,316,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,8372,0x107abff00,28,ConstructFunction
code-creation,Builtin,2,8382,0x107abff20,104,ConstructBoundFunction
code-creation,Builtin,2,8392,0x107abffa0,28,ConstructedNonConstructable
code-creation,Builtin,2,8402,0x107abffc0,100,Construct
code-creation,Builtin,2,8411,0x107ac0040,148,ConstructVarargs
code-creation,Builtin,2,8421,0x107ac00e0,964,ConstructWithSpread
code-creation,Builtin,2,8457,0x107ac04c0,1740,ConstructWithSpread_Baseline
code-creation,Builtin,2,8469,0x107ac0ba0,1756,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,8480,0x107ac1280,920,ConstructWithArrayLike
code-creation,Builtin,2,8490,0x107ac1620,1644,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,8502,0x107ac1ca0,196,ConstructForwardVarargs
code-creation,Builtin,2,8512,0x107ac1d80,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,8523,0x107ac1e60,792,Construct_Baseline
code-creation,Builtin,2,8533,0x107ac2180,812,Construct_WithFeedback
code-creation,Builtin,2,8544,0x107ac24c0,476,JSConstructStubGeneric
code-creation,Builtin,2,8555,0x107ac26a0,376,JSBuiltinsConstructStub
code-creation,Builtin,2,8565,0x107ac2820,676,FastNewObject
code-creation,Builtin,2,8575,0x107ac2ae0,292,FastNewClosure
code-creation,Builtin,2,8585,0x107ac2c20,720,ConstructProxy
code-creation,Builtin,2,8595,0x107ac2f00,192,JSEntry
code-creation,Builtin,2,8604,0x107ac2fe0,192,JSConstructEntry
code-creation,Builtin,2,8614,0x107ac30c0,192,JSRunMicrotasksEntry
code-creation,Builtin,2,8625,0x107ac31a0,96,JSEntryTrampoline
code-creation,Builtin,2,8635,0x107ac3220,96,JSConstructEntryTrampoline
code-creation,Builtin,2,8645,0x107ac32a0,280,ResumeGeneratorTrampoline
code-creation,Builtin,2,8655,0x107ac33c0,1116,StringCodePointAt
code-creation,Builtin,2,8665,0x107ac3820,1548,StringFromCodePointAt
code-creation,Builtin,2,8676,0x107ac3e40,544,StringEqual
code-creation,Builtin,2,8685,0x107ac4080,276,StringGreaterThan
code-creation,Builtin,2,8695,0x107ac41a0,276,StringGreaterThanOrEqual
code-creation,Builtin,2,8705,0x107ac42c0,276,StringLessThan
code-creation,Builtin,2,8715,0x107ac43e0,276,StringLessThanOrEqual
code-creation,Builtin,2,8725,0x107ac4500,2492,StringSubstring
code-creation,Builtin,2,8735,0x107ac4ec0,80,OrderedHashTableHealIndex
code-creation,Builtin,2,8745,0x107ac4f20,1168,InterpreterEntryTrampoline
code-creation,Builtin,2,8756,0x107ac53c0,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,8767,0x107ac5420,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,8780,0x107ac5480,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,8791,0x107ac54e0,80,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,8802,0x107ac5540,80,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,8814,0x107ac55a0,84,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,8827,0x107ac5600,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,8838,0x107ac5660,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,8849,0x107ac5740,52,InterpreterOnStackReplacement
code-creation,Builtin,2,8860,0x107ac5780,592,BaselineOutOfLinePrologue
code-creation,Builtin,2,8901,0x107ac59e0,56,BaselineOnStackReplacement
code-creation,Builtin,2,8923,0x107ac5a20,84,BaselineLeaveFrame
code-creation,Builtin,2,8937,0x107ac5a80,212,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,8954,0x107ac5b60,220,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,8970,0x107ac5c40,188,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,8984,0x107ac5d00,1000,CompileLazy
code-creation,Builtin,2,8998,0x107ac6100,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,9012,0x107ac6160,252,InstantiateAsmJs
code-creation,Builtin,2,9023,0x107ac6260,32,NotifyDeoptimized
code-creation,Builtin,2,9035,0x107ac62a0,784,DeoptimizationEntry_Eager
code-creation,Builtin,2,9049,0x107ac65c0,784,DeoptimizationEntry_Soft
code-creation,Builtin,2,9061,0x107ac68e0,784,DeoptimizationEntry_Bailout
code-creation,Builtin,2,9072,0x107ac6c00,784,DeoptimizationEntry_Lazy
code-creation,Builtin,2,9085,0x107ac6f20,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,9098,0x107ac6f60,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,9111,0x107ac6fa0,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,9124,0x107ac6fe0,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,9137,0x107ac7040,288,CallApiCallback
code-creation,Builtin,2,9150,0x107ac7180,272,CallApiGetter
code-creation,Builtin,2,9184,0x107ac72a0,12,HandleApiCall
code-creation,Builtin,2,9199,0x107ac72c0,12,HandleApiCallAsFunction
code-creation,Builtin,2,9213,0x107ac72e0,12,HandleApiCallAsConstructor
code-creation,Builtin,2,9224,0x107ac7300,64,AllocateInYoungGeneration
code-creation,Builtin,2,9235,0x107ac7360,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,9248,0x107ac73a0,64,AllocateInOldGeneration
code-creation,Builtin,2,9263,0x107ac7400,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,9275,0x107ac7440,424,CopyFastSmiOrObjectElements
code-creation,Builtin,2,9289,0x107ac7600,496,GrowFastDoubleElements
code-creation,Builtin,2,9300,0x107ac7800,396,GrowFastSmiOrObjectElements
code-creation,Builtin,2,9314,0x107ac79a0,388,DebugBreakTrampoline
code-creation,Builtin,2,9327,0x107ac7b40,180,ToNumber
code-creation,Builtin,2,9340,0x107ac7c00,292,ToNumber_Baseline
code-creation,Builtin,2,9351,0x107ac7d40,360,ToNumeric_Baseline
code-creation,Builtin,2,9365,0x107ac7ec0,104,PlainPrimitiveToNumber
code-creation,Builtin,2,9378,0x107ac7f40,212,ToNumberConvertBigInt
code-creation,Builtin,2,9392,0x107ac8020,132,Typeof
code-creation,Builtin,2,9405,0x107ac80c0,104,BigIntToI64
code-creation,Builtin,2,9417,0x107ac8140,4,BigIntToI32Pair
code-creation,Builtin,2,9428,0x107ac8160,232,I64ToBigInt
code-creation,Builtin,2,9441,0x107ac8260,4,I32PairToBigInt
code-creation,Builtin,2,9456,0x107ac8280,100,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,9470,0x107ac8300,4232,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,9482,0x107ac93a0,15704,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,9496,0x107acd100,280,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,9511,0x107acd220,60,LoadIC_FunctionPrototype
code-creation,Builtin,2,9526,0x107acd260,12,LoadIC_StringLength
code-creation,Builtin,2,9542,0x107acd280,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,9558,0x107acd2a0,3056,LoadIC_NoFeedback
code-creation,Builtin,2,9572,0x107acdea0,32,StoreGlobalIC_Slow
code-creation,Builtin,2,9586,0x107acdee0,7284,StoreIC_NoFeedback
code-creation,Builtin,2,9599,0x107acfb60,180,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,9611,0x107acfc20,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,9624,0x107acfc80,240,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,9639,0x107acfd80,240,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,9658,0x107acfe80,240,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,9676,0x107acff80,240,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,9693,0x107ad0080,13924,StoreFastElementIC_Standard
code-creation,Builtin,2,9709,0x107ad3700,9660,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,9725,0x107ad5cc0,13104,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,9743,0x107ad9000,6160,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,9757,0x107ada820,8468,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,9773,0x107adc940,19332,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,9790,0x107ae14e0,8468,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,9809,0x107ae3600,11028,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,9825,0x107ae6120,792,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,9840,0x107ae6440,164,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,9854,0x107ae6500,72,HasIndexedInterceptorIC
code-creation,Builtin,2,9869,0x107ae6560,88,DynamicCheckMapsTrampoline
code-creation,Builtin,2,9883,0x107ae65c0,260,DynamicCheckMaps
code-creation,Builtin,2,9896,0x107ae66e0,88,DynamicCheckMapsWithFeedbackVectorTrampoline
code-creation,Builtin,2,9911,0x107ae6740,224,DynamicCheckMapsWithFeedbackVector
code-creation,Builtin,2,9926,0x107ae6840,148,EnqueueMicrotask
code-creation,Builtin,2,9939,0x107ae68e0,8,RunMicrotasksTrampoline
code-creation,Builtin,2,9953,0x107ae6900,3504,RunMicrotasks
code-creation,Builtin,2,9967,0x107ae76c0,2624,HasProperty
code-creation,Builtin,2,9981,0x107ae8120,1144,DeleteProperty
code-creation,Builtin,2,10049,0x107ae85a0,1972,CopyDataProperties
code-creation,Builtin,2,10066,0x107ae8d60,9156,SetDataProperties
code-creation,Builtin,2,10079,0x107aeb140,28,Abort
code-creation,Builtin,2,10091,0x107aeb160,28,AbortCSAAssert
code-creation,Builtin,2,10104,0x107aeb180,12,EmptyFunction
code-creation,Builtin,2,10116,0x107aeb1a0,12,Illegal
code-creation,Builtin,2,10125,0x107aeb1c0,12,StrictPoisonPillThrower
code-creation,Builtin,2,10138,0x107aeb1e0,12,UnsupportedThrower
code-creation,Builtin,2,10148,0x107aeb200,64,ReturnReceiver
code-creation,Builtin,2,10161,0x107aeb260,28,ArrayConstructor
code-creation,Builtin,2,10174,0x107aeb280,404,ArrayConstructorImpl
tick,0x7ff803e4b9ce,10194,0,0x0,6
tick,0x7ff803e4b9ce,10226,0,0x0,6
code-creation,Builtin,2,10244,0x107aeb420,216,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,10264,0x107aeb500,216,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,10277,0x107aeb5e0,176,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,10289,0x107aeb6a0,176,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,10302,0x107aeb760,176,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,10315,0x107aeb820,176,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,10327,0x107aeb8e0,188,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,10340,0x107aeb9a0,188,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,10353,0x107aeba60,512,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,10366,0x107aebc80,480,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,10378,0x107aebe80,436,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,10392,0x107aec040,404,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,10405,0x107aec1e0,436,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,10424,0x107aec3a0,404,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,10437,0x107aec540,448,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,10451,0x107aec720,412,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,10464,0x107aec8c0,64,ArrayNArgumentsConstructor
code-creation,Builtin,2,10474,0x107aec920,12,ArrayConcat
code-creation,Builtin,2,10483,0x107aec940,12,ArrayPrototypeFill
code-creation,Builtin,2,10492,0x107aec960,932,ArrayIncludesSmiOrObject
code-creation,Builtin,2,10502,0x107aecd20,140,ArrayIncludesPackedDoubles
code-creation,Builtin,2,10512,0x107aecdc0,208,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,10522,0x107aecea0,548,ArrayIncludes
code-creation,Builtin,2,10532,0x107aed0e0,856,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,10542,0x107aed440,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,10553,0x107aed4c0,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,10562,0x107aed540,552,ArrayIndexOf
code-creation,Builtin,2,10572,0x107aed780,12,ArrayPop
code-creation,Builtin,2,10581,0x107aed7a0,616,ArrayPrototypePop
code-creation,Builtin,2,10591,0x107aeda20,12,ArrayPush
code-creation,Builtin,2,10600,0x107aeda40,2412,ArrayPrototypePush
code-creation,Builtin,2,10610,0x107aee3c0,12,ArrayShift
code-creation,Builtin,2,10620,0x107aee3e0,12,ArrayUnshift
code-creation,Builtin,2,10629,0x107aee400,944,CloneFastJSArray
code-creation,Builtin,2,10638,0x107aee7c0,2196,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,10648,0x107aef060,968,ExtractFastJSArray
code-creation,Builtin,2,10658,0x107aef440,260,ArrayPrototypeEntries
code-creation,Builtin,2,10667,0x107aef560,248,ArrayPrototypeKeys
code-creation,Builtin,2,10677,0x107aef660,260,ArrayPrototypeValues
code-creation,Builtin,2,10687,0x107aef780,4424,ArrayIteratorPrototypeNext
code-creation,Builtin,2,10697,0x107af08e0,4164,FlattenIntoArray
code-creation,Builtin,2,10727,0x107af1940,4164,FlatMapIntoArray
code-creation,Builtin,2,10738,0x107af29a0,372,ArrayPrototypeFlat
code-creation,Builtin,2,10748,0x107af2b20,428,ArrayPrototypeFlatMap
code-creation,Builtin,2,10758,0x107af2ce0,12,ArrayBufferConstructor
code-creation,Builtin,2,10768,0x107af2d00,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,10779,0x107af2d20,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,10789,0x107af2d40,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,10799,0x107af2d60,804,AsyncFunctionEnter
code-creation,Builtin,2,10809,0x107af30a0,132,AsyncFunctionReject
code-creation,Builtin,2,10819,0x107af3140,128,AsyncFunctionResolve
code-creation,Builtin,2,10829,0x107af31e0,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,10840,0x107af3200,2804,AsyncFunctionAwaitCaught
code-creation,Builtin,2,10850,0x107af3d00,2804,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,10860,0x107af4800,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,10872,0x107af48c0,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,10882,0x107af4980,12,BigIntConstructor
code-creation,Builtin,2,10892,0x107af49a0,12,BigIntAsUintN
code-creation,Builtin,2,10902,0x107af49c0,12,BigIntAsIntN
code-creation,Builtin,2,10911,0x107af49e0,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,10921,0x107af4a00,12,BigIntPrototypeToString
code-creation,Builtin,2,10932,0x107af4a20,12,BigIntPrototypeValueOf
code-creation,Builtin,2,10941,0x107af4a40,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,10952,0x107af4a60,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,10964,0x107af4a80,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,10975,0x107af4aa0,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,10986,0x107af4ac0,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,10997,0x107af4ae0,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,11009,0x107af4b00,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,11020,0x107af4b20,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,11030,0x107af4b40,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,11041,0x107af4b60,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,11052,0x107af4b80,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,11062,0x107af4ba0,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,11074,0x107af4bc0,12,CallSitePrototypeGetThis
code-creation,Builtin,2,11085,0x107af4be0,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,11095,0x107af4c00,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,11105,0x107af4c20,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,11116,0x107af4c40,12,CallSitePrototypeIsEval
code-creation,Builtin,2,11126,0x107af4c60,12,CallSitePrototypeIsNative
code-creation,Builtin,2,11138,0x107af4c80,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,11149,0x107af4ca0,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,11159,0x107af4cc0,12,CallSitePrototypeToString
code-creation,Builtin,2,11170,0x107af4ce0,12,ConsoleDebug
code-creation,Builtin,2,11180,0x107af4d00,12,ConsoleError
code-creation,Builtin,2,11189,0x107af4d20,12,ConsoleInfo
code-creation,Builtin,2,11199,0x107af4d40,12,ConsoleLog
code-creation,Builtin,2,11209,0x107af4d60,12,ConsoleWarn
code-creation,Builtin,2,11218,0x107af4d80,12,ConsoleDir
code-creation,Builtin,2,11228,0x107af4da0,12,ConsoleDirXml
code-creation,Builtin,2,11237,0x107af4dc0,12,ConsoleTable
code-creation,Builtin,2,11247,0x107af4de0,12,ConsoleTrace
code-creation,Builtin,2,11257,0x107af4e00,12,ConsoleGroup
code-creation,Builtin,2,11267,0x107af4e20,12,ConsoleGroupCollapsed
code-creation,Builtin,2,11278,0x107af4e40,12,ConsoleGroupEnd
code-creation,Builtin,2,11293,0x107af4e60,12,ConsoleClear
code-creation,Builtin,2,11326,0x107af4e80,12,ConsoleCount
code-creation,Builtin,2,11342,0x107af4ea0,12,ConsoleCountReset
code-creation,Builtin,2,11357,0x107af4ec0,12,ConsoleAssert
code-creation,Builtin,2,11369,0x107af4ee0,12,ConsoleProfile
code-creation,Builtin,2,11382,0x107af4f00,12,ConsoleProfileEnd
code-creation,Builtin,2,11412,0x107af4f20,12,ConsoleTime
code-creation,Builtin,2,11426,0x107af4f40,12,ConsoleTimeLog
code-creation,Builtin,2,11438,0x107af4f60,12,ConsoleTimeEnd
code-creation,Builtin,2,11452,0x107af4f80,12,ConsoleTimeStamp
code-creation,Builtin,2,11464,0x107af4fa0,12,ConsoleContext
code-creation,Builtin,2,11477,0x107af4fc0,12,DataViewConstructor
code-creation,Builtin,2,11491,0x107af4fe0,12,DateConstructor
code-creation,Builtin,2,11504,0x107af5000,220,DatePrototypeGetDate
code-creation,Builtin,2,11517,0x107af50e0,220,DatePrototypeGetDay
code-creation,Builtin,2,11531,0x107af51c0,220,DatePrototypeGetFullYear
code-creation,Builtin,2,11543,0x107af52a0,220,DatePrototypeGetHours
code-creation,Builtin,2,11555,0x107af5380,196,DatePrototypeGetMilliseconds
code-creation,Builtin,2,11570,0x107af5460,220,DatePrototypeGetMinutes
code-creation,Builtin,2,11584,0x107af5540,220,DatePrototypeGetMonth
code-creation,Builtin,2,11597,0x107af5620,220,DatePrototypeGetSeconds
code-creation,Builtin,2,11610,0x107af5700,124,DatePrototypeGetTime
code-creation,Builtin,2,11623,0x107af5780,196,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,11636,0x107af5860,196,DatePrototypeGetUTCDate
code-creation,Builtin,2,11649,0x107af5940,196,DatePrototypeGetUTCDay
code-creation,Builtin,2,11662,0x107af5a20,196,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,11676,0x107af5b00,196,DatePrototypeGetUTCHours
code-creation,Builtin,2,11687,0x107af5be0,196,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,11697,0x107af5cc0,196,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,11708,0x107af5da0,196,DatePrototypeGetUTCMonth
code-creation,Builtin,2,11718,0x107af5e80,196,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,11729,0x107af5f60,124,DatePrototypeValueOf
code-creation,Builtin,2,11738,0x107af5fe0,352,DatePrototypeToPrimitive
code-creation,Builtin,2,11749,0x107af6160,12,DatePrototypeGetYear
code-creation,Builtin,2,11759,0x107af6180,12,DatePrototypeSetYear
code-creation,Builtin,2,11768,0x107af61a0,12,DateNow
code-creation,Builtin,2,11777,0x107af61c0,12,DateParse
code-creation,Builtin,2,11789,0x107af61e0,12,DatePrototypeSetDate
code-creation,Builtin,2,11801,0x107af6200,12,DatePrototypeSetFullYear
code-creation,Builtin,2,11815,0x107af6220,12,DatePrototypeSetHours
code-creation,Builtin,2,11830,0x107af6240,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,11843,0x107af6260,12,DatePrototypeSetMinutes
code-creation,Builtin,2,11857,0x107af6280,12,DatePrototypeSetMonth
code-creation,Builtin,2,11871,0x107af62a0,12,DatePrototypeSetSeconds
code-creation,Builtin,2,11885,0x107af62c0,12,DatePrototypeSetTime
code-creation,Builtin,2,11898,0x107af62e0,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,11911,0x107af6300,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,11926,0x107af6320,12,DatePrototypeSetUTCHours
tick,0x7ff803e4b9ce,11945,0,0x0,6
code-creation,Builtin,2,11979,0x107af6340,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,11998,0x107af6360,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,12008,0x107af6380,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,12018,0x107af63a0,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,12028,0x107af63c0,12,DatePrototypeToDateString
code-creation,Builtin,2,12039,0x107af63e0,12,DatePrototypeToISOString
code-creation,Builtin,2,12048,0x107af6400,12,DatePrototypeToUTCString
code-creation,Builtin,2,12058,0x107af6420,12,DatePrototypeToString
code-creation,Builtin,2,12068,0x107af6440,12,DatePrototypeToTimeString
code-creation,Builtin,2,12078,0x107af6460,12,DatePrototypeToJson
code-creation,Builtin,2,12087,0x107af6480,12,DateUTC
code-creation,Builtin,2,12096,0x107af64a0,12,ErrorConstructor
code-creation,Builtin,2,12105,0x107af64c0,12,ErrorCaptureStackTrace
code-creation,Builtin,2,12115,0x107af64e0,12,ErrorPrototypeToString
code-creation,Builtin,2,12124,0x107af6500,12,FunctionConstructor
code-creation,Builtin,2,12134,0x107af6520,68,FunctionPrototypeApply
code-creation,Builtin,2,12143,0x107af6580,12,FunctionPrototypeBind
code-creation,Builtin,2,12153,0x107af65a0,32,FunctionPrototypeCall
code-creation,Builtin,2,12179,0x107af65e0,12,FunctionPrototypeToString
code-creation,Builtin,2,12190,0x107af6600,192,CreateIterResultObject
code-creation,Builtin,2,12200,0x107af66e0,788,CreateGeneratorObject
code-creation,Builtin,2,12210,0x107af6a00,12,GeneratorFunctionConstructor
code-creation,Builtin,2,12220,0x107af6a20,412,GeneratorPrototypeNext
code-creation,Builtin,2,12230,0x107af6bc0,420,GeneratorPrototypeReturn
code-creation,Builtin,2,12240,0x107af6d80,424,GeneratorPrototypeThrow
code-creation,Builtin,2,12250,0x107af6f40,12,AsyncFunctionConstructor
code-creation,Builtin,2,12259,0x107af6f60,368,SuspendGeneratorBaseline
code-creation,Builtin,2,12269,0x107af70e0,88,ResumeGeneratorBaseline
code-creation,Builtin,2,12279,0x107af7140,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,12290,0x107af7180,12,GlobalDecodeURI
code-creation,Builtin,2,12299,0x107af71a0,12,GlobalDecodeURIComponent
code-creation,Builtin,2,12309,0x107af71c0,12,GlobalEncodeURI
code-creation,Builtin,2,12318,0x107af71e0,12,GlobalEncodeURIComponent
code-creation,Builtin,2,12328,0x107af7200,12,GlobalEscape
code-creation,Builtin,2,12337,0x107af7220,12,GlobalUnescape
code-creation,Builtin,2,12346,0x107af7240,12,GlobalEval
code-creation,Builtin,2,12354,0x107af7260,132,GlobalIsFinite
code-creation,Builtin,2,12363,0x107af7300,124,GlobalIsNaN
code-creation,Builtin,2,12372,0x107af7380,12,JsonParse
code-creation,Builtin,2,12380,0x107af73a0,12,JsonStringify
code-creation,Builtin,2,12389,0x107af73c0,4608,LoadIC
code-creation,Builtin,2,12399,0x107af85e0,4296,LoadIC_Megamorphic
code-creation,Builtin,2,12432,0x107af96c0,4520,LoadIC_Noninlined
code-creation,Builtin,2,12445,0x107afa880,44,LoadICTrampoline
code-creation,Builtin,2,12458,0x107afa8c0,24,LoadICBaseline
code-creation,Builtin,2,12470,0x107afa8e0,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,12484,0x107afa920,7376,LoadSuperIC
code-creation,Builtin,2,12495,0x107afc600,24,LoadSuperICBaseline
code-creation,Builtin,2,12508,0x107afc620,8132,KeyedLoadIC
code-creation,Builtin,2,12520,0x107afe600,13076,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,12534,0x107b01920,44,KeyedLoadICTrampoline
code-creation,Builtin,2,12552,0x107b01960,24,KeyedLoadICBaseline
code-creation,Builtin,2,12565,0x107b01980,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,12579,0x107b019c0,5064,StoreGlobalIC
code-creation,Builtin,2,12592,0x107b02da0,44,StoreGlobalICTrampoline
code-creation,Builtin,2,12605,0x107b02de0,24,StoreGlobalICBaseline
code-creation,Builtin,2,12616,0x107b02e00,5304,StoreIC
code-creation,Builtin,2,12625,0x107b042c0,44,StoreICTrampoline
code-creation,Builtin,2,12634,0x107b04300,24,StoreICBaseline
code-creation,Builtin,2,12644,0x107b04320,5740,KeyedStoreIC
code-creation,Builtin,2,12653,0x107b059a0,44,KeyedStoreICTrampoline
code-creation,Builtin,2,12666,0x107b059e0,24,KeyedStoreICBaseline
code-creation,Builtin,2,12679,0x107b05a00,404,StoreInArrayLiteralIC
code-creation,Builtin,2,12694,0x107b05ba0,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,12707,0x107b05bc0,140,LookupContextBaseline
code-creation,Builtin,2,12721,0x107b05c60,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,12736,0x107b05d00,3244,LoadGlobalIC
code-creation,Builtin,2,12746,0x107b069c0,3220,LoadGlobalICInsideTypeof
code-creation,Builtin,2,12756,0x107b07660,44,LoadGlobalICTrampoline
code-creation,Builtin,2,12765,0x107b076a0,24,LoadGlobalICBaseline
code-creation,Builtin,2,12775,0x107b076c0,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,12786,0x107b07700,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,12796,0x107b07720,140,LookupGlobalICBaseline
code-creation,Builtin,2,12806,0x107b077c0,140,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,12820,0x107b07860,2056,CloneObjectIC
code-creation,Builtin,2,12833,0x107b08080,24,CloneObjectICBaseline
code-creation,Builtin,2,12846,0x107b080a0,1988,CloneObjectIC_Slow
code-creation,Builtin,2,12859,0x107b08880,2764,KeyedHasIC
code-creation,Builtin,2,12871,0x107b09360,24,KeyedHasICBaseline
code-creation,Builtin,2,12900,0x107b09380,2620,KeyedHasIC_Megamorphic
code-creation,Builtin,2,12914,0x107b09dc0,1428,IterableToList
code-creation,Builtin,2,12928,0x107b0a360,1228,IterableToFixedArray
code-creation,Builtin,2,12941,0x107b0a840,748,IterableToListWithSymbolLookup
code-creation,Builtin,2,12955,0x107b0ab40,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,12969,0x107b0ab80,124,IterableToListMayPreserveHoles
code-creation,Builtin,2,12983,0x107b0ac00,976,IterableToFixedArrayForWasm
code-creation,Builtin,2,12997,0x107b0afe0,1616,StringListFromIterable
code-creation,Builtin,2,13012,0x107b0b640,1220,FindOrderedHashMapEntry
code-creation,Builtin,2,13025,0x107b0bb20,4156,MapConstructor
code-creation,Builtin,2,13038,0x107b0cb60,1960,MapPrototypeSet
code-creation,Builtin,2,13051,0x107b0d320,1524,MapPrototypeDelete
code-creation,Builtin,2,13064,0x107b0d920,204,MapPrototypeGet
code-creation,Builtin,2,13078,0x107b0da00,164,MapPrototypeHas
code-creation,Builtin,2,13090,0x107b0dac0,12,MapPrototypeClear
code-creation,Builtin,2,13103,0x107b0dae0,284,MapPrototypeEntries
code-creation,Builtin,2,13116,0x107b0dc00,144,MapPrototypeGetSize
code-creation,Builtin,2,13129,0x107b0dca0,492,MapPrototypeForEach
code-creation,Builtin,2,13142,0x107b0dea0,284,MapPrototypeKeys
code-creation,Builtin,2,13154,0x107b0dfc0,284,MapPrototypeValues
code-creation,Builtin,2,13167,0x107b0e0e0,1048,MapIteratorPrototypeNext
code-creation,Builtin,2,13180,0x107b0e500,1176,MapIteratorToList
code-creation,Builtin,2,13192,0x107b0e9a0,12,NumberPrototypeToExponential
code-creation,Builtin,2,13206,0x107b0e9c0,12,NumberPrototypeToFixed
code-creation,Builtin,2,13219,0x107b0e9e0,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,13232,0x107b0ea00,12,NumberPrototypeToPrecision
code-creation,Builtin,2,13247,0x107b0ea20,328,SameValue
code-creation,Builtin,2,13259,0x107b0eb80,204,SameValueNumbersOnly
code-creation,Builtin,2,13272,0x107b0ec60,792,Add_Baseline
code-creation,Builtin,2,13282,0x107b0ef80,828,Subtract_Baseline
code-creation,Builtin,2,13292,0x107b0f2c0,808,Multiply_Baseline
code-creation,Builtin,2,13305,0x107b0f600,832,Divide_Baseline
code-creation,Builtin,2,13318,0x107b0f960,764,Modulus_Baseline
code-creation,Builtin,2,13331,0x107b0fc60,804,Exponentiate_Baseline
code-creation,Builtin,2,13345,0x107b0ffa0,708,BitwiseAnd_Baseline
code-creation,Builtin,2,13357,0x107b10280,700,BitwiseOr_Baseline
code-creation,Builtin,2,13370,0x107b10540,708,BitwiseXor_Baseline
code-creation,Builtin,2,13383,0x107b10820,720,ShiftLeft_Baseline
code-creation,Builtin,2,13396,0x107b10b00,720,ShiftRight_Baseline
code-creation,Builtin,2,13408,0x107b10de0,836,ShiftRightLogical_Baseline
code-creation,Builtin,2,13421,0x107b11140,720,Add_WithFeedback
code-creation,Builtin,2,13433,0x107b11420,780,Subtract_WithFeedback
code-creation,Builtin,2,13446,0x107b11740,776,Multiply_WithFeedback
code-creation,Builtin,2,13459,0x107b11a60,804,Divide_WithFeedback
code-creation,Builtin,2,13473,0x107b11da0,724,Modulus_WithFeedback
code-creation,Builtin,2,13486,0x107b12080,760,Exponentiate_WithFeedback
code-creation,Builtin,2,13499,0x107b12380,684,BitwiseAnd_WithFeedback
code-creation,Builtin,2,13512,0x107b12640,676,BitwiseOr_WithFeedback
code-creation,Builtin,2,13525,0x107b12900,684,BitwiseXor_WithFeedback
code-creation,Builtin,2,13537,0x107b12bc0,692,ShiftLeft_WithFeedback
code-creation,Builtin,2,13550,0x107b12e80,692,ShiftRight_WithFeedback
code-creation,Builtin,2,13563,0x107b13140,808,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,13577,0x107b13480,1696,Equal_Baseline
code-creation,Builtin,2,13590,0x107b13b40,908,StrictEqual_Baseline
code-creation,Builtin,2,13625,0x107b13ee0,1264,LessThan_Baseline
code-creation,Builtin,2,13639,0x107b143e0,1264,GreaterThan_Baseline
code-creation,Builtin,2,13651,0x107b148e0,1264,LessThanOrEqual_Baseline
code-creation,Builtin,2,13665,0x107b14de0,1264,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,13679,0x107b152e0,1624,Equal_WithFeedback
code-creation,Builtin,2,13692,0x107b15940,940,StrictEqual_WithFeedback
code-creation,Builtin,2,13705,0x107b15d00,1240,LessThan_WithFeedback
code-creation,Builtin,2,13733,0x107b161e0,1240,GreaterThan_WithFeedback
code-creation,Builtin,2,13748,0x107b166c0,1240,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,13761,0x107b16ba0,1240,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,13775,0x107b17080,332,BitwiseNot_Baseline
code-creation,Builtin,2,13788,0x107b171e0,460,Decrement_Baseline
code-creation,Builtin,2,13802,0x107b173c0,464,Increment_Baseline
code-creation,Builtin,2,13815,0x107b175a0,488,Negate_Baseline
code-creation,Builtin,2,13827,0x107b177a0,316,BitwiseNot_WithFeedback
code-creation,Builtin,2,13841,0x107b178e0,440,Decrement_WithFeedback
code-creation,Builtin,2,13854,0x107b17aa0,444,Increment_WithFeedback
code-creation,Builtin,2,13867,0x107b17c60,472,Negate_WithFeedback
code-creation,Builtin,2,13880,0x107b17e40,252,ObjectAssign
code-creation,Builtin,2,13893,0x107b17f40,864,ObjectCreate
code-creation,Builtin,2,13903,0x107b182c0,12,ObjectDefineGetter
code-creation,Builtin,2,13915,0x107b182e0,12,ObjectDefineProperties
code-creation,Builtin,2,13929,0x107b18300,12,ObjectDefineProperty
code-creation,Builtin,2,13942,0x107b18320,12,ObjectDefineSetter
code-creation,Builtin,2,13955,0x107b18340,1512,ObjectEntries
code-creation,Builtin,2,13968,0x107b18940,12,ObjectFreeze
code-creation,Builtin,2,13980,0x107b18960,5592,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,13994,0x107b19f40,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,14008,0x107b19f60,600,ObjectGetOwnPropertyNames
code-creation,Builtin,2,14021,0x107b1a1c0,12,ObjectGetOwnPropertySymbols
tick,0x7ff803e80e9a,14041,0,0x0,6
tick,0x7ff803e80bef,14069,0,0x0,6
code-creation,Builtin,2,14087,0x107b1a1e0,164,ObjectHasOwn
code-creation,Builtin,2,14102,0x107b1a2a0,388,ObjectIs
code-creation,Builtin,2,14111,0x107b1a440,12,ObjectIsFrozen
code-creation,Builtin,2,14120,0x107b1a460,12,ObjectIsSealed
code-creation,Builtin,2,14129,0x107b1a480,536,ObjectKeys
code-creation,Builtin,2,14138,0x107b1a6a0,12,ObjectLookupGetter
code-creation,Builtin,2,14148,0x107b1a6c0,12,ObjectLookupSetter
code-creation,Builtin,2,14157,0x107b1a6e0,2264,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,14167,0x107b1afc0,216,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,14177,0x107b1b0a0,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,14187,0x107b1b0c0,12,ObjectPrototypeGetProto
code-creation,Builtin,2,14197,0x107b1b0e0,12,ObjectPrototypeSetProto
code-creation,Builtin,2,14206,0x107b1b100,12,ObjectSeal
code-creation,Builtin,2,14216,0x107b1b120,1108,ObjectToString
code-creation,Builtin,2,14225,0x107b1b580,1280,ObjectValues
code-creation,Builtin,2,14234,0x107b1baa0,280,OrdinaryHasInstance
code-creation,Builtin,2,14243,0x107b1bbc0,344,InstanceOf
code-creation,Builtin,2,14252,0x107b1bd20,628,InstanceOf_WithFeedback
code-creation,Builtin,2,14262,0x107b1bfa0,648,InstanceOf_Baseline
code-creation,Builtin,2,14271,0x107b1c240,268,ForInEnumerate
code-creation,Builtin,2,14280,0x107b1c360,148,ForInPrepare
code-creation,Builtin,2,14290,0x107b1c400,2576,ForInFilter
code-creation,Builtin,2,14299,0x107b1ce20,52,ReflectApply
code-creation,Builtin,2,14308,0x107b1ce60,60,ReflectConstruct
code-creation,Builtin,2,14317,0x107b1cea0,12,ReflectDefineProperty
code-creation,Builtin,2,14326,0x107b1cec0,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,14336,0x107b1cee0,12,ReflectOwnKeys
code-creation,Builtin,2,14345,0x107b1cf00,12,ReflectSet
code-creation,Builtin,2,14354,0x107b1cf20,12,RegExpCapture1Getter
code-creation,Builtin,2,14365,0x107b1cf40,12,RegExpCapture2Getter
code-creation,Builtin,2,14374,0x107b1cf60,12,RegExpCapture3Getter
code-creation,Builtin,2,14384,0x107b1cf80,12,RegExpCapture4Getter
code-creation,Builtin,2,14393,0x107b1cfa0,12,RegExpCapture5Getter
code-creation,Builtin,2,14403,0x107b1cfc0,12,RegExpCapture6Getter
code-creation,Builtin,2,14412,0x107b1cfe0,12,RegExpCapture7Getter
code-creation,Builtin,2,14422,0x107b1d000,12,RegExpCapture8Getter
code-creation,Builtin,2,14431,0x107b1d020,12,RegExpCapture9Getter
code-creation,Builtin,2,14441,0x107b1d040,2212,RegExpConstructor
code-creation,Builtin,2,14478,0x107b1d900,12,RegExpInputGetter
code-creation,Builtin,2,14489,0x107b1d920,12,RegExpInputSetter
code-creation,Builtin,2,14500,0x107b1d940,12,RegExpLastMatchGetter
code-creation,Builtin,2,14510,0x107b1d960,12,RegExpLastParenGetter
code-creation,Builtin,2,14519,0x107b1d980,12,RegExpLeftContextGetter
code-creation,Builtin,2,14529,0x107b1d9a0,908,RegExpPrototypeCompile
code-creation,Builtin,2,14540,0x107b1dd40,12,RegExpPrototypeToString
code-creation,Builtin,2,14549,0x107b1dd60,12,RegExpRightContextGetter
code-creation,Builtin,2,14559,0x107b1dd80,248,RegExpExecAtom
code-creation,Builtin,2,14568,0x107b1de80,1024,RegExpExecInternal
code-creation,Builtin,2,14578,0x107b1e2a0,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,14588,0x107b1e2c0,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,14598,0x107b1e2e0,2676,SetConstructor
code-creation,Builtin,2,14608,0x107b1ed60,1276,SetPrototypeHas
code-creation,Builtin,2,14617,0x107b1f260,1708,SetPrototypeAdd
code-creation,Builtin,2,14627,0x107b1f920,1476,SetPrototypeDelete
code-creation,Builtin,2,14637,0x107b1ff00,12,SetPrototypeClear
code-creation,Builtin,2,14647,0x107b1ff20,284,SetPrototypeEntries
code-creation,Builtin,2,14657,0x107b20040,144,SetPrototypeGetSize
code-creation,Builtin,2,14667,0x107b200e0,444,SetPrototypeForEach
code-creation,Builtin,2,14677,0x107b202a0,284,SetPrototypeValues
code-creation,Builtin,2,14687,0x107b203c0,984,SetIteratorPrototypeNext
code-creation,Builtin,2,14698,0x107b207a0,1104,SetOrSetIteratorToList
code-creation,Builtin,2,14709,0x107b20c00,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,14720,0x107b20c20,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,14731,0x107b20c40,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,14742,0x107b20c60,1280,AtomicsLoad
code-creation,Builtin,2,14752,0x107b21180,1008,AtomicsStore
code-creation,Builtin,2,14762,0x107b21580,1704,AtomicsExchange
code-creation,Builtin,2,14772,0x107b21c40,2092,AtomicsCompareExchange
code-creation,Builtin,2,14783,0x107b22480,1804,AtomicsAdd
code-creation,Builtin,2,14793,0x107b22ba0,1804,AtomicsSub
code-creation,Builtin,2,14803,0x107b232c0,1804,AtomicsAnd
code-creation,Builtin,2,14813,0x107b239e0,1804,AtomicsOr
code-creation,Builtin,2,14822,0x107b24100,1804,AtomicsXor
code-creation,Builtin,2,14832,0x107b24820,12,AtomicsNotify
code-creation,Builtin,2,14842,0x107b24840,12,AtomicsIsLockFree
code-creation,Builtin,2,14858,0x107b24860,12,AtomicsWait
code-creation,Builtin,2,14904,0x107b24880,12,AtomicsWaitAsync
code-creation,Builtin,2,14919,0x107b248a0,12,StringFromCodePoint
code-creation,Builtin,2,14933,0x107b248c0,1428,StringFromCharCode
code-creation,Builtin,2,14947,0x107b24e60,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,14961,0x107b24e80,4360,StringPrototypeMatchAll
code-creation,Builtin,2,14976,0x107b25fa0,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,14988,0x107b25fc0,1228,StringPrototypeReplace
code-creation,Builtin,2,15001,0x107b264a0,2896,StringPrototypeSplit
code-creation,Builtin,2,15015,0x107b27000,12,StringRaw
code-creation,Builtin,2,15031,0x107b27020,12,SymbolConstructor
code-creation,Builtin,2,15053,0x107b27040,12,SymbolFor
code-creation,Builtin,2,15067,0x107b27060,12,SymbolKeyFor
code-creation,Builtin,2,15079,0x107b27080,88,TypedArrayBaseConstructor
code-creation,Builtin,2,15093,0x107b270e0,256,TypedArrayConstructor
code-creation,Builtin,2,15107,0x107b27200,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,15121,0x107b27220,884,TypedArrayPrototypeByteLength
code-creation,Builtin,2,15135,0x107b275a0,368,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,15150,0x107b27720,588,TypedArrayPrototypeLength
code-creation,Builtin,2,15164,0x107b27980,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,15179,0x107b279a0,12,TypedArrayPrototypeFill
code-creation,Builtin,2,15193,0x107b279c0,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,15208,0x107b279e0,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,15224,0x107b27a00,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,15239,0x107b27a20,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,15281,0x107b27a40,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,15300,0x107b27b80,10648,TypedArrayPrototypeMap
code-creation,Builtin,2,15320,0x107b2a520,792,GenericJSToWasmWrapper
code-creation,Builtin,2,15334,0x107b2a840,148,WasmCompileLazy
code-creation,Builtin,2,15348,0x107b2a8e0,168,WasmDebugBreak
code-creation,Builtin,2,15361,0x107b2a9a0,16,WasmOnStackReplace
code-creation,Builtin,2,15376,0x107b2a9c0,140,WasmFloat32ToNumber
code-creation,Builtin,2,15390,0x107b2aa60,152,WasmFloat64ToNumber
code-creation,Builtin,2,15403,0x107b2ab00,4,WasmI32AtomicWait32
code-creation,Builtin,2,15416,0x107b2ab20,4,WasmI64AtomicWait32
code-creation,Builtin,2,15428,0x107b2ab40,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,15442,0x107b2ab60,4316,WeakMapConstructor
code-creation,Builtin,2,15457,0x107b2bc40,196,WeakMapLookupHashIndex
code-creation,Builtin,2,15471,0x107b2bd20,220,WeakMapGet
code-creation,Builtin,2,15483,0x107b2be00,176,WeakMapPrototypeHas
code-creation,Builtin,2,15494,0x107b2bec0,204,WeakMapPrototypeSet
code-creation,Builtin,2,15510,0x107b2bfa0,144,WeakMapPrototypeDelete
code-creation,Builtin,2,15523,0x107b2c040,2876,WeakSetConstructor
code-creation,Builtin,2,15535,0x107b2cb80,176,WeakSetPrototypeHas
code-creation,Builtin,2,15544,0x107b2cc40,204,WeakSetPrototypeAdd
code-creation,Builtin,2,15554,0x107b2cd20,144,WeakSetPrototypeDelete
code-creation,Builtin,2,15563,0x107b2cdc0,372,WeakCollectionDelete
code-creation,Builtin,2,15572,0x107b2cf40,768,WeakCollectionSet
code-creation,Builtin,2,15584,0x107b2d260,296,AsyncGeneratorResolve
code-creation,Builtin,2,15597,0x107b2d3a0,100,AsyncGeneratorReject
code-creation,Builtin,2,15610,0x107b2d420,2760,AsyncGeneratorYield
code-creation,Builtin,2,15623,0x107b2df00,2872,AsyncGeneratorReturn
code-creation,Builtin,2,15636,0x107b2ea40,292,AsyncGeneratorResumeNext
code-creation,Builtin,2,15649,0x107b2eb80,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,15661,0x107b2eba0,1016,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,15671,0x107b2efa0,1024,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,15681,0x107b2f3c0,1024,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,15691,0x107b2f7e0,2736,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,15704,0x107b302a0,2736,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,15717,0x107b30d60,116,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,15731,0x107b30de0,128,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,15744,0x107b30e80,116,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,15758,0x107b30f00,116,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,15771,0x107b30f80,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,15786,0x107b31000,128,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,15799,0x107b310a0,1592,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,15813,0x107b316e0,1696,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,15824,0x107b31da0,1716,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,15837,0x107b32460,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,15847,0x107b324e0,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,15863,0x107b325c0,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,15878,0x107b326a0,204,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,15894,0x107b32780,396,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,15926,0x107b32920,396,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,15944,0x107b32ac0,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,15957,0x107b32ba0,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,15970,0x107b32c80,204,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,15984,0x107b32d60,396,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,16011,0x107b32f00,396,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,16025,0x107b330a0,4,DirectCEntry
code-creation,Builtin,2,16036,0x107b330c0,1096,StringAdd_CheckNone
code-creation,Builtin,2,16049,0x107b33520,2480,SubString
code-creation,Builtin,2,16061,0x107b33ee0,16,StackCheck
code-creation,Builtin,2,16072,0x107b33f00,84,DoubleToI
code-creation,Builtin,2,16081,0x107b33f60,2236,GetProperty
code-creation,Builtin,2,16090,0x107b34820,2308,GetPropertyWithReceiver
code-creation,Builtin,2,16100,0x107b35140,15844,SetProperty
code-creation,Builtin,2,16109,0x107b38f40,13404,SetPropertyInLiteral
code-creation,Builtin,2,16118,0x107b3c3a0,8,MemCopyUint8Uint8
code-creation,Builtin,2,16130,0x107b3c3c0,8,MemMove
code-creation,Builtin,2,16141,0x107b3c3e0,12,IsTraceCategoryEnabled
code-creation,Builtin,2,16152,0x107b3c400,12,Trace
code-creation,Builtin,2,16160,0x107b3c420,12,FinalizationRegistryUnregister
code-creation,Builtin,2,16171,0x107b3c440,416,AsyncModuleEvaluate
code-creation,Builtin,2,16180,0x107b3c600,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,16194,0x107b3c620,12,CallAsyncModuleRejected
code-creation,Builtin,2,16206,0x107b3c640,260,AggregateErrorConstructor
code-creation,Builtin,2,16217,0x107b3c760,856,ArrayPrototypeAt
code-creation,Builtin,2,16226,0x107b3cac0,656,ArrayPrototypeConcat
code-creation,Builtin,2,16235,0x107b3cd60,5820,ArrayPrototypeCopyWithin
code-creation,Builtin,2,16245,0x107b3e420,212,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,16258,0x107b3e500,612,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,16272,0x107b3e780,3256,ArrayEveryLoopContinuation
code-creation,Builtin,2,16285,0x107b3f440,1464,ArrayEvery
code-creation,Builtin,2,16296,0x107b3fa00,284,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,16307,0x107b3fb20,988,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,16318,0x107b3ff00,3560,ArrayFilterLoopContinuation
code-creation,Builtin,2,16327,0x107b40d00,4248,ArrayFilter
code-creation,Builtin,2,16336,0x107b41da0,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,16347,0x107b41e80,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,16360,0x107b41ec0,312,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,16374,0x107b42000,528,ArrayFindLoopContinuation
code-creation,Builtin,2,16387,0x107b42220,1460,ArrayPrototypeFind
code-creation,Builtin,2,16400,0x107b427e0,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,16413,0x107b428c0,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,16427,0x107b42900,312,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,16441,0x107b42a40,524,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,16452,0x107b42c60,1460,ArrayPrototypeFindIndex
code-creation,Builtin,2,16462,0x107b43220,448,ArrayFindLastLoopContinuation
code-creation,Builtin,2,16472,0x107b43400,1700,ArrayPrototypeFindLast
code-creation,Builtin,2,16482,0x107b43ac0,448,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,16495,0x107b43ca0,1700,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,16507,0x107b44360,212,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,16518,0x107b44440,212,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,16529,0x107b44520,3144,ArrayForEachLoopContinuation
code-creation,Builtin,2,16542,0x107b45180,1328,ArrayForEach
code-creation,Builtin,2,16554,0x107b456c0,3572,ArrayFrom
code-creation,Builtin,2,16566,0x107b464c0,148,ArrayIsArray
code-creation,Builtin,2,16577,0x107b46560,408,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,16591,0x107b46700,36,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,16605,0x107b46740,140,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,16618,0x107b467e0,312,ConvertToLocaleString
code-creation,Builtin,2,16631,0x107b46920,748,JoinStackPush
code-creation,Builtin,2,16643,0x107b46c20,268,JoinStackPop
code-creation,Builtin,2,16655,0x107b46d40,6620,ArrayPrototypeJoin
code-creation,Builtin,2,16667,0x107b48720,5360,ArrayPrototypeToLocaleString
code-creation,Builtin,2,16692,0x107b49c20,236,ArrayPrototypeToString
code-creation,Builtin,2,16706,0x107b49d20,5924,TypedArrayPrototypeJoin
code-creation,Builtin,2,16719,0x107b4b460,4640,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,16731,0x107b4c6a0,3824,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,16741,0x107b4d5a0,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,16752,0x107b4d6c0,252,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,16762,0x107b4d7c0,532,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,16775,0x107b4d9e0,3188,ArrayMapLoopContinuation
code-creation,Builtin,2,16788,0x107b4e660,3904,ArrayMap
code-creation,Builtin,2,16800,0x107b4f5c0,1000,ArrayOf
code-creation,Builtin,2,16810,0x107b4f9c0,444,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,16821,0x107b4fb80,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,16833,0x107b4fc60,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,16844,0x107b4fd40,3204,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,16855,0x107b509e0,2000,ArrayReduceRight
code-creation,Builtin,2,16867,0x107b511c0,176,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,16881,0x107b51280,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,16896,0x107b51360,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,16907,0x107b51440,3216,ArrayReduceLoopContinuation
code-creation,Builtin,2,16919,0x107b520e0,1604,ArrayReduce
code-creation,Builtin,2,16929,0x107b52740,3208,ArrayPrototypeReverse
code-creation,Builtin,2,16941,0x107b533e0,3604,ArrayPrototypeShift
code-creation,Builtin,2,16952,0x107b54200,5172,ArrayPrototypeSlice
code-creation,Builtin,2,16962,0x107b55640,212,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,16980,0x107b55720,580,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,16992,0x107b55980,3244,ArraySomeLoopContinuation
code-creation,Builtin,2,17001,0x107b56640,1448,ArraySome
code-creation,Builtin,2,17013,0x107b56c00,14208,ArrayPrototypeSplice
code-creation,Builtin,2,17025,0x107b5a3a0,3268,ArrayPrototypeUnshift
tick,0x7ff803e80db7,17052,0,0x0,6
tick,0x7ff803e4ad06,17081,0,0x0,6
tick,0x7ff803e4ad06,17094,0,0x0,6
code-creation,Builtin,2,17108,0x107b5b080,332,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,17124,0x107b5b1e0,348,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,17135,0x107b5b340,208,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,17146,0x107b5b420,332,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,17157,0x107b5b580,208,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,17168,0x107b5b660,96,ArrayBufferIsView
code-creation,Builtin,2,17177,0x107b5b6e0,396,ToInteger
code-creation,Builtin,2,17185,0x107b5b880,3068,FastCreateDataProperty
code-creation,Builtin,2,17195,0x107b5c480,676,CheckNumberInRange
code-creation,Builtin,2,17204,0x107b5c740,584,CheckSameObject
code-creation,Builtin,2,17213,0x107b5c9a0,904,BooleanConstructor
code-creation,Builtin,2,17222,0x107b5cd40,164,BooleanPrototypeToString
code-creation,Builtin,2,17232,0x107b5ce00,156,BooleanPrototypeValueOf
code-creation,Builtin,2,17242,0x107b5cea0,1180,BigIntAddNoThrow
code-creation,Builtin,2,17251,0x107b5d340,1276,BigIntAdd
code-creation,Builtin,2,17259,0x107b5d840,1180,BigIntSubtractNoThrow
code-creation,Builtin,2,17269,0x107b5dce0,1276,BigIntSubtract
code-creation,Builtin,2,17277,0x107b5e1e0,284,BigIntUnaryMinus
code-creation,Builtin,2,17286,0x107b5e300,1356,ToString
code-creation,Builtin,2,17295,0x107b5e860,156,StringPrototypeToString
code-creation,Builtin,2,17304,0x107b5e900,156,StringPrototypeValueOf
code-creation,Builtin,2,17313,0x107b5e9a0,2452,StringToList
code-creation,Builtin,2,17322,0x107b5f340,1012,StringPrototypeCharAt
code-creation,Builtin,2,17332,0x107b5f740,700,StringPrototypeCharCodeAt
code-creation,Builtin,2,17341,0x107b5fa00,1288,StringPrototypeCodePointAt
code-creation,Builtin,2,17351,0x107b5ff20,400,StringPrototypeConcat
code-creation,Builtin,2,17379,0x107b600c0,992,StringConstructor
code-creation,Builtin,2,17389,0x107b604c0,1432,StringAddConvertLeft
code-creation,Builtin,2,17399,0x107b60a60,1460,StringAddConvertRight
code-creation,Builtin,2,17408,0x107b61020,812,StringCharAt
code-creation,Builtin,2,17417,0x107b61360,16,FastNewClosureBaseline
code-creation,Builtin,2,17426,0x107b61380,196,FastNewFunctionContextEval
code-creation,Builtin,2,17436,0x107b61460,196,FastNewFunctionContextFunction
code-creation,Builtin,2,17446,0x107b61540,248,CreateRegExpLiteral
code-creation,Builtin,2,17455,0x107b61640,1080,CreateShallowArrayLiteral
code-creation,Builtin,2,17465,0x107b61a80,496,CreateEmptyArrayLiteral
code-creation,Builtin,2,17474,0x107b61c80,1724,CreateShallowObjectLiteral
code-creation,Builtin,2,17484,0x107b62340,384,ObjectConstructor
code-creation,Builtin,2,17493,0x107b624e0,176,CreateEmptyLiteralObject
code-creation,Builtin,2,17502,0x107b625a0,532,NumberConstructor
code-creation,Builtin,2,17512,0x107b627c0,64,GenericLazyDeoptContinuation
code-creation,Builtin,2,17521,0x107b62820,64,StringToNumber
code-creation,Builtin,2,17530,0x107b62880,184,NonNumberToNumber
code-creation,Builtin,2,17539,0x107b62940,240,NonNumberToNumeric
code-creation,Builtin,2,17548,0x107b62a40,36,ToNumeric
code-creation,Builtin,2,17557,0x107b62a80,1180,NumberToString
code-creation,Builtin,2,17569,0x107b62f20,92,ToBoolean
code-creation,Builtin,2,17607,0x107b62f80,96,ToBooleanForBaselineJump
code-creation,Builtin,2,17619,0x107b63000,728,ToLength
code-creation,Builtin,2,17629,0x107b632e0,1308,ToName
code-creation,Builtin,2,17637,0x107b63800,756,ToObject
code-creation,Builtin,2,17646,0x107b63b00,208,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,17656,0x107b63be0,208,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,17666,0x107b63cc0,208,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,17677,0x107b63da0,288,OrdinaryToPrimitive_Number
code-creation,Builtin,2,17687,0x107b63ee0,288,OrdinaryToPrimitive_String
code-creation,Builtin,2,17697,0x107b64020,216,FastConsoleAssert
code-creation,Builtin,2,17706,0x107b64100,160,DataViewPrototypeGetBuffer
code-creation,Builtin,2,17716,0x107b641c0,336,DataViewPrototypeGetByteLength
code-creation,Builtin,2,17726,0x107b64320,336,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,17736,0x107b64480,572,DataViewPrototypeGetUint8
code-creation,Builtin,2,17746,0x107b646c0,572,DataViewPrototypeGetInt8
code-creation,Builtin,2,17755,0x107b64900,644,DataViewPrototypeGetUint16
code-creation,Builtin,2,17765,0x107b64ba0,644,DataViewPrototypeGetInt16
code-creation,Builtin,2,17775,0x107b64e40,808,DataViewPrototypeGetUint32
code-creation,Builtin,2,17784,0x107b65180,684,DataViewPrototypeGetInt32
code-creation,Builtin,2,17794,0x107b65440,848,DataViewPrototypeGetFloat32
code-creation,Builtin,2,17804,0x107b657a0,912,DataViewPrototypeGetFloat64
code-creation,Builtin,2,17814,0x107b65b40,984,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,17824,0x107b65f20,1004,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,17834,0x107b66320,928,DataViewPrototypeSetUint8
code-creation,Builtin,2,17843,0x107b666e0,928,DataViewPrototypeSetInt8
code-creation,Builtin,2,17853,0x107b66aa0,1028,DataViewPrototypeSetUint16
code-creation,Builtin,2,17863,0x107b66ec0,1028,DataViewPrototypeSetInt16
code-creation,Builtin,2,17872,0x107b672e0,1064,DataViewPrototypeSetUint32
code-creation,Builtin,2,17882,0x107b67720,1064,DataViewPrototypeSetInt32
code-creation,Builtin,2,17892,0x107b67b60,1032,DataViewPrototypeSetFloat32
code-creation,Builtin,2,17902,0x107b67f80,1096,DataViewPrototypeSetFloat64
code-creation,Builtin,2,17911,0x107b683e0,944,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,17921,0x107b687a0,944,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,17931,0x107b68b60,828,FinalizationRegistryConstructor
code-creation,Builtin,2,17941,0x107b68ea0,1136,FinalizationRegistryRegister
code-creation,Builtin,2,17951,0x107b69320,644,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,17962,0x107b695c0,328,FunctionPrototypeHasInstance
code-creation,Builtin,2,17989,0x107b69720,924,FastFunctionPrototypeBind
code-creation,Builtin,2,18000,0x107b69ac0,88,IncBlockCounter
code-creation,Builtin,2,18009,0x107b69b20,236,GetTemplateObject
code-creation,Builtin,2,18018,0x107b69c20,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,18028,0x107b69c40,92,ForInNext
code-creation,Builtin,2,18037,0x107b69ca0,128,GetImportMetaObjectBaseline
code-creation,Builtin,2,18046,0x107b69d40,116,GetIteratorWithFeedback
code-creation,Builtin,2,18056,0x107b69dc0,100,GetIteratorBaseline
code-creation,Builtin,2,18065,0x107b69e40,268,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,18075,0x107b69f60,1076,CallIteratorWithFeedback
code-creation,Builtin,2,18085,0x107b6a3a0,288,MathAbs
code-creation,Builtin,2,18093,0x107b6a4e0,428,MathCeil
code-creation,Builtin,2,18101,0x107b6a6a0,432,MathFloor
code-creation,Builtin,2,18110,0x107b6a860,488,MathRound
code-creation,Builtin,2,18118,0x107b6aa60,428,MathTrunc
code-creation,Builtin,2,18127,0x107b6ac20,364,MathPow
code-creation,Builtin,2,18135,0x107b6ada0,396,MathMax
code-creation,Builtin,2,18143,0x107b6af40,404,MathMin
code-creation,Builtin,2,18151,0x107b6b0e0,320,MathAcos
code-creation,Builtin,2,18159,0x107b6b240,320,MathAcosh
code-creation,Builtin,2,18168,0x107b6b3a0,320,MathAsin
code-creation,Builtin,2,18176,0x107b6b500,320,MathAsinh
code-creation,Builtin,2,18184,0x107b6b660,320,MathAtan
code-creation,Builtin,2,18193,0x107b6b7c0,412,MathAtan2
code-creation,Builtin,2,18201,0x107b6b960,320,MathAtanh
code-creation,Builtin,2,18210,0x107b6bac0,320,MathCbrt
code-creation,Builtin,2,18218,0x107b6bc20,168,MathClz32
code-creation,Builtin,2,18226,0x107b6bce0,320,MathCos
code-creation,Builtin,2,18235,0x107b6be40,320,MathCosh
code-creation,Builtin,2,18243,0x107b6bfa0,320,MathExp
code-creation,Builtin,2,18251,0x107b6c100,320,MathExpm1
code-creation,Builtin,2,18260,0x107b6c260,272,MathFround
code-creation,Builtin,2,18268,0x107b6c380,304,MathImul
code-creation,Builtin,2,18277,0x107b6c4c0,320,MathLog
code-creation,Builtin,2,18285,0x107b6c620,320,MathLog1p
code-creation,Builtin,2,18297,0x107b6c780,320,MathLog10
code-creation,Builtin,2,18306,0x107b6c8e0,320,MathLog2
code-creation,Builtin,2,18314,0x107b6ca40,320,MathSin
code-creation,Builtin,2,18323,0x107b6cba0,180,MathSign
code-creation,Builtin,2,18331,0x107b6cc60,320,MathSinh
code-creation,Builtin,2,18359,0x107b6cdc0,268,MathSqrt
code-creation,Builtin,2,18367,0x107b6cee0,320,MathTan
code-creation,Builtin,2,18376,0x107b6d040,320,MathTanh
code-creation,Builtin,2,18384,0x107b6d1a0,1056,MathHypot
code-creation,Builtin,2,18400,0x107b6d5e0,324,MathRandom
code-creation,Builtin,2,18412,0x107b6d740,2952,NumberPrototypeToString
code-creation,Builtin,2,18422,0x107b6e2e0,136,NumberIsFinite
code-creation,Builtin,2,18431,0x107b6e380,340,NumberIsInteger
code-creation,Builtin,2,18440,0x107b6e4e0,116,NumberIsNaN
code-creation,Builtin,2,18449,0x107b6e560,372,NumberIsSafeInteger
tick,0x7ff803d76d01,18464,0,0x0,6
code-creation,Builtin,2,18491,0x107b6e6e0,156,NumberPrototypeValueOf
code-creation,Builtin,2,18504,0x107b6e780,196,NumberParseFloat
code-creation,Builtin,2,18513,0x107b6e860,248,ParseInt
code-creation,Builtin,2,18521,0x107b6e960,84,NumberParseInt
code-creation,Builtin,2,18530,0x107b6e9c0,860,Add
code-creation,Builtin,2,18538,0x107b6ed20,424,Subtract
code-creation,Builtin,2,18546,0x107b6eee0,608,Multiply
code-creation,Builtin,2,18555,0x107b6f160,532,Divide
code-creation,Builtin,2,18563,0x107b6f380,592,Modulus
code-creation,Builtin,2,18571,0x107b6f5e0,524,Exponentiate
code-creation,Builtin,2,18580,0x107b6f800,344,Negate
code-creation,Builtin,2,18588,0x107b6f960,112,BitwiseNot
code-creation,Builtin,2,18597,0x107b6f9e0,112,Decrement
code-creation,Builtin,2,18605,0x107b6fa60,112,Increment
code-creation,Builtin,2,18614,0x107b6fae0,392,ShiftLeft
code-creation,Builtin,2,18622,0x107b6fc80,392,ShiftRight
code-creation,Builtin,2,18631,0x107b6fe20,508,ShiftRightLogical
code-creation,Builtin,2,18640,0x107b70020,388,BitwiseAnd
code-creation,Builtin,2,18648,0x107b701c0,388,BitwiseOr
code-creation,Builtin,2,18657,0x107b70360,388,BitwiseXor
code-creation,Builtin,2,18678,0x107b70500,796,LessThan
code-creation,Builtin,2,18688,0x107b70820,796,LessThanOrEqual
code-creation,Builtin,2,18697,0x107b70b40,796,GreaterThan
code-creation,Builtin,2,18706,0x107b70e60,796,GreaterThanOrEqual
code-creation,Builtin,2,18715,0x107b71180,860,Equal
code-creation,Builtin,2,18723,0x107b714e0,348,StrictEqual
code-creation,Builtin,2,18732,0x107b71640,3132,ObjectFromEntries
code-creation,Builtin,2,18741,0x107b72280,756,CreateObjectWithoutProperties
code-creation,Builtin,2,18751,0x107b72580,144,ObjectIsExtensible
code-creation,Builtin,2,18761,0x107b72620,148,ObjectPreventExtensions
code-creation,Builtin,2,18770,0x107b726c0,144,ObjectGetPrototypeOf
code-creation,Builtin,2,18780,0x107b72760,300,ObjectSetPrototypeOf
code-creation,Builtin,2,18789,0x107b728a0,80,ObjectPrototypeToString
code-creation,Builtin,2,18798,0x107b72900,96,ObjectPrototypeValueOf
code-creation,Builtin,2,18808,0x107b72980,164,ObjectPrototypeToLocaleString
code-creation,Builtin,2,18818,0x107b72a40,860,FulfillPromise
code-creation,Builtin,2,18827,0x107b72da0,980,RejectPromise
code-creation,Builtin,2,18835,0x107b73180,2412,NewPromiseCapability
code-creation,Builtin,2,18845,0x107b73b00,164,PromiseCapabilityDefaultReject
code-creation,Builtin,2,18855,0x107b73bc0,148,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,18865,0x107b73c60,1412,PerformPromiseThen
code-creation,Builtin,2,18874,0x107b74200,648,PromiseReject
code-creation,Builtin,2,18883,0x107b744a0,292,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,18893,0x107b745e0,104,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,18904,0x107b74660,4556,PromiseAll
code-creation,Builtin,2,18912,0x107b75840,4876,PromiseAllSettled
code-creation,Builtin,2,18921,0x107b76b60,1100,PromiseAllResolveElementClosure
code-creation,Builtin,2,18932,0x107b76fc0,1388,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,18942,0x107b77540,1396,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,18953,0x107b77ac0,1172,PromiseAnyRejectElementClosure
code-creation,Builtin,2,19015,0x107b77f60,2368,PromiseAny
code-creation,Builtin,2,19037,0x107b788c0,2908,PromiseConstructor
code-creation,Builtin,2,19048,0x107b79420,296,PromisePrototypeCatch
code-creation,Builtin,2,19058,0x107b79560,88,PromiseValueThunkFinally
code-creation,Builtin,2,19068,0x107b795c0,84,PromiseThrowerFinally
code-creation,Builtin,2,19078,0x107b79620,904,PromiseCatchFinally
code-creation,Builtin,2,19087,0x107b799c0,904,PromiseThenFinally
code-creation,Builtin,2,19096,0x107b79d60,1700,PromisePrototypeFinally
code-creation,Builtin,2,19106,0x107b7a420,1336,PromiseRace
code-creation,Builtin,2,19115,0x107b7a960,268,PromiseFulfillReactionJob
code-creation,Builtin,2,19125,0x107b7aa80,364,PromiseRejectReactionJob
code-creation,Builtin,2,19134,0x107b7ac00,156,PromiseResolveTrampoline
code-creation,Builtin,2,19144,0x107b7aca0,656,PromiseResolve
code-creation,Builtin,2,19153,0x107b7af40,712,ResolvePromise
code-creation,Builtin,2,19162,0x107b7b220,2220,PromisePrototypeThen
code-creation,Builtin,2,19171,0x107b7bae0,1144,PromiseResolveThenableJob
code-creation,Builtin,2,19181,0x107b7bf60,448,ProxyConstructor
code-creation,Builtin,2,19190,0x107b7c140,1760,ProxyDeleteProperty
code-creation,Builtin,2,19199,0x107b7c840,2112,ProxyGetProperty
code-creation,Builtin,2,19208,0x107b7d0a0,1060,ProxyGetPrototypeOf
code-creation,Builtin,2,19217,0x107b7d4e0,1668,ProxyHasProperty
code-creation,Builtin,2,19226,0x107b7db80,760,ProxyIsExtensible
code-creation,Builtin,2,19241,0x107b7de80,800,ProxyPreventExtensions
code-creation,Builtin,2,19250,0x107b7e1c0,1148,ProxyRevocable
code-creation,Builtin,2,19259,0x107b7e640,120,ProxyRevoke
code-creation,Builtin,2,19267,0x107b7e6c0,2216,ProxySetProperty
code-creation,Builtin,2,19276,0x107b7ef80,1292,ProxySetPrototypeOf
code-creation,Builtin,2,19286,0x107b7f4a0,208,ReflectIsExtensible
code-creation,Builtin,2,19295,0x107b7f580,212,ReflectPreventExtensions
code-creation,Builtin,2,19304,0x107b7f660,188,ReflectGetPrototypeOf
code-creation,Builtin,2,19314,0x107b7f720,292,ReflectSetPrototypeOf
code-creation,Builtin,2,19340,0x107b7f860,284,ReflectGet
code-creation,Builtin,2,19350,0x107b7f980,160,ReflectDeleteProperty
code-creation,Builtin,2,19359,0x107b7fa40,148,ReflectHas
code-creation,Builtin,2,19368,0x107b7fae0,5108,RegExpPrototypeExecSlow
code-creation,Builtin,2,19377,0x107b80ee0,5100,RegExpPrototypeExec
code-creation,Builtin,2,19413,0x107b822e0,2360,RegExpPrototypeMatchAll
code-creation,Builtin,2,19426,0x107b82c20,9384,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,19440,0x107b850e0,8796,RegExpMatchFast
code-creation,Builtin,2,19451,0x107b87340,3592,RegExpPrototypeMatch
code-creation,Builtin,2,19463,0x107b88160,6304,RegExpReplace
code-creation,Builtin,2,19473,0x107b89a20,524,RegExpPrototypeReplace
code-creation,Builtin,2,19484,0x107b89c40,1400,RegExpSearchFast
code-creation,Builtin,2,19498,0x107b8a1c0,1640,RegExpPrototypeSearch
code-creation,Builtin,2,19510,0x107b8a840,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,19520,0x107b8a920,5784,RegExpSplit
code-creation,Builtin,2,19528,0x107b8bfc0,476,RegExpPrototypeSplit
code-creation,Builtin,2,19538,0x107b8c1a0,2236,RegExpPrototypeTest
code-creation,Builtin,2,19547,0x107b8ca60,1348,RegExpPrototypeTestFast
code-creation,Builtin,2,19556,0x107b8cfc0,228,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,19568,0x107b8d0c0,244,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,19581,0x107b8d1c0,244,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,19594,0x107b8d2c0,244,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,19607,0x107b8d3c0,244,RegExpPrototypeLinearGetter
code-creation,Builtin,2,19620,0x107b8d4c0,244,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,19633,0x107b8d5c0,272,RegExpPrototypeStickyGetter
code-creation,Builtin,2,19645,0x107b8d6e0,272,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,19657,0x107b8d800,2256,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,19668,0x107b8e0e0,1500,StringPrototypeAt
code-creation,Builtin,2,19677,0x107b8e6c0,2992,StringPrototypeEndsWith
code-creation,Builtin,2,19686,0x107b8f280,480,CreateHTML
code-creation,Builtin,2,19695,0x107b8f480,164,StringPrototypeAnchor
code-creation,Builtin,2,19706,0x107b8f540,128,StringPrototypeBig
code-creation,Builtin,2,19718,0x107b8f5e0,128,StringPrototypeBlink
code-creation,Builtin,2,19728,0x107b8f680,128,StringPrototypeBold
code-creation,Builtin,2,19737,0x107b8f720,168,StringPrototypeFontcolor
code-creation,Builtin,2,19746,0x107b8f7e0,168,StringPrototypeFontsize
code-creation,Builtin,2,19756,0x107b8f8a0,128,StringPrototypeFixed
code-creation,Builtin,2,19769,0x107b8f940,128,StringPrototypeItalics
code-creation,Builtin,2,19780,0x107b8f9e0,168,StringPrototypeLink
code-creation,Builtin,2,19790,0x107b8faa0,128,StringPrototypeSmall
code-creation,Builtin,2,19799,0x107b8fb40,128,StringPrototypeStrike
code-creation,Builtin,2,19808,0x107b8fbe0,128,StringPrototypeSub
code-creation,Builtin,2,19817,0x107b8fc80,128,StringPrototypeSup
code-creation,Builtin,2,19831,0x107b8fd20,1028,StringPrototypeIncludes
code-creation,Builtin,2,19843,0x107b90140,628,StringPrototypeIndexOf
code-creation,Builtin,2,19856,0x107b903c0,344,StringPrototypeIterator
code-creation,Builtin,2,19868,0x107b90520,2028,StringIteratorPrototypeNext
code-creation,Builtin,2,19880,0x107b90d20,1304,StringPrototypeMatch
code-creation,Builtin,2,19892,0x107b91240,1304,StringPrototypeSearch
code-creation,Builtin,2,19905,0x107b91760,824,StringPrototypePadStart
code-creation,Builtin,2,19917,0x107b91aa0,824,StringPrototypePadEnd
code-creation,Builtin,2,19929,0x107b91de0,120,StringRepeat
code-creation,Builtin,2,19940,0x107b91e60,400,StringPrototypeRepeat
code-creation,Builtin,2,19953,0x107b92000,10964,StringPrototypeReplaceAll
code-creation,Builtin,2,19966,0x107b94ae0,3384,StringPrototypeSlice
code-creation,Builtin,2,19978,0x107b95820,3004,StringPrototypeStartsWith
code-creation,Builtin,2,19991,0x107b963e0,3324,StringPrototypeSubstr
code-creation,Builtin,2,20003,0x107b970e0,3260,StringPrototypeSubstring
code-creation,Builtin,2,20016,0x107b97da0,6904,StringPrototypeTrim
code-creation,Builtin,2,20041,0x107b998a0,6316,StringPrototypeTrimStart
code-creation,Builtin,2,20052,0x107b9b160,5840,StringPrototypeTrimEnd
code-creation,Builtin,2,20062,0x107b9c840,160,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,20072,0x107b9c900,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,20085,0x107b9c9a0,172,SymbolPrototypeToString
code-creation,Builtin,2,20097,0x107b9ca60,156,SymbolPrototypeValueOf
code-creation,Builtin,2,20107,0x107b9cb00,832,TypedArrayPrototypeAt
code-creation,Builtin,2,20117,0x107b9ce60,10004,CreateTypedArray
code-creation,Builtin,2,20125,0x107b9f580,1000,TypedArrayPrototypeEvery
code-creation,Builtin,2,20138,0x107b9f980,372,TypedArrayPrototypeEntries
code-creation,Builtin,2,20150,0x107b9fb00,3508,TypedArrayPrototypeFilter
code-creation,Builtin,2,20163,0x107ba08c0,996,TypedArrayPrototypeFind
code-creation,Builtin,2,20175,0x107ba0cc0,1004,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,20188,0x107ba10c0,428,FindLastAllElementsDetachedContinuation
code-creation,Builtin,2,20202,0x107ba1280,1208,TypedArrayPrototypeFindLast
code-creation,Builtin,2,20215,0x107ba1740,436,FindLastIndexAllElementsDetachedContinuation
code-creation,Builtin,2,20229,0x107ba1900,1216,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,20242,0x107ba1de0,864,TypedArrayPrototypeForEach
code-creation,Builtin,2,20255,0x107ba2160,2352,TypedArrayFrom
code-creation,Builtin,2,20267,0x107ba2aa0,356,TypedArrayPrototypeKeys
code-creation,Builtin,2,20280,0x107ba2c20,1028,TypedArrayOf
code-creation,Builtin,2,20291,0x107ba3040,952,TypedArrayPrototypeReduce
code-creation,Builtin,2,20304,0x107ba3400,944,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,20317,0x107ba37c0,2496,TypedArrayPrototypeSet
code-creation,Builtin,2,20329,0x107ba41a0,3028,TypedArrayPrototypeSlice
code-creation,Builtin,2,20342,0x107ba4d80,992,TypedArrayPrototypeSome
code-creation,Builtin,2,20354,0x107ba5180,1052,TypedArrayMergeSort
code-creation,Builtin,2,20367,0x107ba55a0,1616,TypedArrayPrototypeSort
code-creation,Builtin,2,20379,0x107ba5c00,2736,TypedArrayPrototypeSubArray
code-creation,Builtin,2,20392,0x107ba66c0,372,TypedArrayPrototypeValues
code-creation,Builtin,2,20417,0x107ba6840,956,WeakRefConstructor
code-creation,Builtin,2,20430,0x107ba6c00,184,WeakRefDeref
code-creation,Builtin,2,20442,0x107ba6cc0,680,NewSloppyArgumentsElements
code-creation,Builtin,2,20456,0x107ba6f80,296,NewStrictArgumentsElements
code-creation,Builtin,2,20469,0x107ba70c0,320,NewRestArgumentsElements
tick,0x7ff803e15790,20491,0,0x0,6
tick,0x7ff803e80c86,20518,0,0x0,6
code-creation,Builtin,2,20534,0x107ba7220,1388,FastNewSloppyArguments
code-creation,Builtin,2,20549,0x107ba77a0,524,FastNewStrictArguments
code-creation,Builtin,2,20559,0x107ba79c0,556,FastNewRestArguments
code-creation,Builtin,2,20569,0x107ba7c00,676,StringSlowFlatten
code-creation,Builtin,2,20578,0x107ba7ec0,2000,StringIndexOf
code-creation,Builtin,2,20587,0x107ba86a0,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,20597,0x107ba86c0,20,TestHelperPlus1
code-creation,Builtin,2,20606,0x107ba86e0,20,TestHelperPlus2
code-creation,Builtin,2,20615,0x107ba8700,96,NewSmiBox
code-creation,Builtin,2,20624,0x107ba8780,24,ReturnTwoValues
code-creation,Builtin,2,20633,0x107ba87a0,32,Load_FastSmiElements_0
code-creation,Builtin,2,20642,0x107ba87e0,32,Load_FastObjectElements_0
code-creation,Builtin,2,20652,0x107ba8820,144,Load_FastDoubleElements_0
code-creation,Builtin,2,20662,0x107ba88c0,32,Store_FastSmiElements_0
code-creation,Builtin,2,20671,0x107ba8900,92,Store_FastObjectElements_0
code-creation,Builtin,2,20681,0x107ba8960,48,Store_FastDoubleElements_0
code-creation,Builtin,2,20691,0x107ba89a0,36,Delete_FastSmiElements_0
code-creation,Builtin,2,20701,0x107ba89e0,36,Delete_FastObjectElements_0
code-creation,Builtin,2,20711,0x107ba8a20,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,20720,0x107ba8a60,308,SortCompareDefault
code-creation,Builtin,2,20729,0x107ba8ba0,92,SortCompareUserFn
code-creation,Builtin,2,20738,0x107ba8c00,8,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,20749,0x107ba8c20,308,Copy
code-creation,Builtin,2,20774,0x107ba8d60,5732,MergeAt
code-creation,Builtin,2,20784,0x107baa3e0,792,GallopLeft
code-creation,Builtin,2,20792,0x107baa700,832,GallopRight
code-creation,Builtin,2,20801,0x107baaa60,3820,ArrayTimSort
code-creation,Builtin,2,20810,0x107bab960,2096,ArrayPrototypeSort
code-creation,Builtin,2,20819,0x107bac1a0,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,20828,0x107bac220,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,20838,0x107bac2a0,76,WasmTaggedToFloat64
code-creation,Builtin,2,20847,0x107bac300,72,WasmMemoryGrow
code-creation,Builtin,2,20856,0x107bac360,100,WasmTableInit
code-creation,Builtin,2,20878,0x107bac3e0,100,WasmTableCopy
code-creation,Builtin,2,20887,0x107bac460,84,WasmTableFill
code-creation,Builtin,2,20896,0x107bac4c0,72,WasmTableGrow
code-creation,Builtin,2,20905,0x107bac520,144,WasmTableGet
code-creation,Builtin,2,20914,0x107bac5c0,236,WasmTableSet
code-creation,Builtin,2,20922,0x107bac6c0,88,WasmRefFunc
code-creation,Builtin,2,20931,0x107bac720,144,WasmAllocateFixedArray
code-creation,Builtin,2,20941,0x107bac7c0,44,WasmThrow
code-creation,Builtin,2,20949,0x107bac800,52,WasmRethrow
code-creation,Builtin,2,20958,0x107bac840,44,WasmTriggerTierUp
code-creation,Builtin,2,20967,0x107bac880,32,WasmStackGuard
code-creation,Builtin,2,20976,0x107bac8c0,32,WasmStackOverflow
code-creation,Builtin,2,20985,0x107bac900,40,WasmTraceMemory
code-creation,Builtin,2,20994,0x107bac940,32,WasmTraceEnter
code-creation,Builtin,2,21003,0x107bac980,40,WasmTraceExit
code-creation,Builtin,2,21012,0x107bac9c0,332,WasmAllocateJSArray
code-creation,Builtin,2,21021,0x107bacb20,104,WasmAllocatePair
code-creation,Builtin,2,21030,0x107bacba0,64,WasmAllocateRtt
code-creation,Builtin,2,21038,0x107bacc00,72,WasmAllocateFreshRtt
code-creation,Builtin,2,21048,0x107bacc60,124,WasmAllocateStructWithRtt
code-creation,Builtin,2,21057,0x107bacce0,140,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,21067,0x107bacd80,176,WasmAllocateArray_InitZero
code-creation,Builtin,2,21077,0x107bace40,176,WasmAllocateArray_InitNull
code-creation,Builtin,2,21087,0x107bacf00,116,WasmArrayCopyWithChecks
code-creation,Builtin,2,21096,0x107bacf80,60,WasmArrayCopy
code-creation,Builtin,2,21105,0x107bacfc0,240,WasmAllocateObjectWrapper
code-creation,Builtin,2,21115,0x107bad0c0,52,WasmSubtypeCheck
code-creation,Builtin,2,21124,0x107bad100,8,WasmInt32ToNumber
code-creation,Builtin,2,21133,0x107bad120,116,WasmUint32ToNumber
code-creation,Builtin,2,21142,0x107bad1a0,144,UintPtr53ToNumber
code-creation,Builtin,2,21151,0x107bad240,96,WasmAtomicNotify
code-creation,Builtin,2,21160,0x107bad2c0,116,WasmI32AtomicWait64
code-creation,Builtin,2,21169,0x107bad340,116,WasmI64AtomicWait64
code-creation,Builtin,2,21178,0x107bad3c0,580,WasmGetOwnProperty
code-creation,Builtin,2,21187,0x107bad620,40,WasmTrap
code-creation,Builtin,2,21196,0x107bad660,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,21205,0x107bad680,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,21215,0x107bad6a0,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,21225,0x107bad6c0,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,21235,0x107bad6e0,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,21245,0x107bad700,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,21254,0x107bad720,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,21264,0x107bad740,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,21274,0x107bad760,16,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,21284,0x107bad780,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,21295,0x107bad7a0,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,21305,0x107bad7c0,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,21314,0x107bad7e0,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,21324,0x107bad800,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,21334,0x107bad820,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,21350,0x107bad840,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,21360,0x107bad860,172,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,21383,0x107bad920,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,21394,0x107bad940,116,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,21405,0x107bad9c0,112,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,21416,0x107bada40,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,21427,0x107bada60,220,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,21437,0x107badb40,248,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,21448,0x107badc40,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,21459,0x107badc60,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,21469,0x107badc80,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,21480,0x107badca0,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,21491,0x107badcc0,132,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,21501,0x107badd60,8,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,21511,0x107badd80,32,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,21522,0x107baddc0,32,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,21533,0x107bade00,32,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,21544,0x107bade40,2668,Load_GenericElementsAccessor_0
code-creation,Builtin,2,21554,0x107bae8c0,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,21564,0x107bae8e0,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,21574,0x107bae920,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,21584,0x107bae940,164,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,21595,0x107baea00,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,21606,0x107baeac0,116,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,21616,0x107baeb40,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,21627,0x107baeb80,156,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,21638,0x107baec20,112,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,21649,0x107baeca0,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,21692,0x107baecc0,152,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,21708,0x107baed60,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,21723,0x107baed80,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,21738,0x107baeda0,620,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,21753,0x107baf020,220,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,21766,0x107baf100,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,21781,0x107baf140,200,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,21795,0x107baf220,248,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,21809,0x107baf320,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,21824,0x107baf360,200,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,21837,0x107baf440,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,21851,0x107baf460,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,21865,0x107baf480,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,21880,0x107baf540,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,21893,0x107baf560,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,21906,0x107baf580,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,21917,0x107baf640,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,21928,0x107baf660,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,21939,0x107baf680,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,21950,0x107baf740,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,21962,0x107baf760,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,21974,0x107baf780,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,21984,0x107baf840,132,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,22010,0x107baf8e0,164,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,22022,0x107baf9a0,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,22033,0x107bafa60,12,CollatorConstructor
code-creation,Builtin,2,22045,0x107bafa80,12,CollatorInternalCompare
code-creation,Builtin,2,22058,0x107bafaa0,12,CollatorPrototypeCompare
code-creation,Builtin,2,22071,0x107bafac0,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,22084,0x107bafae0,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,22097,0x107bafb00,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,22109,0x107bafb20,12,DatePrototypeToLocaleString
code-creation,Builtin,2,22122,0x107bafb40,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,22135,0x107bafb60,12,DateTimeFormatConstructor
code-creation,Builtin,2,22145,0x107bafb80,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,22155,0x107bafba0,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,22165,0x107bafbc0,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,22177,0x107bafbe0,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,22189,0x107bafc00,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,22200,0x107bafc20,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,22213,0x107bafc40,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,22226,0x107bafc60,12,DisplayNamesConstructor
code-creation,Builtin,2,22238,0x107bafc80,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,22251,0x107bafca0,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,22264,0x107bafcc0,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,22277,0x107bafce0,12,IntlGetCanonicalLocales
code-creation,Builtin,2,22290,0x107bafd00,12,ListFormatConstructor
code-creation,Builtin,2,22303,0x107bafd20,224,ListFormatPrototypeFormat
code-creation,Builtin,2,22315,0x107bafe20,224,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,22329,0x107baff20,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,22342,0x107baff40,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,22355,0x107baff60,12,LocaleConstructor
code-creation,Builtin,2,22367,0x107baff80,12,LocalePrototypeBaseName
code-creation,Builtin,2,22379,0x107baffa0,12,LocalePrototypeCalendar
code-creation,Builtin,2,22392,0x107baffc0,12,LocalePrototypeCalendars
code-creation,Builtin,2,22405,0x107baffe0,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,22418,0x107bb0000,12,LocalePrototypeCollation
code-creation,Builtin,2,22430,0x107bb0020,12,LocalePrototypeCollations
code-creation,Builtin,2,22443,0x107bb0040,12,LocalePrototypeHourCycle
code-creation,Builtin,2,22456,0x107bb0060,12,LocalePrototypeHourCycles
code-creation,Builtin,2,22469,0x107bb0080,12,LocalePrototypeLanguage
code-creation,Builtin,2,22481,0x107bb00a0,12,LocalePrototypeMaximize
code-creation,Builtin,2,22494,0x107bb00c0,12,LocalePrototypeMinimize
code-creation,Builtin,2,22507,0x107bb00e0,12,LocalePrototypeNumeric
code-creation,Builtin,2,22519,0x107bb0100,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,22532,0x107bb0120,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,22546,0x107bb0140,12,LocalePrototypeRegion
code-creation,Builtin,2,22558,0x107bb0160,12,LocalePrototypeScript
code-creation,Builtin,2,22571,0x107bb0180,12,LocalePrototypeTextInfo
code-creation,Builtin,2,22583,0x107bb01a0,12,LocalePrototypeTimeZones
code-creation,Builtin,2,22596,0x107bb01c0,12,LocalePrototypeToString
code-creation,Builtin,2,22609,0x107bb01e0,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,22621,0x107bb0200,12,NumberFormatConstructor
code-creation,Builtin,2,22634,0x107bb0220,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,22647,0x107bb0240,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,22660,0x107bb0260,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,22674,0x107bb0280,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,22687,0x107bb02a0,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,22712,0x107bb02c0,12,PluralRulesConstructor
code-creation,Builtin,2,22725,0x107bb02e0,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,22739,0x107bb0300,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,22752,0x107bb0320,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,22765,0x107bb0340,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,22778,0x107bb0360,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,22791,0x107bb0380,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,22806,0x107bb03a0,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,22820,0x107bb03c0,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,22833,0x107bb03e0,12,SegmenterConstructor
code-creation,Builtin,2,22846,0x107bb0400,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,22859,0x107bb0420,12,SegmenterPrototypeSegment
code-creation,Builtin,2,22872,0x107bb0440,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,22885,0x107bb0460,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,22898,0x107bb0480,12,SegmentsPrototypeContaining
code-creation,Builtin,2,22911,0x107bb04a0,12,SegmentsPrototypeIterator
code-creation,Builtin,2,22935,0x107bb04c0,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,22950,0x107bb04e0,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,22968,0x107bb0500,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,22981,0x107bb0520,200,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,22994,0x107bb0600,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,23007,0x107bb0620,632,StringToLowerCaseIntl
code-creation,Builtin,2,23019,0x107bb08a0,12,V8BreakIteratorConstructor
code-creation,Builtin,2,23032,0x107bb08c0,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,23045,0x107bb08e0,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,23059,0x107bb0900,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,23072,0x107bb0920,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,23085,0x107bb0940,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,23097,0x107bb0960,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,23111,0x107bb0980,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,23124,0x107bb09a0,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,23138,0x107bb09c0,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,23150,0x107bb09e0,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,23163,0x107bb0a00,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,23177,0x107bb0a20,12,V8BreakIteratorSupportedLocalesOf
tick,0x7ff803d55328,23201,0,0x0,6
tick,0x7ff803e80c81,23233,0,0x0,6
code-creation,BytecodeHandler,0,23246,0x107bb0a40,24,Wide
code-creation,BytecodeHandler,0,23260,0x107bb0a60,24,ExtraWide
code-creation,BytecodeHandler,0,23269,0x107bb0a80,104,DebugBreakWide
code-creation,BytecodeHandler,0,23279,0x107bb0b00,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,23289,0x107bb0b80,164,DebugBreak0
code-creation,BytecodeHandler,0,23299,0x107bb0c40,104,DebugBreak1
code-creation,BytecodeHandler,0,23308,0x107bb0cc0,104,DebugBreak2
code-creation,BytecodeHandler,0,23318,0x107bb0d40,104,DebugBreak3
code-creation,BytecodeHandler,0,23327,0x107bb0dc0,104,DebugBreak4
code-creation,BytecodeHandler,0,23337,0x107bb0e40,104,DebugBreak5
code-creation,BytecodeHandler,0,23346,0x107bb0ec0,104,DebugBreak6
code-creation,BytecodeHandler,0,23356,0x107bb0f40,32,Ldar
code-creation,BytecodeHandler,0,23365,0x107bb0f80,68,LdaZero
code-creation,BytecodeHandler,0,23374,0x107bb0fe0,76,LdaSmi
code-creation,BytecodeHandler,0,23383,0x107bb1040,68,LdaUndefined
code-creation,BytecodeHandler,0,23392,0x107bb10a0,68,LdaNull
code-creation,BytecodeHandler,0,23401,0x107bb1100,68,LdaTheHole
code-creation,BytecodeHandler,0,23411,0x107bb1160,20,LdaTrue
code-creation,BytecodeHandler,0,23420,0x107bb1180,20,LdaFalse
code-creation,BytecodeHandler,0,23429,0x107bb11a0,76,LdaConstant
code-creation,BytecodeHandler,0,23438,0x107bb1200,132,LdaContextSlot
code-creation,BytecodeHandler,0,23449,0x107bb12a0,132,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,23472,0x107bb1340,88,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,23483,0x107bb13a0,88,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,23494,0x107bb1400,32,Star
code-creation,BytecodeHandler,0,23503,0x107bb1440,40,Mov
code-creation,BytecodeHandler,0,23512,0x107bb1480,40,PushContext
code-creation,BytecodeHandler,0,23521,0x107bb14c0,36,PopContext
code-creation,BytecodeHandler,0,23530,0x107bb1500,48,TestReferenceEqual
code-creation,BytecodeHandler,0,23540,0x107bb1540,52,TestUndetectable
code-creation,BytecodeHandler,0,23550,0x107bb1580,36,TestNull
code-creation,BytecodeHandler,0,23559,0x107bb15c0,36,TestUndefined
code-creation,BytecodeHandler,0,23569,0x107bb1600,336,TestTypeOf
code-creation,BytecodeHandler,0,23578,0x107bb1760,6036,LdaGlobal
code-creation,BytecodeHandler,0,23587,0x107bb2f00,4536,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,23597,0x107bb40c0,168,StaGlobal
code-creation,BytecodeHandler,0,23606,0x107bb4180,156,StaContextSlot
code-creation,BytecodeHandler,0,23616,0x107bb4220,112,StaCurrentContextSlot
code-creation,BytecodeHandler,0,23626,0x107bb42a0,124,LdaLookupSlot
code-creation,BytecodeHandler,0,23636,0x107bb4320,240,LdaLookupContextSlot
code-creation,BytecodeHandler,0,23646,0x107bb4420,4776,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,23656,0x107bb56e0,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,23667,0x107bb5760,240,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,23678,0x107bb5860,4740,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,23689,0x107bb6b00,220,StaLookupSlot
code-creation,BytecodeHandler,0,23699,0x107bb6be0,5204,LdaNamedProperty
code-creation,BytecodeHandler,0,23708,0x107bb8040,180,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,23719,0x107bb8100,212,LdaKeyedProperty
code-creation,BytecodeHandler,0,23729,0x107bb81e0,160,LdaModuleVariable
code-creation,BytecodeHandler,0,23738,0x107bb82a0,292,StaModuleVariable
code-creation,BytecodeHandler,0,23748,0x107bb83e0,172,StaNamedProperty
code-creation,BytecodeHandler,0,23758,0x107bb84a0,172,StaNamedOwnProperty
code-creation,BytecodeHandler,0,23768,0x107bb8560,164,StaKeyedProperty
code-creation,BytecodeHandler,0,23778,0x107bb8620,164,StaInArrayLiteral
code-creation,BytecodeHandler,0,23788,0x107bb86e0,196,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,23798,0x107bb87c0,160,CollectTypeProfile
code-creation,BytecodeHandler,0,23808,0x107bb8880,1028,Add
code-creation,BytecodeHandler,0,23817,0x107bb8ca0,1064,Sub
code-creation,BytecodeHandler,0,23826,0x107bb90e0,1024,Mul
code-creation,BytecodeHandler,0,23834,0x107bb9500,988,Div
code-creation,BytecodeHandler,0,23843,0x107bb98e0,912,Mod
code-creation,BytecodeHandler,0,23852,0x107bb9c80,960,Exp
code-creation,BytecodeHandler,0,23861,0x107bba060,876,BitwiseOr
code-creation,BytecodeHandler,0,23870,0x107bba3e0,888,BitwiseXor
code-creation,BytecodeHandler,0,23879,0x107bba760,888,BitwiseAnd
code-creation,BytecodeHandler,0,23888,0x107bbaae0,900,ShiftLeft
code-creation,BytecodeHandler,0,23898,0x107bbae80,900,ShiftRight
code-creation,BytecodeHandler,0,23907,0x107bbb220,1020,ShiftRightLogical
code-creation,BytecodeHandler,0,23917,0x107bbb620,960,AddSmi
code-creation,BytecodeHandler,0,23925,0x107bbba00,1000,SubSmi
code-creation,BytecodeHandler,0,23934,0x107bbbe00,916,MulSmi
code-creation,BytecodeHandler,0,23944,0x107bbc1a0,920,DivSmi
code-creation,BytecodeHandler,0,23952,0x107bbc540,816,ModSmi
code-creation,BytecodeHandler,0,23961,0x107bbc880,868,ExpSmi
code-creation,BytecodeHandler,0,23970,0x107bbcc00,488,BitwiseOrSmi
code-creation,BytecodeHandler,0,23980,0x107bbce00,488,BitwiseXorSmi
code-creation,BytecodeHandler,0,23989,0x107bbd000,488,BitwiseAndSmi
code-creation,BytecodeHandler,0,23998,0x107bbd200,488,ShiftLeftSmi
code-creation,BytecodeHandler,0,24008,0x107bbd400,488,ShiftRightSmi
code-creation,BytecodeHandler,0,24017,0x107bbd600,640,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,24027,0x107bbd8a0,656,Inc
code-creation,BytecodeHandler,0,24047,0x107bbdb40,656,Dec
code-creation,BytecodeHandler,0,24056,0x107bbdde0,640,Negate
code-creation,BytecodeHandler,0,24065,0x107bbe080,480,BitwiseNot
code-creation,BytecodeHandler,0,24075,0x107bbe280,108,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,24085,0x107bbe300,36,LogicalNot
code-creation,BytecodeHandler,0,24094,0x107bbe340,208,TypeOf
code-creation,BytecodeHandler,0,24103,0x107bbe420,120,DeletePropertyStrict
code-creation,BytecodeHandler,0,24113,0x107bbe4a0,112,DeletePropertySloppy
code-creation,BytecodeHandler,0,24123,0x107bbe520,40,GetSuperConstructor
code-creation,BytecodeHandler,0,24136,0x107bbe560,1120,CallAnyReceiver
code-creation,BytecodeHandler,0,24146,0x107bbe9e0,1120,CallProperty
code-creation,BytecodeHandler,0,24155,0x107bbee60,1008,CallProperty0
code-creation,BytecodeHandler,0,24164,0x107bbf260,1024,CallProperty1
code-creation,BytecodeHandler,0,24174,0x107bbf680,1036,CallProperty2
code-creation,BytecodeHandler,0,24205,0x107bbfaa0,1000,CallUndefinedReceiver
code-creation,BytecodeHandler,0,24218,0x107bbfea0,1040,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,24231,0x107bc02c0,1016,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,24245,0x107bc06c0,1032,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,24259,0x107bc0ae0,1120,CallWithSpread
code-creation,BytecodeHandler,0,24271,0x107bc0f60,124,CallRuntime
code-creation,BytecodeHandler,0,24284,0x107bc0fe0,156,CallRuntimeForPair
code-creation,BytecodeHandler,0,24296,0x107bc1080,80,CallJSRuntime
code-creation,BytecodeHandler,0,24309,0x107bc10e0,1236,InvokeIntrinsic
code-creation,BytecodeHandler,0,24321,0x107bc15c0,1016,Construct
code-creation,BytecodeHandler,0,24334,0x107bc19c0,536,ConstructWithSpread
code-creation,BytecodeHandler,0,24347,0x107bc1be0,1936,TestEqual
code-creation,BytecodeHandler,0,24362,0x107bc2380,1064,TestEqualStrict
code-creation,BytecodeHandler,0,24374,0x107bc27c0,1624,TestLessThan
code-creation,BytecodeHandler,0,24387,0x107bc2e20,1624,TestGreaterThan
code-creation,BytecodeHandler,0,24399,0x107bc3480,1624,TestLessThanOrEqual
code-creation,BytecodeHandler,0,24412,0x107bc3ae0,1624,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,24426,0x107bc4140,856,TestInstanceOf
code-creation,BytecodeHandler,0,24438,0x107bc44a0,156,TestIn
code-creation,BytecodeHandler,0,24450,0x107bc4540,112,ToName
code-creation,BytecodeHandler,0,24462,0x107bc45c0,212,ToNumber
code-creation,BytecodeHandler,0,24475,0x107bc46a0,232,ToNumeric
code-creation,BytecodeHandler,0,24487,0x107bc47a0,112,ToObject
code-creation,BytecodeHandler,0,24499,0x107bc4820,116,ToString
code-creation,BytecodeHandler,0,24512,0x107bc48a0,400,CreateRegExpLiteral
code-creation,BytecodeHandler,0,24525,0x107bc4a40,1460,CreateArrayLiteral
code-creation,BytecodeHandler,0,24537,0x107bc5000,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,24551,0x107bc5060,792,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,24564,0x107bc5380,2160,CreateObjectLiteral
code-creation,BytecodeHandler,0,24577,0x107bc5c00,224,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,24591,0x107bc5d00,168,CloneObject
code-creation,BytecodeHandler,0,24604,0x107bc5dc0,212,GetTemplateObject
code-creation,BytecodeHandler,0,24617,0x107bc5ea0,328,CreateClosure
code-creation,BytecodeHandler,0,24629,0x107bc6000,120,CreateBlockContext
code-creation,BytecodeHandler,0,24642,0x107bc6080,132,CreateCatchContext
code-creation,BytecodeHandler,0,24655,0x107bc6120,256,CreateFunctionContext
code-creation,BytecodeHandler,0,24668,0x107bc6240,256,CreateEvalContext
code-creation,BytecodeHandler,0,24681,0x107bc6360,132,CreateWithContext
code-creation,BytecodeHandler,0,24694,0x107bc6400,1568,CreateMappedArguments
code-creation,BytecodeHandler,0,24708,0x107bc6a40,592,CreateUnmappedArguments
code-creation,BytecodeHandler,0,24721,0x107bc6ca0,632,CreateRestParameter
code-creation,BytecodeHandler,0,24734,0x107bc6f20,424,JumpLoop
code-creation,BytecodeHandler,0,24746,0x107bc70e0,44,Jump
code-creation,BytecodeHandler,0,24758,0x107bc7120,56,JumpConstant
code-creation,BytecodeHandler,0,24770,0x107bc7160,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,24795,0x107bc71c0,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,24809,0x107bc7220,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,24823,0x107bc7280,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,24837,0x107bc72e0,84,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,24851,0x107bc7340,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,24864,0x107bc73a0,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,24878,0x107bc7400,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,24891,0x107bc7460,152,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,24905,0x107bc7500,152,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,24919,0x107bc75a0,136,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,24932,0x107bc7640,136,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,24945,0x107bc76e0,64,JumpIfTrue
code-creation,BytecodeHandler,0,24958,0x107bc7740,64,JumpIfFalse
code-creation,BytecodeHandler,0,24970,0x107bc77a0,64,JumpIfNull
code-creation,BytecodeHandler,0,24982,0x107bc7800,64,JumpIfNotNull
code-creation,BytecodeHandler,0,24995,0x107bc7860,64,JumpIfUndefined
code-creation,BytecodeHandler,0,25008,0x107bc78c0,64,JumpIfNotUndefined
code-creation,BytecodeHandler,0,25021,0x107bc7920,72,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,25034,0x107bc7980,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,25047,0x107bc79e0,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,25060,0x107bc7a60,464,ForInEnumerate
code-creation,BytecodeHandler,0,25073,0x107bc7c40,252,ForInPrepare
code-creation,BytecodeHandler,0,25086,0x107bc7d40,60,ForInContinue
code-creation,BytecodeHandler,0,25098,0x107bc7d80,256,ForInNext
code-creation,BytecodeHandler,0,25111,0x107bc7ea0,48,ForInStep
code-creation,BytecodeHandler,0,25123,0x107bc7ee0,36,SetPendingMessage
code-creation,BytecodeHandler,0,25136,0x107bc7f20,116,Throw
code-creation,BytecodeHandler,0,25148,0x107bc7fa0,116,ReThrow
code-creation,BytecodeHandler,0,25160,0x107bc8020,112,Return
code-creation,BytecodeHandler,0,25172,0x107bc80a0,196,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,25186,0x107bc8180,132,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,25200,0x107bc8220,132,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,25215,0x107bc82c0,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,25228,0x107bc8360,120,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,25242,0x107bc83e0,500,SuspendGenerator
code-creation,BytecodeHandler,0,25254,0x107bc85e0,128,ResumeGenerator
code-creation,BytecodeHandler,0,25267,0x107bc8680,152,GetIterator
code-creation,BytecodeHandler,0,25279,0x107bc8720,116,Debugger
code-creation,BytecodeHandler,0,25292,0x107bc87a0,124,IncBlockCounter
code-creation,BytecodeHandler,0,25305,0x107bc8820,56,Abort
code-creation,BytecodeHandler,0,25317,0x107bc8860,32,Star0
code-creation,BytecodeHandler,0,25329,0x107bc88a0,60,Illegal
code-creation,BytecodeHandler,0,25342,0x107bc88e0,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,25355,0x107bc8960,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,25368,0x107bc89e0,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,25381,0x107bc8a60,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,25394,0x107bc8ae0,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,25407,0x107bc8b60,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,25420,0x107bc8be0,32,Ldar.Wide
code-creation,BytecodeHandler,0,25433,0x107bc8c20,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,25460,0x107bc8c60,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,25474,0x107bc8ca0,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,25487,0x107bc8d00,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,25502,0x107bc8d60,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,25517,0x107bc8da0,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,25531,0x107bc8de0,32,Star.Wide
code-creation,BytecodeHandler,0,25544,0x107bc8e20,40,Mov.Wide
code-creation,BytecodeHandler,0,25568,0x107bc8e60,40,PushContext.Wide
code-creation,BytecodeHandler,0,25582,0x107bc8ea0,36,PopContext.Wide
code-creation,BytecodeHandler,0,25595,0x107bc8ee0,48,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,25609,0x107bc8f20,4668,LdaGlobal.Wide
code-creation,BytecodeHandler,0,25622,0x107bca160,4604,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,25635,0x107bcb360,172,StaGlobal.Wide
code-creation,BytecodeHandler,0,25648,0x107bcb420,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,25662,0x107bcb4c0,112,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,25676,0x107bcb540,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,25690,0x107bcb5e0,244,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,25704,0x107bcb6e0,4852,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,25717,0x107bcc9e0,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,25732,0x107bcca80,244,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,25747,0x107bccb80,4812,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,25762,0x107bcde60,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,25776,0x107bcdf40,5208,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,25790,0x107bcf3a0,188,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,25804,0x107bcf460,160,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,25817,0x107bcf520,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,25830,0x107bcf5e0,296,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,25843,0x107bcf720,176,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,25857,0x107bcf7e0,176,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,25871,0x107bcf8a0,168,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,25884,0x107bcf960,168,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,25898,0x107bcfa20,200,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,25912,0x107bcfb00,164,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,25926,0x107bcfbc0,984,Add.Wide
tick,0x7ff803e80ea8,25949,0,0x0,6
tick,0x7ff803e80d7f,25978,0,0x0,6
code-creation,BytecodeHandler,0,25991,0x107bcffa0,1020,Sub.Wide
code-creation,BytecodeHandler,0,26005,0x107bd03a0,972,Mul.Wide
code-creation,BytecodeHandler,0,26015,0x107bd0780,988,Div.Wide
code-creation,BytecodeHandler,0,26024,0x107bd0b60,916,Mod.Wide
code-creation,BytecodeHandler,0,26034,0x107bd0f00,984,Exp.Wide
code-creation,BytecodeHandler,0,26043,0x107bd12e0,904,BitwiseOr.Wide
code-creation,BytecodeHandler,0,26052,0x107bd1680,920,BitwiseXor.Wide
code-creation,BytecodeHandler,0,26062,0x107bd1a20,920,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,26072,0x107bd1dc0,932,ShiftLeft.Wide
code-creation,BytecodeHandler,0,26081,0x107bd2180,932,ShiftRight.Wide
code-creation,BytecodeHandler,0,26091,0x107bd2540,1052,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,26101,0x107bd2960,916,AddSmi.Wide
code-creation,BytecodeHandler,0,26111,0x107bd2d00,960,SubSmi.Wide
code-creation,BytecodeHandler,0,26120,0x107bd30e0,912,MulSmi.Wide
code-creation,BytecodeHandler,0,26130,0x107bd3480,920,DivSmi.Wide
code-creation,BytecodeHandler,0,26139,0x107bd3820,816,ModSmi.Wide
code-creation,BytecodeHandler,0,26148,0x107bd3b60,868,ExpSmi.Wide
code-creation,BytecodeHandler,0,26158,0x107bd3ee0,496,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,26167,0x107bd40e0,496,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,26177,0x107bd42e0,496,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,26187,0x107bd44e0,496,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,26197,0x107bd46e0,496,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,26207,0x107bd48e0,648,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,26218,0x107bd4b80,616,Inc.Wide
code-creation,BytecodeHandler,0,26228,0x107bd4e00,616,Dec.Wide
code-creation,BytecodeHandler,0,26237,0x107bd5080,648,Negate.Wide
code-creation,BytecodeHandler,0,26246,0x107bd5320,492,BitwiseNot.Wide
code-creation,BytecodeHandler,0,26256,0x107bd5520,124,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,26266,0x107bd55a0,116,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,26295,0x107bd5620,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,26306,0x107bd5660,1124,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,26316,0x107bd5ae0,1124,CallProperty.Wide
code-creation,BytecodeHandler,0,26326,0x107bd5f60,1012,CallProperty0.Wide
code-creation,BytecodeHandler,0,26336,0x107bd6360,1024,CallProperty1.Wide
code-creation,BytecodeHandler,0,26346,0x107bd6780,1036,CallProperty2.Wide
code-creation,BytecodeHandler,0,26356,0x107bd6ba0,1004,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,26367,0x107bd6fa0,1044,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,26378,0x107bd73c0,1020,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,26389,0x107bd77c0,1036,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,26400,0x107bd7be0,1124,CallWithSpread.Wide
code-creation,BytecodeHandler,0,26409,0x107bd8060,128,CallRuntime.Wide
code-creation,BytecodeHandler,0,26419,0x107bd8100,168,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,26430,0x107bd81c0,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,26440,0x107bd8220,1240,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,26450,0x107bd8700,960,Construct.Wide
code-creation,BytecodeHandler,0,26459,0x107bd8ae0,472,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,26470,0x107bd8cc0,1964,TestEqual.Wide
code-creation,BytecodeHandler,0,26479,0x107bd9480,1068,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,26489,0x107bd98c0,1512,TestLessThan.Wide
code-creation,BytecodeHandler,0,26499,0x107bd9ec0,1512,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,26509,0x107bda4c0,1512,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,26520,0x107bdaac0,1512,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,26530,0x107bdb0c0,864,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,26540,0x107bdb440,160,TestIn.Wide
code-creation,BytecodeHandler,0,26550,0x107bdb500,116,ToName.Wide
code-creation,BytecodeHandler,0,26559,0x107bdb580,216,ToNumber.Wide
code-creation,BytecodeHandler,0,26568,0x107bdb660,236,ToNumeric.Wide
code-creation,BytecodeHandler,0,26578,0x107bdb760,116,ToObject.Wide
code-creation,BytecodeHandler,0,26588,0x107bdb7e0,404,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,26598,0x107bdb980,1372,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,26609,0x107bdbee0,792,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,26620,0x107bdc200,2060,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,26631,0x107bdca20,172,CloneObject.Wide
code-creation,BytecodeHandler,0,26640,0x107bdcae0,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,26650,0x107bdcba0,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,26660,0x107bdcd00,124,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,26671,0x107bdcd80,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,26682,0x107bdce20,256,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,26693,0x107bdcf40,256,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,26724,0x107bdd060,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,26735,0x107bdd100,440,JumpLoop.Wide
code-creation,BytecodeHandler,0,26744,0x107bdd2c0,44,Jump.Wide
code-creation,BytecodeHandler,0,26759,0x107bdd300,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,26771,0x107bdd340,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,26783,0x107bdd3a0,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,26794,0x107bdd400,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,26805,0x107bdd460,80,JumpIfNotUndefinedConstant.Wide
tick,0x7ff803e80c81,26824,0,0x0,6
code-creation,BytecodeHandler,0,26851,0x107bdd4c0,84,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,26865,0x107bdd520,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,26877,0x107bdd580,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,26887,0x107bdd5e0,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,26898,0x107bdd640,152,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,26923,0x107bdd6e0,152,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,26935,0x107bdd780,136,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,26946,0x107bdd820,136,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,26957,0x107bdd8c0,64,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,26966,0x107bdd920,64,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,26976,0x107bdd980,64,JumpIfNull.Wide
code-creation,BytecodeHandler,0,26986,0x107bdd9e0,64,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,26996,0x107bdda40,64,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,27006,0x107bddaa0,64,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,27016,0x107bddb00,72,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,27027,0x107bddb60,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,27037,0x107bddbc0,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,27048,0x107bddc40,468,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,27058,0x107bdde20,252,ForInPrepare.Wide
code-creation,BytecodeHandler,0,27068,0x107bddf20,60,ForInContinue.Wide
code-creation,BytecodeHandler,0,27078,0x107bddf60,260,ForInNext.Wide
code-creation,BytecodeHandler,0,27087,0x107bde080,48,ForInStep.Wide
code-creation,BytecodeHandler,0,27097,0x107bde0c0,156,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,27108,0x107bde160,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,27119,0x107bde220,120,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,27130,0x107bde2a0,516,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,27140,0x107bde4c0,128,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,27150,0x107bde560,156,GetIterator.Wide
code-creation,BytecodeHandler,0,27160,0x107bde600,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,27170,0x107bde6a0,56,Abort.Wide
code-creation,BytecodeHandler,0,27179,0x107bde6e0,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,27190,0x107bde760,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,27200,0x107bde7e0,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,27210,0x107bde860,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,27220,0x107bde8e0,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,27230,0x107bde960,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,27240,0x107bde9e0,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,27250,0x107bdea20,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,27259,0x107bdea40,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,27270,0x107bdea80,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27281,0x107bdeae0,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27292,0x107bdeb40,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27304,0x107bdeb80,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27315,0x107bdebc0,28,Star.ExtraWide
code-creation,BytecodeHandler,0,27325,0x107bdebe0,40,Mov.ExtraWide
code-creation,BytecodeHandler,0,27335,0x107bdec20,36,PushContext.ExtraWide
code-creation,BytecodeHandler,0,27345,0x107bdec60,32,PopContext.ExtraWide
code-creation,BytecodeHandler,0,27355,0x107bdeca0,48,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,27366,0x107bdece0,4656,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,27376,0x107bdff20,4592,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,27387,0x107be1120,168,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,27397,0x107be11e0,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27408,0x107be1280,108,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27419,0x107be1300,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,27429,0x107be13a0,240,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,27440,0x107be14a0,4836,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,27452,0x107be27a0,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,27463,0x107be2840,240,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,27487,0x107be2940,4800,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,27500,0x107be3c20,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,27511,0x107be3d00,5188,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,27521,0x107be5160,184,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,27533,0x107be5220,156,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,27544,0x107be52c0,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,27555,0x107be5380,292,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,27566,0x107be54c0,172,StaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,27576,0x107be5580,172,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,27587,0x107be5640,168,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,27598,0x107be5700,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,27609,0x107be57c0,196,StaDataPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,27621,0x107be58a0,164,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,27632,0x107be5960,980,Add.ExtraWide
code-creation,BytecodeHandler,0,27641,0x107be5d40,1016,Sub.ExtraWide
code-creation,BytecodeHandler,0,27651,0x107be6140,972,Mul.ExtraWide
code-creation,BytecodeHandler,0,27660,0x107be6520,988,Div.ExtraWide
code-creation,BytecodeHandler,0,27670,0x107be6900,916,Mod.ExtraWide
code-creation,BytecodeHandler,0,27679,0x107be6ca0,980,Exp.ExtraWide
code-creation,BytecodeHandler,0,27689,0x107be7080,904,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,27698,0x107be7420,916,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,27708,0x107be77c0,916,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,27718,0x107be7b60,928,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,27728,0x107be7f20,928,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,27738,0x107be82e0,1048,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,27749,0x107be8700,916,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,27759,0x107be8aa0,960,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,27768,0x107be8e80,912,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,27778,0x107be9220,916,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,27788,0x107be95c0,816,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,27797,0x107be9900,868,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,27807,0x107be9c80,492,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,27818,0x107be9e80,492,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,27829,0x107bea080,492,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,27839,0x107bea280,492,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,27849,0x107bea480,492,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,27860,0x107bea680,644,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,27870,0x107bea920,616,Inc.ExtraWide
code-creation,BytecodeHandler,0,27880,0x107beaba0,616,Dec.ExtraWide
code-creation,BytecodeHandler,0,27890,0x107beae20,644,Negate.ExtraWide
code-creation,BytecodeHandler,0,27899,0x107beb0c0,488,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,27910,0x107beb2c0,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,27921,0x107beb340,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,27932,0x107beb3c0,36,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,27943,0x107beb400,1120,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,27953,0x107beb880,1120,CallProperty.ExtraWide
tick,0x7ff803d55379,27984,0,0x0,6
code-creation,BytecodeHandler,0,28014,0x107bebd00,1004,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,28045,0x107bec100,1020,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,28059,0x107bec500,1032,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,28070,0x107bec920,1000,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,28082,0x107becd20,1044,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,28094,0x107bed140,1016,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,28123,0x107bed540,1028,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,28135,0x107bed960,1120,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,28146,0x107bedde0,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,28157,0x107bede80,164,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,28168,0x107bedf40,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,28179,0x107bedfa0,1240,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,28190,0x107bee480,956,Construct.ExtraWide
code-creation,BytecodeHandler,0,28200,0x107bee840,468,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,28211,0x107beea20,1964,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,28221,0x107bef1e0,1068,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,28232,0x107bef620,1508,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,28242,0x107befc20,1508,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,28253,0x107bf0220,1508,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,28264,0x107bf0820,1508,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,28276,0x107bf0e20,860,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,28286,0x107bf1180,156,TestIn.ExtraWide
code-creation,BytecodeHandler,0,28296,0x107bf1220,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,28306,0x107bf12a0,216,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,28316,0x107bf1380,236,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,28326,0x107bf1480,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,28336,0x107bf1500,400,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,28347,0x107bf16a0,1368,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,28359,0x107bf1c00,792,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,28370,0x107bf1f20,2060,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,28381,0x107bf2740,168,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,28392,0x107bf2800,160,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,28403,0x107bf28c0,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,28414,0x107bf2a20,124,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,28425,0x107bf2aa0,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,28436,0x107bf2b40,256,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,28447,0x107bf2c60,256,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,28458,0x107bf2d80,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,28468,0x107bf2e20,436,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,28478,0x107bf2fe0,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,28488,0x107bf3020,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,28499,0x107bf3060,76,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,28509,0x107bf30c0,76,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,28521,0x107bf3120,76,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,28533,0x107bf3180,76,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,28545,0x107bf31e0,84,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,28556,0x107bf3240,76,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,28567,0x107bf32a0,76,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,28579,0x107bf3300,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,28590,0x107bf3360,148,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,28602,0x107bf3400,148,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,28614,0x107bf34a0,136,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,28625,0x107bf3540,136,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,28636,0x107bf35e0,64,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,28646,0x107bf3640,64,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,28656,0x107bf36a0,64,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,28667,0x107bf3700,64,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,28688,0x107bf3760,64,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,28700,0x107bf37c0,64,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,28711,0x107bf3820,68,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,28722,0x107bf3880,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,28733,0x107bf38e0,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,28744,0x107bf3960,464,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,28755,0x107bf3b40,252,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,28766,0x107bf3c40,56,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,28776,0x107bf3c80,256,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,28786,0x107bf3da0,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,28797,0x107bf3de0,156,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,28809,0x107bf3e80,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,28820,0x107bf3f40,120,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,28832,0x107bf3fc0,512,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,28843,0x107bf41e0,124,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,28853,0x107bf4260,152,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,28864,0x107bf4300,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,28874,0x107bf4380,56,Abort.ExtraWide
new,MemoryChunk,0x315753800000,262144
new,MemoryChunk,0x3157e4600000,262144
tick,0x108124051,30539,0,0x0,5
tick,0x1077b4aaa,31773,0,0x0,5
new,MemoryChunk,0x31574a2c0000,262144
new,MemoryChunk,0x3157b57c0000,262144
tick,0x1077b42f6,32849,0,0x0,5
tick,0x107271000,34130,0,0x0,5
code-creation,Eval,10,34902,0x3157b57fbd56,5, node:internal/main/run_main_module:1:1,0x3157b57fbc10,~
script-source,91,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0x3157b57fbd56,91,0,632,C0O0C4O632,,
code-creation,Function,10,35012,0x3157b57fbdfe,58, node:internal/main/run_main_module:1:1,0x3157b57fbcd0,~
code-source-info,0x3157b57fbdfe,91,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
tick,0x1076c8290,35430,0,0x0,2,0x1077801f0,0x3157b57fbe01
code-creation,LazyCompile,10,35492,0x3157b57fc03e,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x31575b54f8f8,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n  */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
code-source-info,0x3157b57fc03e,9,10315,10658,C0O10324C2O10335C4O10331C9O10351C13O10372C14O10392C19O10405C24O10409C29O10409C35O10550C37O10560C47O10608C60O10566C65O10560C66O10629C71O10629C75O10656,,
code-creation,LazyCompile,10,36689,0x3157b57fcd4e,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x31575b54f828,~
code-source-info,0x3157b57fcd4e,9,9528,10089,C0O9546C6O9561C12O9590C16O9598C17O9626C22O9634C23O9647C30O9690C37O9721C45O9690C63O9820C70O9820C75O9855C89O9890C103O9847C108O9928C109O9940C124O9970C126O9983C141O10003C152O10022C160O10054C165O10003C170O10077C174O10085,,
tick,0x1074f233a,36790,0,0x0,3,0x1077801f0,0x3157b57fc085,0x3157b57fbe01
code-creation,Eval,10,37211,0x3157b57fdc96,5, node:internal/bootstrap/pre_execution:1:1,0x3157b57fd900,~
script-source,92,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  getEmbedderOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\n\nconst { Buffer } = require('buffer');\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false) {\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n  initializeCJSLoader();\n  initializeESMLoader();\n\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  // TODO(joyeecheung): snapshot fast APIs (which need to work with\n  // array buffers\x2C whose connection with C++ needs to be rebuilt after\n  // deserialization).\n  const {\n    hrtime\x2C\n    hrtimeBigInt\n  } = require('internal/process/per_thread').getFastAPIs(binding);\n\n  process.hrtime = hrtime;\n  process.hrtime.bigint = hrtimeBigInt;\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    enumerable: true\x2C\n    configurable: false\x2C\n    value: process.argv[0]\n  });\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {}\n  }\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n\n  // Create global.process and global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0x3157b57fdc96,92,0,15986,C0O0C4O15986,,
code-creation,Function,10,38748,0x3157b57fe796,426, node:internal/bootstrap/pre_execution:1:1,0x3157b57fdc10,~
code-source-info,0x3157b57fe796,92,0,15986,C0O0C190O25C196O43C202O67C208O78C214O93C220O122C226O204C232O204C237O162C243O180C249O269C255O269C260O241C266O317C272O317C277O306C283O378C289O378C294O404C299O344C305O427C311O427C315O427C317O15589C324O15610C330O15632C336O15654C342O15677C348O15694C354O15712C360O15742C366O15768C372O15791C378O15821C384O15853C390O15875C396O15902C402O15925C408O15945C414O15968C420O15604C425O15985,,
tick,0x10728b214,38855,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x3157b57fbe01
tick,0x1072a7e90,39051,1,0x10712a580,2,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x3157b57fe87e,0x3157b57fcdb5,0x3157b57fc085,0x3157b57fbe01
new,MemoryChunk,0x31576e500000,262144
code-creation,Eval,10,39147,0x31576e5012b6,5, node:internal/options:1:1,0x3157b57fff48,~
script-source,93,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\n};\n
code-source-info,0x31576e5012b6,93,0,1820,C0O0C4O1820,,
code-creation,Function,10,39340,0x31576e501686,154, node:internal/options:1:1,0x31576e501230,~
code-source-info,0x31576e501686,93,0,1820,C0O0C54O97C57O97C62O25C68O62C74O156C75O156C77O167C78O167C80O183C81O183C83O199C84O199C86O1614C93O1756C99O1774C105O1798C148O1629C153O1819,,
code-creation,LazyCompile,10,39461,0x31576e501b96,69,internalBinding node:internal/bootstrap/loaders:164:45,0x31575b54f378,~
code-source-info,0x31576e501b96,9,5115,5353,C0O5140C7O5150C11O5164C15O5201C25O5228C30O5226C37O5262C48O5281C56O5317C61O5262C66O5338C68O5349,,
code-creation,LazyCompile,10,39789,0x31576e5023c6,213,prepareMainThreadExecution node:internal/bootstrap/pre_execution:22:36,0x3157b57fdcc8,~
code-source-info,0x31576e5023c6,92,491,2380,C10O634C15O634C18O736C21O736C25O771C28O771C31O800C34O800C37O820C40O820C43O845C46O845C49O1048C52O1060C57O1064C63O1088C66O1096C77O1152C82O1156C87O1125C91O1117C95O1183C98O1183C101O1275C104O1275C107O1381C110O1381C113O1403C116O1403C119O1462C122O1462C125O1785C128O1785C131O1860C134O1860C137O2057C140O2057C143O2084C146O2084C149O2118C152O2118C155O2146C158O2146C161O2166C164O2166C167O2191C170O2191C173O2235C179O2235C184O2277C189O2295C195O2277C199O2325C202O2325C205O2349C208O2349C212O2379,,
code-creation,LazyCompile,10,39921,0x31576e5035ee,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x315735271cd0,~
script-source,19,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0x31576e5035ee,19,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x7ff803e80ea8,42925,0,0x0,3,0x1077801f0,0x31576e5023d5,0x3157b57fbe0d
tick,0x7ff803df1f01,42955,0,0x0,3,0x1077801f0,0x31576e5023d5,0x3157b57fbe0d
tick,0x7ff803e4b9ce,42966,0,0x0,3,0x1077801f0,0x31576e5023d5,0x3157b57fbe0d
code-creation,LazyCompile,10,43081,0x31576e505e3e,432,patchProcessObject node:internal/bootstrap/pre_execution:81:28,0x3157b57fdd18,~
code-source-info,0x31576e505e3e,92,2409,4251,C0O2443C6O2443C11O2489C19O2489C24O2727C30O2727C35O2765C40O2766C46O2696C51O2708C56O2791C61O2806C65O2818C68O2826C75O2840C79O2859C90O2880C98O2966C104O2970C111O2859C116O2982C119O2990C129O3008C133O2998C137O3021C144O3048C151O3052C158O3066C164O3100C171O3104C178O3066C185O3182C191O3182C199O3215C202O3223C210O3238C218O3254C225O3258C229O3238C234O3231C244O3426C253O3426C258O3472C267O3472C272O3525C281O3525C286O3585C295O3585C300O3643C309O3643C314O3703C323O3703C328O3767C337O3767C342O3832C351O3832C356O3903C365O3903C370O3973C379O3973C384O4033C393O4033C398O4103C409O4103C414O4173C425O4173C431O4250,,
code-creation,LazyCompile,10,43327,0x31576e5064f6,113,getFastAPIs node:internal/process/per_thread:57:21,0x31573527de80,~
script-source,23,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nfunction getFastAPIs(binding) {\n  const {\n    hrtime: _hrtime\n  } = binding.getFastAPIs();\n\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  const hrValues = new Uint32Array(_hrtime.buffer);\n\n  function hrtime(time) {\n    _hrtime.hrtime();\n\n    if (time !== undefined) {\n      validateArray(time\x2C 'time');\n      if (time.length !== 2) {\n        throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n      }\n\n      const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n      const nsec = hrValues[2] - time[1];\n      const needsBorrow = nsec < 0;\n      return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n    }\n\n    return [\n      hrValues[0] * 0x100000000 + hrValues[1]\x2C\n      hrValues[2]\x2C\n    ];\n  }\n\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  const hrBigintValues = new BigUint64Array(_hrtime.buffer\x2C 0\x2C 1);\n  function hrtimeBigInt() {\n    _hrtime.hrtimeBigInt();\n    return hrBigintValues[0];\n  }\n\n  return {\n    hrtime\x2C\n    hrtimeBigInt\x2C\n  };\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  NodeEnvironmentFlagsSet.prototype.keys =\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\n    NodeEnvironmentFlagsSet.prototype.values;\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  getFastAPIs\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\n};\n
code-source-info,0x31576e5064f6,23,1229,2412,C0O1229C24O1285C29O1285C34O1263C40O1500C50O1524C57O1500C62O1500C64O2232C74O2259C86O2232C91O2232C93O2367C100O2380C106O2392C112O2410,,
tick,0x7ff803e9822a,44511,0,0x0,3,0x1077801f0,0x31576e505e66,0x31576e5023db,0x3157b57fbe0d
code-creation,LazyCompile,10,44742,0x31576e507bc6,175,resolve node:path:1091:10,0x315715868488,~
script-source,35,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instancee\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0x31576e507bc6,35,33782,34692,C0O33782C3O33817C6O33848C8O33878C12O33885C16O33898C18O33892C25O33902C27O33946C28O33948C35O33959C42O33965C45O33965C49O33984C57O33984C62O34058C68O34065C73O34082C75O34107C87O34133C92O34155C99O34182C107O34221C109O34217C113O33921C118O33860C121O34437C126O34483C137O34452C143O34569C147O34599C152O34610C156O34625C157O34656C163O34663C174O34688,,
tick,0x7ff803d61c6a,49223,0,0x0,3,0x1077801f0,0x31576e505f23,0x31576e5023db,0x3157b57fbe0d
tick,0x7ff803e80cc9,49246,0,0x0,3,0x1077801f0,0x31576e505f23,0x31576e5023db,0x3157b57fbe0d
tick,0x7ff803e80c86,49256,0,0x0,3,0x1077801f0,0x31576e505f23,0x31576e5023db,0x3157b57fbe0d
tick,0x7ff803d551be,49265,0,0x0,3,0x1077801f0,0x31576e505f23,0x31576e5023db,0x3157b57fbe0d
code-creation,LazyCompile,10,49294,0x31576e50adfe,30,validateString node:internal/validators:117:24,0x315735259ef8,~
script-source,17,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  RegExpPrototypeTest\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n    ERR_INVALID_CALLBACK\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (!isInt32(value)) {\n      if (typeof value !== 'number') {\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n      }\n      if (!NumberIsInteger(value)) {\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n      }\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (!isUint32(value)) {\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    const min = positive ? 1 : 0;\n    // 2 ** 32 === 4294967296\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\n  }\n  if (positive && value === 0) {\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\n/**\n * @param {unknown} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options) => {\n    const useDefaultOptions = options == null;\n    const allowArray = useDefaultOptions ? false : options.allowArray;\n    const allowFunction = useDefaultOptions ? false : options.allowFunction;\n    const nullable = useDefaultOptions ? false : options.nullable;\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateCallback = hideStackFrames((callback) => {\n  if (typeof callback !== 'function')\n    throw new ERR_INVALID_CALLBACK(callback);\n});\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateCallback\x2C\n  validateAbortSignal\x2C\n};\n
code-source-info,0x31576e50adfe,17,3398,3507,C0O3416C6O3451C22O3457C27O3451C29O3506,,
code-creation,LazyCompile,10,50107,0x31576e50b75e,13, node:path:1082:10,0x315715868438,~
code-source-info,0x31576e50b75e,35,33631,33650,C0O33645C3O33645C8O33645C12O33650,,
tick,0x10768f6c6,50166,0,0x0,3,0x1077801f0,0x31576e507bf3,0x31576e505f23,0x31576e5023db,0x3157b57fbe0d
code-creation,LazyCompile,10,50212,0x31576e50b85e,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x31577c04d3e8,~
script-source,90,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id |= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0x31576e50b85e,90,3341,3425,C0O3348C7O3362C12O3374C17O3397C22O3397C29O3384C35O3406C39O3423,,
code-creation,LazyCompile,10,50764,0x31576e50bec6,442,normalizeString node:path:66:25,0x315715867fa0,~
code-source-info,0x31576e50bec6,35,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,50898,0x31576e50c246,8,isPosixPathSeparator node:path:56:30,0x315715867f00,~
code-source-info,0x31576e50c246,35,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,51027,0x31576e50c6be,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:129:33,0x3157b57fdd68,~
code-source-info,0x31576e50c6be,92,4285,4510,C16O4337C21O4337C26O4363C28O4380C36O4410C43O4473C49O4491C56O4380C62O4509,,
code-creation,LazyCompile,10,51101,0x31576e50c83e,82,getOptionValue node:internal/options:39:24,0x31576e5013d8,~
code-source-info,0x31576e50c83e,93,902,1145,C0O935C3O935C7O980C15O980C22O1030C30O1052C38O1052C43O1039C47O1030C53O1067C55O1092C60O1098C61O1120C66O1120C74O1135C81O1143,,
code-creation,LazyCompile,10,51161,0x31576e50cbee,33,getCLIOptionsFromBinding node:internal/options:18:34,0x31576e5012e8,~
code-source-info,0x31576e50cbee,93,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
tick,0x107675f80,51297,1,0x107135a90,5,0x10777feb0,0x31576e50cbf9,0x31576e50c841,0x31576e50c6d3,0x31576e505f3b,0x31576e5023db,0x3157b57fbe0d
code-creation,LazyCompile,10,51575,0x31576e50cfce,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:221:33,0x3157b57fe010,~
code-source-info,0x31576e50cfce,92,6753,6980,C0O6795C6O6795C11O6768C16O6867C22O6867C27O6838C32O6909C35O6934C40O6909C45O6979,,
code-creation,LazyCompile,10,51660,0x31576e50d166,77,toggleTraceCategoryState node:internal/process/per_thread:385:34,0x31573527e470,~
code-source-info,0x31576e50d166,23,11040,11337,C0O11064C4O11093C10O11128C16O11159C21O11203C26O11204C33O11149C39O11228C44O11249C49O11249C55O11268C61O11300C66O11321C71O11321C76O11336,,
code-creation,LazyCompile,10,51716,0x31576e50d316,42,setupPerfHooks node:internal/bootstrap/pre_execution:227:24,0x3157b57fe060,~
code-source-info,0x31576e50d316,92,7005,7125,C0O7012C6O7012C11O7048C16O7049C20O7072C26O7072C31O7102C36O7103C41O7124,,
code-creation,LazyCompile,10,51778,0x31576e50d496,42,refreshTimeOrigin node:internal/perf/performance:178:27,0x31572ee43b38,~
script-source,70,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (type !== undefined) {\n    type = `${type}`;\n  }\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  eventLoopUtilization: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  now: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x31576e50d496,70,3755,3912,C0O3762C7O3783C10O3795C25O3879C28O3879C35O3762C41O3911,,
code-creation,LazyCompile,10,52255,0x31576e50dba6,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x31571587b420,~
script-source,41,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0x31576e50dba6,41,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,52396,0x31576e50de16,62,setupInspectorHooks node:internal/bootstrap/pre_execution:232:29,0x3157b57fe0b0,~
code-source-info,0x31576e50de16,92,7155,7708,C0O7498C6O7502C11O7527C17O7592C23O7592C28O7562C33O7576C38O7638C44O7638C49O7666C54O7667C61O7707,,
tick,0x1073cb96e,52570,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e50de2d,0x31576e5023ee,0x3157b57fbe0d
code-creation,Eval,10,52603,0x31576e50e1c6,5, node:internal/inspector_async_hook:1:1,0x31576e50e010,~
script-source,94,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0x31576e50e1c6,94,0,1972,C0O0C4O1972,,
code-creation,Function,10,52821,0x31576e50e3e6,79, node:internal/inspector_async_hook:1:1,0x31576e50e140,~
code-source-info,0x31576e50e3e6,94,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
code-creation,LazyCompile,10,52952,0x31576e50e8de,69,setupWarningHandler node:internal/bootstrap/pre_execution:141:29,0x3157b57fddb8,~
code-source-info,0x31576e50e8de,92,4540,4737,C0O4575C6O4575C11O4559C16O4614C24O4618C33O4662C38O4666C45O4683C50O4698C53O4706C61O4706C68O4736,,
code-creation,LazyCompile,10,53081,0x31576e50ea3e,20,addListener node:events:486:58,0x31575b572d38,~
script-source,13,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  MathMin\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\nconst { inspect } = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @returns {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catcheable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n// Returns the length and line number of the first sequence of `a` that fully\n// appears in `b` with a length of at least 4.\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return [len\x2C i];\n        }\n      }\n    }\n  }\n\n  return [0\x2C 0];\n}\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {}\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {}\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          `added to ${inspect(target\x2C { depth: -1 })}. Use ` +\n                          'emitter.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = {}) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError());\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters\x2C we do not listen to `error` events here.\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError();\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError());\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0x31576e50ea3e,13,14192,14264,C0O14213C14O14220C19O14262,,
tick,0x7ff803e8087e,55977,0,0x0,3,0x1077801f0,0x31576e50e91b,0x31576e5023f4,0x3157b57fbe0d
tick,0x7ff803e80c81,56001,0,0x0,3,0x1077801f0,0x31576e50e91b,0x31576e5023f4,0x3157b57fbe0d
tick,0x7ff803ca54c2,56012,0,0x0,3,0x1077801f0,0x31576e50e91b,0x31576e5023f4,0x3157b57fbe0d
code-creation,LazyCompile,10,56132,0x31576e510c9e,387,_addListener node:events:418:22,0x31575b572c98,~
code-source-info,0x31576e510c9e,13,11979,13994,C0O12021C2O12030C4O12044C6O12057C9O12057C13O12101C18O12112C20O12144C22O12170C27O12170C32O12168C39O12194C40O12214C46O12380C52O12422C60O12475C77O12422C82O12654C87O12673C89O12690C93O12705C97O12816C99O12829C103O12845C109O12854C115O12883C121O12988C129O13022C140O13033C149O13043C166O13056C175O13066C182O13012C193O13141C197O13171C202O13171C209O13218C214O13218C219O13276C222O13280C227O13310C228O13316C233O13332C240O13339C245O13356C251O13372C252O13388C256O13521C264O13618C278O13628C281O13628C295O13578C304O13694C307O13702C312O13694C327O13654C333O13733C339O13521C345O13815C347O13822C351O13861C353O13871C357O13887C359O13894C363O13927C367O13916C371O13941C374O13949C379O13949C384O13978C386O13992,,
code-creation,LazyCompile,10,56235,0x31576e510fd6,15,checkListener node:events:127:23,0x31575b5725f8,~
code-source-info,0x31576e510fd6,13,3670,3726,C0O3685C8O3685C14O3725,,
code-creation,LazyCompile,10,56286,0x31576e5110c6,30, node:internal/validators:235:42,0x31573525a390,~
code-source-info,0x31576e5110c6,17,7207,7323,C0O7228C6O7265C22O7271C27O7265C29O7322,,
code-creation,LazyCompile,10,56434,0x31576e51135e,380,emit node:events:340:44,0x31575b572bd8,~
code-source-info,0x31576e51135e,13,9741,11955,C0O9741C8O9775C10O9781C14O9818C19O9829C21O9861C27O9883C29O9882C34O9924C41O9929C51O9924C56O9958C60O9987C68O10018C72O10036C73O10049C74O10108C78O10131C80O10148C86O10155C91O10166C92O10175C96O10184C98O10202C100O10191C108O10247C110O10259C120O10304C126O10314C132O10259C137O10329C145O10354C157O10403C174O10403C186O10329C197O10677C199O10677C200O10729C205O10760C211O10776C219O10774C220O10809C225O10906C232O10906C238O10950C240O10962C244O10972C246O10972C247O11033C249O11039C253O11050C255O11081C256O11094C257O11098C263O11162C268O11162C275O11316C281O11369C296O11369C303O11446C308O11476C311O11476C316O11514C318O11519C320O11519C325O11554C327O11563C332O11567C337O11567C344O11829C350O11884C365O11884C370O11528C375O11501C378O11941C379O11953,,
code-creation,LazyCompile,10,56574,0x31576e5116fe,172,startListeningIfSignal node:internal/process/signal:22:32,0x31577c04be98,~
script-source,89,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0x31576e5116fe,89,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,56780,0x31576e511abe,19,isSignal node:internal/process/signal:17:18,0x31577c04bce0,~
code-source-info,0x31576e511abe,89,255,334,C0O267C8O303C13O310C17O318C18O332,,
code-creation,LazyCompile,10,56854,0x31576e511c5e,75,setupDebugEnv node:internal/bootstrap/pre_execution:193:23,0x3157b57fdf20,~
code-source-info,0x31576e511c5e,92,6003,6213,C0O6010C6O6010C11O6043C19O6071C24O6075C29O6044C34O6090C42O6094C48O6138C54O6138C59O6175C64O6188C69O6189C74O6212,,
code-creation,LazyCompile,10,56957,0x31576e511ff6,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x31571587a7c8,~
script-source,40,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 0: return debug();\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0x31576e511ff6,40,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
tick,0x7ff803e80ef6,57366,0,0x0,3,0x1077801f0,0x31576e511c7b,0x31576e502428,0x3157b57fbe0d
new,MemoryChunk,0x10f8c0000,262144
code-creation,Function,11,57530,0x10f8c3060,572,getOptionValue node:internal/options:39:24,0x31576e5013d8,^
code-source-info,0x10f8c3060,93,902,1145,,,
code-creation,Function,11,57577,0x10f8c3300,116,isPosixPathSeparator node:path:56:30,0x315715867f00,^
code-source-info,0x10f8c3300,35,1854,1902,,,
code-creation,Function,11,57654,0x10f8c33e0,3076,normalizeString node:path:66:25,0x315715867fa0,^
code-source-info,0x10f8c33e0,35,2161,4085,,,
code-creation,LazyCompile,10,57730,0x31576e512946,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:172:40,0x3157b57fde58,~
code-source-info,0x31576e512946,92,5567,5753,C0O5574C8O5579C14O5619C15O5626C16O5660C22O5660C27O5641C32O5710C38O5743C43O5743C48O5752,,
code-creation,LazyCompile,10,57833,0x31576e512bb6,62,initializeReport node:internal/bootstrap/pre_execution:182:26,0x3157b57fdea8,~
code-source-info,0x31576e512bb6,92,5780,5979,C0O5780C8O5806C16O5806C21O5795C27O5844C42O5865C47O5937C55O5844C61O5978,,
code-creation,Eval,10,58053,0x31576e513136,5, node:internal/process/report:1:1,0x31576e512f30,~
script-source,95,node:internal/process/report,'use strict';\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined && typeof file !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('file'\x2C 'String'\x2C file);\n    } else if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0x31576e513136,95,0,2623,C0O0C4O2623,,
code-creation,Function,10,58351,0x31576e513c4e,315, node:internal/process/report:1:1,0x31576e5130b0,~
code-source-info,0x31576e513c4e,95,0,2623,C0O0C51O66C54O66C59O92C64O24C70O48C76O189C79O189C84O110C90O129C96O147C102O169C108O232C111O232C115O232C117O269C123O312C128O316C136O756C290O2572C297O2593C303O2613C309O2587C314O2622,,
tick,0x1073799f0,58522,1,0x1070a97c0,5,0x1072c15f0,0x31576e501baf,0x31576e513cbd,0x3157b57fcdb5,0x3157b57fc085,0x31576e512bc6,0x31576e502434,0x3157b57fbe0d
code-creation,LazyCompile,10,58624,0x31576e51598e,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:201:40,0x3157b57fdf70,~
code-source-info,0x31576e51598e,92,6314,6410,C0O6350C6O6350C11O6329C16O6389C20O6409,,
code-creation,LazyCompile,10,58703,0x31576e515ad6,57,addSignalHandler node:internal/process/report:97:26,0x31576e513168,~
code-source-info,0x31576e515ad6,95,2222,2368,C0O2232C5O2239C10O2239C16O2269C22O2304C27O2313C32O2313C38O2331C41O2339C49O2339C56O2367,,
code-creation,LazyCompile,10,58779,0x31576e516096,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:207:46,0x3157b57fdfc0,~
code-source-info,0x31576e516096,92,6457,6719,C0O6457C8O6479C18O6479C23O6523C25O6540C26O6547C27O6551C35O6551C40O6581C45O6582C50O6642C58O6642C63O6620C69O6660C74O6668C79O6671C84O6668C91O6718,,
code-creation,LazyCompile,10,58864,0x31576e516326,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:337:37,0x3157b57fe190,~
code-source-info,0x31576e516326,92,10471,11000,C0O10478C3O10490C8O10494C14O10532C20O10532C25O10576C33O10599C38O10603C46O10576C52O10629C53O10639C57O10629C61O10720C64O10735C73O10793C76O10801C81O10805C90O10852C93O10867C102O10909C108O10909C113O10933C118O10934C124O10973C127O10988C132O10973C137O10999,,
code-creation,LazyCompile,10,59018,0x31576e51671e,455,initializePolicy node:internal/bootstrap/pre_execution:365:26,0x3157b57fe230,~
code-source-info,0x31576e51671e,92,11299,13097,C0O11333C10O11333C15O11376C17O11406C21O11414C35O11414C41O11539C49O11539C55O11516C60O11531C65O11658C67O11675C75O11679C81O11694C87O11695C94O11735C100O11767C108O11749C116O11824C120O11846C126O11846C132O11824C138O11860C149O11876C153O11890C161O11904C167O11962C175O11962C180O11996C190O11996C197O12071C207O12071C212O12113C214O12166C222O12166C227O12244C235O12244C241O12212C246O12224C251O12293C257O12293C263O12343C269O12343C275O12402C277O12428C279O12452C283O12433C288O12542C290O12558C295O12493C300O12521C305O12584C311O12620C317O12620C322O12661C328O12661C334O12690C340O12710C344O12697C349O12730C356O12777C358O12806C360O12847C366O12869C376O12869C383O12847C389O12461C394O12415C397O12904C401O12931C415O12937C420O12931C421O13020C429O13020C435O13061C441O13085C447O13062C454O13096,,
code-creation,LazyCompile,10,59143,0x31576e516b0e,63,initializeClusterIPC node:internal/bootstrap/pre_execution:356:30,0x3157b57fe1e0,~
code-source-info,0x31576e516b0e,92,11031,11272,C0O11038C3O11050C10O11054C18O11069C23O11073C29O11111C35O11111C40O11143C45O11143C49O11232C52O11247C62O11271,,
code-creation,LazyCompile,10,59203,0x31576e516c7e,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:460:38,0x3157b57fe370,~
code-source-info,0x31576e516c7e,92,14830,14979,C0O14874C6O14874C11O14845C16O14925C21O14954C26O14978,,
code-creation,Eval,10,59498,0x31576e5175fe,5, node:internal/source_map/source_map_cache:1:1,0x31576e517298,~
script-source,96,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an [eval]-wrapper\x2C which is currently not\n    // supported.\n    debug(err.stack);\n    return;\n  }\n  const match = StringPrototypeMatch(\n    content\x2C\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err.stack);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err.stack);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err.stack);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL) {\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap = esmSourceMapCache.get(sourceURL);\n  if (sourceMap === undefined) {\n    for (const value of cjsSourceMapCache) {\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\n      if (sourceURL === filename) {\n        sourceMap = {\n          data: ObjectGetValueSafe(value\x2C 'data')\n        };\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0x31576e5175fe,96,0,7654,C0O0C4O7654,,
code-creation,Function,10,60274,0x31576e517c76,435, node:internal/source_map/source_map_cache:1:1,0x31576e517578,~
code-source-info,0x31576e517c76,96,0,7654,C0O0C152O25C158O46C164O59C170O75C176O89C182O123C188O156C194O179C199O190C205O214C211O526C217O526C222O515C228O557C234O557C239O590C252O591C258O557C260O653C266O653C270O653C272O695C278O695C283O676C289O752C295O752C300O732C305O832C311O832C316O806C322O901C328O901C333O881C339O1137C341O1137C346O1137C348O1264C350O1264C355O1264C357O1325C363O1325C368O1287C374O1302C380O1317C386O1354C387O1354C389O1370C390O1370C392O7518C399O7539C405O7556C411O7580C417O7604C423O7627C429O7533C434O7653,,
tick,0x7ff803e80c86,60353,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e516c84,0x31576e502458,0x3157b57fbe0d
code-creation,LazyCompile,10,60491,0x31576e518a5e,82,debuglog node:internal/util/debuglog:71:18,0x31571587ab00,~
code-source-info,0x31576e518a5e,40,2232,3279,C0O2232C28O2357C32O2357C34O2789C35O2789C37O2811C41O2811C43O2899C48O3128C58O3149C63O3174C74O3128C79O3263C81O3277,,
code-creation,Eval,10,60711,0x31576e518fde,5, node:internal/util/iterable_weak_map:1:1,0x31576e518d90,~
script-source,97,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0x31576e518fde,97,0,1958,C0O0C4O1958,,
code-creation,Function,10,60983,0x31576e51973e,196, node:internal/util/iterable_weak_map:1:1,0x31576e518f58,~
code-source-info,0x31576e51973e,97,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,61021,0x31576e5198be,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x31576e519268,~
code-source-info,0x31576e5198be,97,399,516,C3O410C10O410C27O441C34O441C48O479C62O479C74O516,,
tick,0x7ff803dd14a2,61063,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e517d9d,0x3157b57fcdb5,0x3157b57fc085,0x31576e516c84,0x31576e502458,0x3157b57fbe0d
code-creation,Eval,10,61408,0x31576e51a586,5, node:internal/modules/cjs/helpers:1:1,0x31576e51a2d0,~
script-source,98,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0x31576e51a586,98,0,6746,C0O0C4O6746,,
code-creation,Function,10,62102,0x31576e51ab06,536, node:internal/modules/cjs/helpers:1:1,0x31576e51a500,~
code-source-info,0x31576e51ab06,98,0,6746,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O856C330O856C335O911C346O1041C353O1083C354O1083C410O1105C465O1041C470O1041C472O1665C474O1665C479O1665C481O6586C488O6607C494O6633C500O6650C506O6666C512O6686C518O6709C524O6733C530O6601C535O6745,,
tick,0x7ff803e80c86,62185,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e517dad,0x3157b57fcdb5,0x3157b57fc085,0x31576e516c84,0x31576e502458,0x3157b57fbe0d
code-creation,LazyCompile,10,62382,0x31576e51b746,27,SafeSet node:internal/per_context/primordials:364:16,0x31575b549fc0,~
script-source,6,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C desc);\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(global[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0x31576e51b746,6,10527,10544,C3O10533C7O10539C11O10533C26O10543,,
tick,0x1070465c3,63628,0,0x0,3,0x1077801f0,0x31576e51acd7,0x3157b57fcdb5,0x3157b57fc085,0x31576e517dad,0x3157b57fcdb5,0x3157b57fc085,0x31576e516c84,0x31576e502458,0x3157b57fbe0d
code-creation,LazyCompile,10,63665,0x31576e51c586,27,SafeMap node:internal/per_context/primordials:351:16,0x31575b549e38,~
code-source-info,0x31576e51c586,6,10200,10217,C3O10206C7O10212C11O10206C26O10216,,
code-creation,LazyCompile,10,63756,0x31576e51c6fe,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x31576e519060,~
code-source-info,0x31576e51c6fe,97,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,63806,0x31576e51ca86,27,SafeWeakMap node:internal/per_context/primordials:357:16,0x31575b549ef8,~
code-source-info,0x31576e51ca86,6,10371,10388,C3O10377C7O10383C11O10377C26O10387,,
code-creation,LazyCompile,10,63865,0x31576e51cb8e,27,SafeFinalizationRegistry node:internal/per_context/primordials:378:16,0x31575b54a148,~
code-source-info,0x31576e51cb8e,6,10977,11022,C3O10997C7O11003C11O10997C26O11021,,
code-creation,LazyCompile,10,64064,0x31576e51d376,492,initializeDeprecations node:internal/bootstrap/pre_execution:250:32,0x3157b57fe100,~
code-source-info,0x31576e51d376,92,7934,10433,C0O7934C11O7963C19O7963C24O7949C29O8018C39O8018C44O8209C52O8209C57O8250C65O8250C70O8303C99O8295C127O8295C130O8621C141O8641C145O8683C156O8757C167O8847C178O8802C187O8668C196O8906C199O8639C203O8284C269O9183C277O9183C282O9162C287O9212C289O9240C304O9261C311O9379C315O9240C320O9411C324O9441C334O9477C344O9554C351O9459C356O9457C360O9640C370O9682C381O9664C386O9662C390O10021C394O10021C396O10032C407O10053C418O10082C426O10124C434O10032C439O10237C445O10237C447O10247C458O10268C469O10296C477O10337C485O10247C491O10432,,
tick,0x7ff803d76c9c,64191,0,0x0,3,0x1077801f0,0x31576e50245e,0x3157b57fbe0d
code-creation,LazyCompile,10,64265,0x31576e51d9a6,53,initializeWASI node:internal/bootstrap/pre_execution:414:24,0x3157b57fe280,~
code-source-info,0x31576e51d9a6,92,13122,13328,C0O13154C6O13154C11O13137C16O13220C21O13224C29O13224C35O13239C37O13270C43O13270C47O13264C52O13327,,
code-creation,LazyCompile,10,64342,0x31576e51dba6,66,initializeCJSLoader node:internal/bootstrap/pre_execution:421:29,0x3157b57fe2d0,~
code-source-info,0x31576e51dba6,92,13358,13673,C0O13383C6O13383C11O13425C16O13430C20O13450C26O13488C31O13495C36O13495C40O13591C51O13612C56O13648C60O13606C65O13672,,
tick,0x1074dbd7a,65407,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,65528,0x31576e51fb5e,5, node:internal/modules/cjs/loader:1:1,0x31576e51f278,~
script-source,99,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C request\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C request\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(filename\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\n    }\n\n    return module.exports;\n  }\n\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers) return mod.exports;\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (parent?.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n      if (pkg.data?.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\n                                  cjsConditions)\x2C request\x2C parent.filename\x2C\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(match\x2C request\x2C parentPath\x2C pkgPath) {\n  const { resolved\x2C exact } = match;\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  let actual = tryFile(filename);\n  if (!exact && !actual) {\n    const exts = ObjectKeys(Module._extensions);\n    actual = tryExtensions(filename\x2C exts\x2C false) ||\n      tryPackage(filename\x2C exts\x2C false\x2C request);\n  }\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename));\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {}\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers) {\n      mod.syncExports();\n    }\n  }\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0x31576e51fb5e,99,0,40182,C0O0C4O40182,,
code-creation,Function,10,69507,0x31576e5218fe,2547, node:internal/modules/cjs/loader:1:1,0x31576e51fad8,~
code-source-info,0x31576e5218fe,99,0,40182,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C518O1431C524O1440C530O1453C535O1469C541O1493C546O1509C552O1543C558O1567C564O1581C570O1600C576O1633C582O1657C587O1666C593O1682C599O1696C605O1719C611O1742C617O1753C622O1768C628O1778C634O1803C640O1832C646O1859C652O1889C658O1915C664O1939C670O1964C676O1988C682O2012C688O2118C690O2118C695O2118C697O2191C709O2212C715O2222C721O2230C727O2242C733O2260C763O2206C767O2376C771O2376C777O2359C783O2450C787O2450C793O2425C799O2555C803O2555C809O2507C815O2522C821O2537C827O2602C831O2602C837O2588C842O2639C846O2639C850O2639C852O2669C856O2669C860O2669C862O2708C866O2708C870O2708C872O2742C876O2742C880O2742C882O2785C886O2785C890O2785C892O2818C896O2810C902O2855C910O2855C916O2832C922O2904C926O2904C930O2904C932O2976C940O2976C946O2961C952O3132C956O3132C962O3018C968O3035C974O3051C980O3071C986O3094C992O3118C998O3200C1002O3200C1008O3181C1014O3254C1022O3254C1026O3254C1028O3322C1036O3322C1040O3322C1042O3432C1050O3432C1060O3476C1067O3432C1069O3656C1070O3656C1072O3825C1076O3825C1082O3825C1088O3687C1094O3714C1100O3748C1106O3769C1112O3804C1118O3880C1122O3880C1128O3861C1134O3939C1142O3939C1147O4051C1151O4051C1157O3991C1163O4013C1169O4036C1175O4105C1179O4105C1185O4093C1191O4155C1195O4155C1199O4155C1201O4222C1205O4222C1211O4203C1217O4290C1225O4290C1231O4275C1237O4402C1241O4402C1247O4332C1253O4351C1259O4376C1265O4462C1269O4470C1277O4479C1280O4462C1282O4522C1285O4522C1289O4522C1291O4562C1292O4562C1294O4581C1295O4581C1297O4606C1298O4606C1300O5250C1302O5250C1307O5250C1309O5546C1312O5595C1316O5595C1350O5577C1381O5566C1388O5573C1397O5612C1403O5640C1407O5640C1412O5550C1483O5687C1487O5717C1493O5739C1497O5758C1504O5774C1508O5772C1512O5794C1519O5814C1527O5812C1535O5834C1542O5855C1550O5853C1558O5893C1562O5893C1564O5897C1572O5916C1580O5937C1581O5937C1583O5995C1587O5995C1589O6091C1597O6205C1606O6218C1618O6345C1635O6195C1645O6195C1647O6484C1659O6505C1668O6525C1680O6558C1692O6484C1702O6618C1714O6639C1723O6662C1735O6703C1747O6618C1757O6796C1766O6798C1781O6832C1789O6860C1806O6832C1816O6906C1824O6940C1841O6906C1851O7132C1859O7160C1884O7190C1892O7313C1907O7211C1921O7394C1931O7418C1939O7541C1954O7439C1968O7622C1976O7132C1986O7656C1990O7656C2000O7689C2020O7690C2032O7656C2034O7737C2050O7753C2060O7751C2068O8066C2072O8066C2082O8066C2084O10869C2088O10869C2098O10869C2100O13498C2107O13498C2109O14282C2116O14282C2118O14300C2126O14317C2134O16993C2141O16993C2143O17070C2147O17078C2155O17070C2157O17086C2161O17149C2169O17173C2179O18757C2187O18781C2195O19927C2203O19954C2211O21502C2223O21520C2235O21897C2249O21502C2259O21502C2261O23185C2269O23198C2277O26129C2285O26153C2293O30233C2297O30240C2311O30255C2319O31169C2323O31176C2337O31194C2345O31632C2346O31632C2348O31667C2349O31667C2351O32724C2355O32731C2369O32750C2377O34632C2381O34639C2395O34658C2403O36402C2407O36409C2421O36430C2429O36830C2433O36837C2447O36858C2455O37671C2461O37721C2467O37671C2469O38305C2475O38326C2483O38344C2491O38362C2499O39331C2507O39354C2515O39941C2523O39970C2531O40158C2537O40172C2546O40181,,
tick,0x10704648c,69793,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x10751dd72,69820,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x7ff803e80ec4,69831,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,70149,0x31576e52596e,5, node:internal/modules/package_json_reader:1:1,0x31576e5257c8,~
script-source,100,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0x31576e52596e,100,0,983,C0O0C4O983,,
code-creation,Function,10,70307,0x31576e525abe,113, node:internal/modules/package_json_reader:1:1,0x31576e5258e8,~
code-source-info,0x31576e525abe,100,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
tick,0x7ff803e4b9ce,70371,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e521c9c,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,70565,0x31576e52628e,5, node:internal/process/esm_loader:1:1,0x31576e526098,~
script-source,101,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\n\nexports.esmLoader = esmLoader;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  const { getOptionValue } = require('internal/options');\n  // customLoaders CURRENTLY can be only 1 (a string)\n  // Once chaining is implemented\x2C it will be string[]\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (!customLoaders.length) return;\n\n  const { emitExperimentalWarning } = require('internal/util');\n  emitExperimentalWarning('--experimental-loader');\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const exports = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(exports);\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0x31576e52628e,101,0,2883,C0O0C4O2883,,
code-creation,Function,10,70855,0x31576e52652e,182, node:internal/process/esm_loader:1:1,0x31576e526208,~
code-source-info,0x31576e52652e,101,0,2883,C0O0C44O25C50O111C56O111C61O137C66O67C72O167C78O167C83O153C89O258C95O258C100O217C106O323C112O323C117O305C123O381C129O381C134O358C140O413C144O448C148O749C152O789C156O1259C159O1259C164O1259C166O1277C168O1295C172O2528C176O2544C181O2882,,
code-creation,Eval,10,71267,0x31576e527596,5, node:internal/modules/esm/loader:1:1,0x31576e527198,~
script-source,102,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeWeakMap\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURLInstance } = require('internal/url');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  /**\n   * Prior to ESM loading. These are called once before any modules are started.\n   * @private\n   * @property {function[]} globalPreloaders First-in-first-out list of\n   * preload hooks.\n   */\n  #globalPreloaders = [];\n\n  /**\n   * Phase 2 of 2 in ESM loading.\n   * @private\n   * @property {function[]} loaders First-in-first-out list of loader hooks.\n   */\n  #loaders = [\n    defaultLoad\x2C\n  ];\n\n  /**\n   * Phase 1 of 2 in ESM loading.\n   * @private\n   * @property {function[]} resolvers First-in-first-out list of resolver hooks\n   */\n  #resolvers = [\n    defaultResolve\x2C\n  ];\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (globalPreload) {\n      acceptedHooks.globalPreloader =\n        FunctionPrototypeBind(globalPreload\x2C null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {object | object[]} customLoaders A list of exports from\n   * user-defined loaders (as returned by ESMLoader.import()).\n   */\n  async addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    if (!ArrayIsArray(customLoaders)) customLoaders = [customLoaders];\n\n    for (let i = 0; i < customLoaders.length; i++) {\n      const exports = customLoaders[i];\n      const {\n        globalPreloader\x2C\n        resolver\x2C\n        loader\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreloader) ArrayPrototypePush(\n        this.#globalPreloaders\x2C\n        FunctionPrototypeBind(globalPreloader\x2C null)\x2C // [1]\n      );\n      if (resolver) ArrayPrototypePush(\n        this.#resolvers\x2C\n        FunctionPrototypeBind(resolver\x2C null)\x2C // [1]\n      );\n      if (loader) ArrayPrototypePush(\n        this.#loaders\x2C\n        FunctionPrototypeBind(loader\x2C null)\x2C // [1]\n      );\n    }\n\n    // [1] ensure hook function is not bound to ESMLoader instance\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }) => {\n          return this.import(specifier\x2C url);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(this\x2C url\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  async getModuleJob(specifier\x2C parentURL) {\n    const { format\x2C url } = await this.resolve(specifier\x2C parentURL);\n    let job = this.moduleMap.get(url);\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') this.moduleMap.set(url\x2C job = job());\n\n    if (job !== undefined) return job;\n\n    const moduleProvider = async (url\x2C isMain) => {\n      const { format: finalFormat\x2C source } = await this.load(url\x2C { format });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat);\n\n      return FunctionPrototypeCall(translator\x2C this\x2C url\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    job = new ModuleJob(\n      this\x2C\n      url\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\n    );\n\n    this.moduleMap.set(url\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   *\n   * @param {string | string[]} specifiers Path(s) to the module\n   * @param {string} [parentURL] Path of the parent importing the module\n   * @returns {object | object[]} A list of module export(s)\n   */\n  async import(specifiers\x2C parentURL) {\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) specifiers = [specifiers];\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n\n    return wasArr ?\n      namespaces :\n      namespaces[0];\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} url The URL/path of the module to be loaded\n   * @param {Object} context Metadata about the module\n   * @returns {Object}\n   */\n  async load(url\x2C context = {}) {\n    const defaultLoader = this.#loaders[0];\n\n    const loader = this.#loaders.length === 1 ?\n      defaultLoader :\n      this.#loaders[1];\n    const loaded = await loader(url\x2C context\x2C defaultLoader);\n\n    if (typeof loaded !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader load'\x2C\n        loaded\x2C\n      );\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_INVALID_MODULE_SPECIFIER(\n        url\x2C\n        dataUrl ? `has an unsupported MIME type "${dataUrl[1]}"` : ''\n      );\n    }\n\n    if (typeof format !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n      'string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n      'loader load'\x2C\n      'source'\x2C\n      source\n    );\n\n    return {\n      format\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    const count = this.#globalPreloaders.length;\n    if (!count) return;\n\n    for (let i = 0; i < count; i++) {\n      const preload = this.#globalPreloaders[i]();\n\n      if (preload == null) return;\n\n      if (typeof preload !== 'string') {\n        throw new ERR_INVALID_RETURN_VALUE(\n          'string'\x2C\n          'loader globalPreloadCode'\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preload\x2C\n        ['getBuiltin']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\n      );\n      const { NativeModule } = require('internal/bootstrap/loaders');\n\n      FunctionPrototypeCall(preloadInit\x2C globalThis\x2C (builtinName) => {\n        if (NativeModule.canBeRequiredByUsers(builtinName)) {\n          return require(builtinName);\n        }\n        throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n      });\n    }\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * The internals of this WILL change when chaining is implemented\x2C\n   * depending on the resolution/consensus from #36954\n   * @param {string} originalSpecifier The specified URL path of the module to\n   * be resolved\n   * @param {String} parentURL The URL path of the module's parent\n   * @returns {{ url: String }}\n   */\n  async resolve(originalSpecifier\x2C parentURL) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURLInstance(parentURL)\n    ) throw new ERR_INVALID_ARG_TYPE(\n      'parentURL'\x2C\n      ['string'\x2C 'URL']\x2C\n      parentURL\x2C\n    );\n\n    const conditions = DEFAULT_CONDITIONS;\n\n    const defaultResolver = this.#resolvers[0];\n\n    const resolver = this.#resolvers.length === 1 ?\n      defaultResolver :\n      this.#resolvers[1];\n    const resolution = await resolver(\n      originalSpecifier\x2C\n      {\n        conditions\x2C\n        parentURL\x2C\n      }\x2C\n      defaultResolver\x2C\n    );\n\n    if (typeof resolution !== 'object') {\n      throw new ERR_INVALID_RETURN_VALUE(\n        'object'\x2C\n        'loader resolve'\x2C\n        resolution\x2C\n      );\n    }\n\n    const { format\x2C url } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string'\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n    if (typeof url !== 'string') {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'string'\x2C\n        'loader resolve'\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    return {\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0x31576e527596,102,0,11918,C0O0C4O11918,,
code-creation,Function,10,72458,0x31576e527cde,530, node:internal/modules/esm/loader:1:1,0x31576e527510,~
code-source-info,0x31576e527cde,102,0,11918,C0O0C104O79C110O79C114O130C120O139C126O155C132O177C138O199C144O224C150O249C156O265C161O289C167O303C173O326C179O347C185O362C191O578C197O578C202O604C207O402C213O426C219O451C225O483C231O520C237O548C243O653C249O653C254O620C260O635C266O731C272O731C277O688C283O708C289O781C295O781C299O781C301O843C307O843C311O843C313O940C319O940C324O898C330O916C336O1005C342O1005C347O989C353O1067C359O1067C364O1051C370O1142C376O1142C381O1123C510O11868C517O11837C522O11887C524O11905C529O11917,,
code-creation,Function,10,72521,0x31576e5280d6,139,<instance_members_initializer> node:internal/modules/esm/loader:59:3,0x31576e527898,~
code-source-info,0x31576e5280d6,102,1611,2404,C3O1631C17O1786C28O1792C45O1966C56O1972C73O2065C80O2065C94O2183C104O2270C111O2270C125O2393C138O2404,,
tick,0x7ff803e981a7,72563,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,72772,0x31576e52949e,5, node:internal/modules/esm/module_map:1:1,0x31576e5292d0,~
script-source,103,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst {\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url) {\n    validateString(url\x2C 'url');\n    return super.get(url);\n  }\n  set(url\x2C job) {\n    validateString(url\x2C 'url');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} in ModuleMap`);\n    return super.set(url\x2C job);\n  }\n  has(url) {\n    validateString(url\x2C 'url');\n    return super.has(url);\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0x31576e52949e,103,0,955,C0O0C4O955,,
code-creation,Function,10,72913,0x31576e5298be,149, node:internal/modules/esm/module_map:1:1,0x31576e529418,~
code-source-info,0x31576e5298be,103,0,955,C0O0C17O33C20O33C24O33C26O87C31O125C34O125C39O158C52O159C58O125C60O236C63O236C68O262C73O211C79O297C82O297C87O278C97O407C141O927C143O942C148O954,,
tick,0x107315ab4,72998,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e527e05,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,73219,0x31576e52a2e6,5, node:internal/modules/esm/module_job:1:1,0x31576e52a000,~
script-source,104,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier) => {\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await PromiseAll(new SafeArrayIterator(promises));\n\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return PromiseAll(new SafeArrayIterator(\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = StringPrototypeReplace(\n          splitStack[0]\x2C\n          /:\\d+$/\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\n          e.message\x2C\n          /module '(.*)' does not provide an export named '(.+)'/);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        const { format } = await this.loader.load(childFileURL);\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\n          const destructuringAssignment = oneLineNamedImports &&\n            StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0x31576e52a2e6,104,0,7692,C0O0C4O7692,,
code-creation,Function,10,73981,0x31576e52a7d6,334, node:internal/modules/esm/module_job:1:1,0x31576e52a260,~
code-source-info,0x31576e52a7d6,104,0,7692,C0O0C85O25C91O47C97O68C103O90C109O112C114O133C119O157C125O171C130O189C136O214C142O230C148O253C154O274C160O285C166O312C172O336C178O362C184O386C190O454C196O454C201O439C207O518C213O518C218O495C224O580C230O580C235O554C241O644C247O644C251O644C253O696C256O696C258O728C260O728C262O769C263O769C265O799C269O799C271O917C275O917C314O7646C321O7615C326O7664C328O7679C333O7691,,
tick,0x7ff803e80ea8,74086,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e5298d2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e05,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,75040,0x31576e52d50e,5, node:internal/modules/esm/resolve:1:1,0x31576e52ce18,~
script-source,105,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   exports?: ExportConfig;\n *   name?: string;\n *   main?: string;\n *   type?: PackageType;\n * }} PackageConfig\n */\n\nconst emittedPackageWarnings = new SafeSet();\n\n/**\n * @param {string} match\n * @param {URL} pjsonUrl\n * @param {boolean} isExports\n * @param {string | URL | undefined} base\n * @returns {void}\n */\nfunction emitFolderMapDeprecation(match\x2C pjsonUrl\x2C isExports\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated folder mapping "${match}" in the ${isExports ?\n      '"exports"' : '"imports"'} field module resolution of the package at ${\n      pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` +\n      `Update this package.json to use a subpath pattern like "${match}*".`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0148'\n  );\n}\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C isExports\x2C base) {\n  if (!pendingDeprecation) return;\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ${\n      isExports ? '"exports"' : '"imports"'} field module resolution of the ` +\n      `package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormat(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%5C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base) {\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  const path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path\x2C '/')) {\n      file = resolveDirectoryEntry(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveDirectoryEntry(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string | URL} subpath\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath))\n    throwInvalidSubpath(match + subpath\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (pattern)\n    return new URL(RegExpPrototypeSymbolReplace(patternRegEx\x2C resolved.href\x2C\n                                                () => subpath));\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\n/**\n *\n * @param {Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    return { resolved\x2C exact: true };\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            true\x2C base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath\x2C key) &&\n      patternKeyCompare(bestMatch\x2C key) === 1) {\n      bestMatch = key;\n      bestMatchSubpath = StringPrototypeSlice(packageSubpath\x2C key.length);\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = StringPrototypeIncludes(bestMatch\x2C '*');\n    const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                          bestMatchSubpath\x2C bestMatch\x2C base\x2C\n                                          pattern\x2C false\x2C conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    if (!pattern)\n      emitFolderMapDeprecation(bestMatch\x2C packageJSONUrl\x2C true\x2C base);\n    return { resolved\x2C exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*') &&\n          !StringPrototypeEndsWith(name\x2C '/')) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolved !== null)\n          return { resolved\x2C exact: true };\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name\x2C key) &&\n            patternKeyCompare(bestMatch\x2C key) === 1) {\n            bestMatch = key;\n            bestMatchSubpath = StringPrototypeSlice(name\x2C key.length);\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = StringPrototypeIncludes(bestMatch\x2C '*');\n          const resolved = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                bestMatchSubpath\x2C bestMatch\x2C\n                                                base\x2C pattern\x2C true\x2C\n                                                conditions);\n          if (resolved !== null) {\n            if (!pattern)\n              emitFolderMapDeprecation(bestMatch\x2C packageJSONUrl\x2C false\x2C base);\n            return { resolved\x2C exact: pattern };\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base);\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier\x2C base\x2C conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier\x2C base\x2C conditions);\n    }\n  }\n  return finalizeResolution(resolved\x2C base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === 'node:')\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: 'node:' + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL\x2C 'data:')) {\n    // This is gonna blow up\x2C we want the error\n    new URL(specifier\x2C parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier\x2C parentURL\x2C conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath\x2C sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n};\n\n// cycle\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\n
code-source-info,0x31576e52d50e,105,0,36468,C0O0C4O36468,,
code-creation,Function,10,78784,0x31576e52e4ae,1086, node:internal/modules/esm/resolve:1:1,0x31576e52d488,~
code-source-info,0x31576e52e4ae,105,0,36468,C0O0C379O25C385O41C391O63C397O86C403O99C409O116C414O132C420O161C426O194C432O204C438O236C444O259C449O270C455O281C461O291C467O318C473O345C479O371C485O401C491O425C497O449C503O512C506O512C510O512C512O567C515O567C520O550C526O655C529O655C534O616C540O632C546O644C552O697C555O697C560O678C566O792C572O792C581O836C588O792C590O916C593O916C598O889C604O894C610O904C616O958C622O958C626O958C628O1026C634O1026C638O1026C640O1087C646O1087C650O1087C652O1146C658O1146C662O1146C664O1233C667O1233C672O1195C678O1200C684O1215C690O1607C693O1607C698O1633C703O1268C709O1298C715O1323C721O1355C727O1385C733O1415C739O1450C745O1474C751O1508C757O1541C763O1571C769O1671C772O1671C777O1657C783O1738C786O1738C790O1738C792O1810C798O1810C803O1859C809O1859C814O1914C825O1975C832O2017C833O2017C887O2039C938O1975C942O1975C944O2091C952O2091C957O2091C959O2408C962O2408C967O2408C969O5520C971O5520C976O5520C978O5560C980O5560C985O5560C987O5700C991O5700C993O11011C997O11011C999O11985C1003O11985C1005O14877C1009O14877C1011O14940C1015O14940C1017O36212C1024O36233C1030O36255C1036O36273C1042O36292C1048O36317C1054O36335C1060O36360C1066O36227C1070O36424C1073O36424C1078O36403C1085O36467,,
tick,0x7ff803e80efa,78939,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e527e1d,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x7ff803e80c00,78982,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e527e1d,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x10728b1b6,78999,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e527e1d,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x107672c23,79012,1,0x10712a580,6,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e527e1d,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,79416,0x31576e531696,5, node:internal/modules/esm/get_format:1:1,0x31576e531470,~
script-source,106,node:internal/modules/esm/get_format,'use strict';\nconst {\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n} = primordials;\nconst { extname } = require('path');\nconst { getOptionValue } = require('internal/options');\n\nconst experimentalJsonModules = getOptionValue('--experimental-json-modules');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\nconst { getPackageType } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.mjs': 'module'\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\n};\n\nif (experimentalWasmModules)\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n\nif (experimentalJsonModules)\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\n\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\n  'data:'(parsed) {\n    const { 1: mime } = RegExpPrototypeExec(\n      /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n      parsed.pathname\x2C\n    ) || [\x2C null];\n    const format = ({\n      '__proto__': null\x2C\n      'text/javascript': 'module'\x2C\n      'application/json': experimentalJsonModules ? 'json' : null\x2C\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\n    })[mime] || null;\n\n    return format;\n  }\x2C\n  'file:'(parsed\x2C url) {\n    const ext = extname(parsed.pathname);\n    let format;\n\n    if (ext === '.js') {\n      format = getPackageType(parsed.href) === 'module' ? 'module' : 'commonjs';\n    } else {\n      format = extensionFormatMap[ext];\n    }\n    if (!format) {\n      if (experimentalSpecifierResolution === 'node') {\n        process.emitWarning(\n          'The Node.js specifier resolution in ESM is experimental.'\x2C\n          'ExperimentalWarning');\n        format = legacyExtensionFormatMap[ext];\n      } else {\n        throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C fileURLToPath(url));\n      }\n    }\n\n    return format || null;\n  }\x2C\n  'node:'() { return 'builtin'; }\x2C\n});\n\nfunction defaultGetFormat(url\x2C context) {\n  const parsed = new URL(url);\n\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\n    protocolHandlers[parsed.protocol](parsed\x2C url) :\n    null;\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  extensionFormatMap\x2C\n  legacyExtensionFormatMap\x2C\n};\n
code-source-info,0x31576e531696,106,0,2630,C0O0C4O2630,,
code-creation,Function,10,79708,0x31576e531ac6,314, node:internal/modules/esm/get_format:1:1,0x31576e531610,~
code-source-info,0x31576e531ac6,106,0,2630,C0O0C53O24C58O40C63O56C69O89C75O147C78O147C83O135C89O191C92O191C97O172C102O253C105O253C109O253C111O342C114O342C118O342C120O429C123O429C127O429C129O503C132O503C137O484C143O575C146O575C151O552C157O557C163O639C166O639C171O665C176O608C182O701C186O701C188O821C192O821C194O956C198O987C207O1051C213O1015C217O1062C221O1093C230O1157C236O1121C240O1193C242O1206C252O1230C260O1646C268O2284C276O1193C281O1193C283O2538C290O2559C296O2579C302O2601C308O2553C313O2629,,
code-creation,Eval,10,79950,0x31576e532456,5, node:internal/modules/esm/load:1:1,0x31576e5322e0,~
script-source,107,node:internal/modules/esm/load,'use strict';\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { defaultGetSource } = require('internal/modules/esm/get_source');\nconst { translators } = require('internal/modules/esm/translators');\n\nasync function defaultLoad(url\x2C context) {\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (!translators.has(format)) format = defaultGetFormat(url);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    source = await defaultGetSource(url\x2C { format });\n  }\n\n  return {\n    format\x2C\n    source\x2C\n  };\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0x31576e532456,107,0,643,C0O0C4O643,,
code-creation,Function,10,80057,0x31576e53259e,80, node:internal/modules/esm/load:1:1,0x31576e5323d0,~
code-source-info,0x31576e53259e,107,0,643,C0O0C19O44C22O44C27O23C33O117C36O117C41O96C47O185C50O185C55O169C61O606C68O627C74O621C79O642,,
code-creation,Eval,10,80214,0x31576e532b06,5, node:internal/modules/esm/get_source:1:1,0x31576e532930,~
script-source,108,node:internal/modules/esm/get_source,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\nconst { Buffer } = require('buffer');\n\nconst fs = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_INVALID_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst readFileAsync = fs.readFile;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function defaultGetSource(url\x2C { format } = {}\x2C defaultGetSource) {\n  const parsed = new URL(url);\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = Buffer.from(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else {\n    throw new ERR_INVALID_URL_SCHEME(['file'\x2C 'data']);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return source;\n}\nexports.defaultGetSource = defaultGetSource;\n
code-source-info,0x31576e532b06,108,0,1349,C0O0C4O1349,,
code-creation,Function,10,80418,0x31576e532c76,169, node:internal/modules/esm/get_source:1:1,0x31576e532a80,~
code-source-info,0x31576e532c76,108,0,1349,C0O0C37O25C43O48C49O112C52O112C57O93C62O207C65O207C74O251C81O207C83O316C86O316C91O305C97O347C100O347C105O378C110O404C113O404C118O396C124O486C127O486C132O512C137O439C143O458C149O545C153O542C155O581C159O581C161O1304C163O1329C168O1348,,
tick,0x7ff803e80cf2,80508,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,81304,0x31576e533fee,5, node:internal/fs/promises:1:1,0x31576e533850,~
script-source,109,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = internalBinding('constants').fs;\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst { lazyDOMException\x2C promisify } = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError();\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrOptions;\n  if (!isArrayBufferView(buffer)) {\n    if (bufferOrOptions === undefined) {\n      bufferOrOptions = {};\n    }\n    if (bufferOrOptions.buffer) {\n      buffer = bufferOrOptions.buffer;\n      validateBuffer(buffer);\n    } else {\n      buffer = Buffer.alloc(16384);\n    }\n    offset = bufferOrOptions.offset || 0;\n    length = buffer.byteLength;\n    position = bufferOrOptions.position || null;\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  if (isArrayBufferView(buffer)) {\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return SafePromisePrototypeFinally(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || {};\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return SafePromisePrototypeFinally(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return SafePromisePrototypeFinally(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return SafePromisePrototypeFinally(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0x31576e533fee,109,0,22879,C0O0C4O22879,,
code-creation,Function,10,83606,0x31576e536726,1659, node:internal/fs/promises:1:1,0x31576e533f68,~
code-source-info,0x31576e536726,109,0,22879,C0O0C490O25C496O47C502O56C508O67C514O78C520O101C526O112C532O136C538O154C544O175C550O206C555O216C561O311C565O311C571O339C577O256C583O264C589O277C595O289C601O299C607O360C611O360C615O360C617O402C625O402C631O391C637O550C645O550C651O550C657O445C663O472C669O499C675O534C681O608C689O608C695O586C701O667C709O667C715O648C721O1300C729O1300C735O1300C741O725C747O743C753O759C759O786C765O820C771O851C777O865C783O894C788O908C794O922C800O945C806O965C812O981C818O994C824O1026C830O1043C836O1066C842O1085C848O1108C854O1129C860O1157C866O1186C871O1207C877O1231C883O1269C889O1350C897O1350C903O1338C908O1524C916O1524C922O1388C928O1405C934O1428C940O1447C946O1465C952O1485C958O1504C964O1575C972O1575C976O1575C978O1632C986O1632C992O1600C998O1618C1003O1688C1011O1688C1017O1666C1022O1740C1030O1740C1036O1730C1041O1796C1049O1796C1055O1781C1061O1846C1069O1846C1073O1846C1075O1891C1079O1891C1083O1891C1085O1922C1089O1922C1093O1922C1095O1951C1099O1951C1103O1951C1105O1990C1109O1990C1113O1990C1115O2037C1119O2037C1123O2037C1125O2083C1129O2083C1133O2083C1135O2120C1139O2120C1143O2120C1145O2151C1149O2151C1153O2151C1155O2195C1159O2178C1165O2273C1173O2273C1179O2214C1184O2230C1189O2244C1194O2255C1199O2353C1203O2353C1205O2409C1209O2409C1211O2444C1212O2444C1214O2599C1215O2599C1217O2720C1339O5857C1349O6260C1359O6317C1371O6408C1381O6445C1413O2695C1415O22436C1421O22466C1429O22472C1435O22484C1441O22498C1447O22506C1451O22525C1461O22549C1467O22561C1473O22575C1479O22583C1485O22594C1491O22605C1497O22618C1503O22632C1509O22645C1515O22656C1521O22666C1527O22676C1533O22688C1539O22699C1545O22711C1551O22723C1557O22734C1563O22746C1569O22759C1575O22773C1581O22786C1587O22801C1593O22817C1599O22831C1619O22846C1629O22860C1639O22868C1649O22451C1658O22878,,
code-creation,Function,10,83750,0x31576e5370ce,27,<instance_members_initializer> node:internal/fs/promises:189:3,0x31576e5355c8,~
code-source-info,0x31576e5370ce,109,4202,5000,C0O4202C12O4210C26O5000,,
tick,0x7ff803e8093b,83786,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x7ff803e80ec4,83817,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x1077ceead,83994,1,0x10712a580,6,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,84374,0x31576e539b6e,5, node:internal/fs/rimraf:1:1,0x31576e539808,~
script-source,110,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR')\n      throw originalErr;\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          }\n        }\n      }\n    }\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0x31576e539b6e,110,0,7095,C0O0C4O7095,,
code-creation,Function,10,85099,0x31576e53a16e,409, node:internal/fs/rimraf:1:1,0x31576e539ae8,~
code-source-info,0x31576e53a16e,110,0,7095,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7038C385O7057C391O7065C397O7081C403O7053C408O7094,,
tick,0x107409f22,85300,1,0x10712a580,6,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e5369eb,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,LazyCompile,10,85440,0x31576e53b006,188,from node:buffer:295:28,0x315735264b08,~
script-source,18,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\n  if (!mustMatch && len === 0)\n    return 0;\n\n  if (!encoding)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    return (mustMatch ? -1 : byteLengthUtf8(string));\n  return ops.byteLength(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\n    err.code = code;\n    err.errno = result;\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\nconst kBase64Digits =\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (!kBase64Digits.includes(input[n]))\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
code-source-info,0x31576e53b006,18,8406,9357,C3O8444C9O8479C12O8486C17O8522C18O8526C28O8581C33O8585C39O8616C51O8623C56O8672C57O8700C63O8717C68O8717C73O8732C78O8771C95O8862C104O8869C109O8909C110O8931C113O8931C118O8954C120O8967C122O8976C123O8982C125O8999C127O8998C134O9060C136O9066C138O9065C145O9084C151O9102C155O9147C158O9154C163O9194C164O9216C182O9222C187O9216,,
tick,0x7ff803e80c81,89014,0,0x0,3,0x1077801f0,0x31576e53a2e1,0x3157b57fcdb5,0x3157b57fc085,0x31576e5369eb,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x7ff803e4b9ce,89037,0,0x0,3,0x1077801f0,0x31576e53a2e1,0x3157b57fcdb5,0x3157b57fc085,0x31576e5369eb,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x107046480,89054,0,0x0,3,0x1077801f0,0x31576e53a2e1,0x3157b57fcdb5,0x3157b57fc085,0x31576e5369eb,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,LazyCompile,10,89110,0x31576e53d9de,110,fromString node:buffer:431:20,0x315735264ef0,~
code-source-info,0x31576e53d9de,18,12457,12891,C0O12484C2O12491C8O12536C14O12543C19O12567C25O12574C30O12587C35O12594C40O12611C41O12616C46O12634C51O12644C56O12681C59O12687C64O12717C66O12746C73O12752C78O12746C79O12803C85O12810C90O12823C95O12830C100O12847C101O12854C104O12861C109O12889,,
code-creation,LazyCompile,10,89238,0x31576e53db96,177,fromStringFast node:buffer:412:24,0x315735264e50,~
code-source-info,0x31576e53db96,18,11913,12436,C0O11950C5O11950C11O11973C14O11995C18O12004C21O11984C26O12016C31O12052C36O12023C41O12065C42O12069C44O12083C49O12094C51O12092C54O12080C59O12111C62O12111C65O12135C72O12150C77O12161C85O12135C91O12203C110O12203C116O12234C118O12245C123O12329C130O12348C135O12359C143O12333C149O12386C156O12400C162O12397C168O12410C171O12410C174O12425C176O12434,,
code-creation,LazyCompile,10,89317,0x31576e53dd86,36,FastBuffer node:internal/buffer:958:14,0x315735271a18,~
code-source-info,0x31576e53dd86,19,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,89366,0x31576e53de86,23,write node:buffer:592:12,0x315735265260,~
code-source-info,0x31576e53de86,18,16525,16589,C0O16559C17O16559C22O16589,,
code-creation,LazyCompile,10,89436,0x31576e53df76,42,alignPool node:buffer:158:19,0x315735264888,~
code-source-info,0x31576e53df76,18,3998,4102,C0O4032C4O4047C9O4060C19O4071C25O4083C34O4093C41O4101,,
code-creation,LazyCompile,10,89647,0x31576e53e336,251,promisify node:internal/util:324:19,0x31575b56a438,~
script-source,12,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { value: type.name }\x2C\n    length: { value: type.length }\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\n        continue;\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\nlet DOMException;\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  if (DOMException === undefined)\n    DOMException = internalBinding('messaging').DOMException;\n  return new DOMException(message\x2C name);\n});\n\nfunction structuredClone(value) {\n  const {\n    DefaultSerializer\x2C\n    DefaultDeserializer\x2C\n  } = require('v8');\n  const ser = new DefaultSerializer();\n  ser._getDataCloneError = hideStackFrames((message) =>\n    lazyDOMException(message\x2C 'DataCloneError'));\n  ser.writeValue(value);\n  const serialized = ser.releaseBuffer();\n\n  const des = new DefaultDeserializer(serialized);\n  return des.readValue();\n}\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  structuredClone\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\n};\n
code-source-info,0x31576e53e336,12,8845,10349,C0O8845C17O8907C25O8947C33O8971C38O8950C55O9007C68O9007C73O9050C80O9063C82O9062C87O9107C94O9116C96O9115C100O9148C110O9148C115O9200C126O9232C136O9273C143O9207C148O9339C149O9502C156O9511C158O9510C161O9502C163O10066C174O10091C180O10091C185O10066C190O10127C201O10152C211O10191C218O10127C223O10258C234O10301C240O10301C245O10265C250O10347,,
tick,0x7ff803e98203,91054,0,0x0,3,0x1077801f0,0x31576e536bd5,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
new,MemoryChunk,0x3157a91c0000,262144
code-creation,LazyCompile,10,91300,0x31576e53f85e,65,EventEmitterMixin node:internal/event_target:827:27,0x315715876290,~
script-source,38,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst { customInspectSymbol } = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\n// TODO(joyeecheung): V8 snapshot does not support instance member\n// initializers for now:\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\nconst kType = Symbol('type');\nconst kDefaultPrevented = Symbol('defaultPrevented');\nconst kCancelable = Symbol('cancelable');\nconst kTimestamp = Symbol('timestamp');\nconst kBubbles = Symbol('bubbles');\nconst kComposed = Symbol('composed');\nconst kPropagationStopped = Symbol('propagationStopped');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  constructor(type\x2C options = null) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options'\x2C {\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\n    });\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\n    this[kCancelable] = !!cancelable;\n    this[kBubbles] = !!bubbles;\n    this[kComposed] = !!composed;\n    this[kType] = `${type}`;\n    this[kDefaultPrevented] = false;\n    this[kTimestamp] = now();\n    this[kPropagationStopped] = false;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this[kDefaultPrevented]\x2C\n      cancelable: this[kCancelable]\x2C\n      timeStamp: this[kTimestamp]\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kDefaultPrevented] = true;\n  }\n\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable];\n  }\n\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kCancelable] && this[kDefaultPrevented];\n  }\n\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTimestamp];\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.defaultPrevented;\n  }\n\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kBubbles];\n  }\n\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kComposed];\n  }\n\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kPropagationStopped];\n  }\n\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kPropagationStopped] = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n  });\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  addEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the shouldAddListeners check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!shouldAddListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive);\n  }\n\n  removeEventListener(type\x2C listener\x2C options = {}) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (!shouldAddListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction shouldAddListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return {};\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    get() {\n      return this[kHandlers]?.get(name)?.handler;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0x31576e53f85e,38,23423,23845,C0O23475C23O23659C30O23691C33O23704C38O23659C43O23718C47O23751C52O23792C57O23751C62O23818C64O23843,,
tick,0x1070465d6,93595,0,0x0,3,0x1077801f0,0x31576e536be7,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x7ff803e8095f,93630,0,0x0,3,0x1077801f0,0x31576e536be7,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
tick,0x10767af56,93726,0,0x0,0,0x1072e3520,0x31576e53f897,0x31576e536be7,0x3157b57fcdb5,0x3157b57fc085,0x31576e532cda,0x3157b57fcdb5,0x3157b57fc085,0x31576e5325c2,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,94277,0x3157a91c37a6,5, node:internal/modules/esm/translators:1:1,0x3157a91c32f0,~
script-source,111,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n    getOptionValue('--experimental-import-meta-resolve');\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    await init();\n    cjsParse = parse;\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }) {\n  return asyncESM.esmLoader.import(specifier\x2C url);\n}\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\nfunction initializeImportMeta(meta\x2C { url }) {\n  // Alphabetical\n  if (experimentalImportMetaResolve)\n    meta.resolve = createImportMetaResolve(url);\n  meta.url = url;\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {}\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {}\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing Web Assembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0x3157a91c37a6,111,0,11226,C0O0C4O11226,,
code-creation,Function,10,95388,0x3157a91c4046,773, node:internal/modules/esm/translators:1:1,0x3157a91c3720,~
code-source-info,0x3157a91c4046,111,0,11226,C0O0C201O25C207O50C213O71C219O82C225O95C231O119C237O152C243O166C249O190C255O207C261O228C266O239C272O250C278O276C284O300C290O329C301O367C307O413C308O413C310O558C316O558C321O541C327O605C333O605C338O581C344O590C350O682C356O682C361O632C367O648C373O668C379O772C385O772C390O741C396O754C402O838C408O838C412O838C414O891C420O891C424O891C426O980C432O980C437O957C443O972C449O1008C455O1008C460O1041C473O1042C479O1008C481O1122C487O1122C492O1094C498O1226C504O1226C509O1252C514O1158C520O1188C526O1292C532O1292C537O1268C543O1360C546O1360C550O1360C552O1415C555O1400C561O1454C567O1454C572O1435C577O1525C580O1525C584O1525C586O1596C592O1596C596O1596C598O1664C604O1664C609O1644C615O1725C621O1725C626O1709C632O1760C633O1760C635O2084C637O2084C643O2099C645O2119C649O2134C651O2157C655O2190C656O2190C658O3712C671O3712C677O4902C684O4911C687O4894C689O4944C693O4944C695O4963C708O4963C714O7967C727O7967C733O8416C746O8416C752O10364C765O10364C772O11225,,
tick,0x7ff803d61c90,95529,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e5325d0,0x3157b57fcdb5,0x3157b57fc085,0x31576e527e34,0x3157b57fcdb5,0x3157b57fc085,0x31576e52657c,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,95755,0x3157a91c565e,5, node:internal/modules/esm/create_dynamic_module:1:1,0x3157a91c5488,~
script-source,112,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0x3157a91c565e,112,0,1756,C0O0C4O1756,,
code-creation,Function,10,95975,0x3157a91c5886,111, node:internal/modules/esm/create_dynamic_module:1:1,0x3157a91c55d8,~
code-source-info,0x3157a91c5886,112,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
tick,0x10729e71e,96298,1,0x10712a580,2,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e5265af,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,Eval,10,96578,0x3157a91c6b3e,5, node:internal/vm/module:1:1,0x3157a91c65f8,~
script-source,113,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = {}) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = {}) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\n          // and error cause proposal.\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await PromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0x3157a91c6b3e,113,0,12310,C0O0C4O12310,,
code-creation,Function,10,97796,0x3157a91c7d9e,872, node:internal/vm/module:1:1,0x3157a91c6ab8,~
code-source-info,0x3157a91c7d9e,113,0,12310,C0O0C156O30C162O30C166O30C168O68C174O84C180O109C186O134C192O156C198O172C204O196C210O220C216O244C222O258C228O274C233O289C238O299C244O320C250O371C253O371C258O357C264O462C270O462C275O412C281O439C287O576C293O576C298O504C304O524C309O547C315O858C321O858C326O884C331O612C337O636C343O661C349O693C355O728C361O771C367O804C373O832C379O1014C385O1014C390O902C396O921C402O941C408O958C414O976C420O994C426O1063C429O1063C433O1063C435O1216C438O1105C444O1119C449O1138C454O1156C460O1173C465O1188C471O1202C477O1245C484O1250C488O1268C495O1283C499O1300C506O1314C510O1330C517O1343C521O1357C528O1374C532O1387C539O1403C543O1414C550O1245C552O1450C553O1450C555O1479C557O1479C559O1516C561O1516C566O1516C568O1550C571O1550C575O1550C577O1584C580O1584C584O1584C586O1632C589O1632C593O1632C595O1677C598O1677C602O1677C660O5923C688O6683C691O6683C695O6683C697O6733C700O6733C704O6733C736O6785C799O10265C827O12150C834O12171C840O12181C846O12201C852O12220C856O12270C866O12165C871O12309,,
code-creation,Function,10,97891,0x3157a91c82de,30,<instance_members_initializer> node:internal/vm/module:256:3,0x3157a91c7128,~
code-source-info,0x3157a91c82de,113,6796,6832,C3O6805C29O6832,,
tick,0x10704649a,97939,1,0x10712a580,3,0x1072c15f0,0x3157b57fcd94,0x3157b57fc085,0x31576e5265af,0x3157b57fcdb5,0x3157b57fc085,0x31576e521da9,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,LazyCompile,10,98118,0x3157a91c97a6,16,ESMLoader node:internal/modules/esm/loader:52:1,0x31576e5275c8,~
code-source-info,0x3157a91c97a6,102,1392,1392,C0O1392C15O1392,,
code-creation,LazyCompile,10,98197,0x3157a91ca73e,27,ModuleMap node:internal/modules/esm/module_map:15:14,0x31576e529520,~
code-source-info,0x3157a91ca73e,103,430,447,C3O436C7O442C11O436C26O446,,
code-creation,LazyCompile,10,98263,0x3157a91ca99e,13,desc.value node:internal/per_context/primordials:325:32,0x31575b549d90,~
code-source-info,0x3157a91ca99e,6,9496,9555,C0O9513C7O9520C12O9543,,
code-creation,LazyCompile,10,98327,0x3157a91caaa6,13,SafeIterator node:internal/per_context/primordials:270:16,0x31575b5497e0,~
code-source-info,0x3157a91caaa6,6,7785,7845,C0O7804C3O7821C7O7819C12O7844,,
code-creation,LazyCompile,10,98379,0x3157a91cabde,13,next node:internal/per_context/primordials:273:9,0x31575b5498a8,~
code-source-info,0x3157a91cabde,6,7854,7899,C0O7865C3O7882C8O7872C12O7893,,
code-creation,LazyCompile,10,98619,0x3157a91cae5e,152,deprecate node:internal/util:96:19,0x31575b569cc0,~
code-source-info,0x3157a91cae5e,12,2408,3584,C0O2408C26O2428C31O2440C37O2454C42O2470C44O2480C45O2535C53O2573C61O2595C66O2576C83O2631C87O2659C100O2659C105O2705C106O2705C108O3280C121O3280C126O3320C129O3327C135O3520C141O3546C145O3541C149O3564C151O3582,,
tick,0x107629dce,98714,0,0x0,0,0x1077905f0,0x107b72820,0x3157a91caed7,0x31576e522100,0x3157b57fcdb5,0x3157b57fc085,0x31576e51dbac,0x31576e50246a,0x3157b57fbe0d
code-creation,LazyCompile,10,98875,0x3157a91cb43e,28,getEmbedderOptions node:internal/options:32:28,0x31576e501388,~
code-source-info,0x3157a91cb43e,93,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,99103,0x3157a91cb6e6,315,Module._initPaths node:internal/modules/cjs/loader:1227:29,0x31576e520de0,~
code-source-info,0x3157a91cb6e6,99,38372,39328,C0O38395C9O38415C14O38419C22O38433C28O38433C33O38472C42O38492C47O38496C55O38508C61O38508C66O38703C74O38719C77O38724C85O38740C93O38724C103O38762C106O38767C114O38783C125O38767C131O38823C140O38824C143O38829C157O38829C169O38868C173O38887C180O38916C183O38921C191O38921C198O38887C203O38963C210O38992C213O38997C221O38997C228O38963C233O39040C237O39060C244O39094C249O39122C254O39153C257O39158C262O39122C270O39176C273O39094C279O39060C284O39199C286O39211C292O39272C297O39293C302O39313C305O39293C309O39291C314O39327,,
code-creation,Function,11,99322,0x10f8c4060,1284,resolve node:path:1091:10,0x315715868488,^
code-source-info,0x10f8c4060,35,33782,34692,,,
code-creation,Function,11,99368,0x10f8c45e0,664,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x31575b54f8f8,^
code-source-info,0x10f8c45e0,9,10315,10658,,,
code-creation,Function,11,99410,0x10f8c48e0,1252,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x31575b54f828,^
code-source-info,0x10f8c48e0,9,9528,10089,,,
code-creation,Function,11,99448,0x10f8c4e40,432,getCLIOptionsFromBinding node:internal/options:18:34,0x31576e5012e8,^
code-source-info,0x10f8c4e40,93,497,598,,,
code-creation,Function,11,99478,0x10f8c5060,104,next node:internal/per_context/primordials:273:9,0x31575b5498a8,^
code-source-info,0x10f8c5060,6,7854,7899,,,
code-creation,Function,11,99508,0x10f8c5140,252,SafeMap node:internal/per_context/primordials:351:16,0x31575b549e38,^
code-source-info,0x10f8c5140,6,10200,10217,,,
code-creation,Eval,10,99683,0x3157a91ce9de,5, node:internal/modules/run_main:1:1,0x3157a91ce7d8,~
script-source,114,node:internal/modules/run_main,'use strict';\n\nconst {\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  const userLoader = getOptionValue('--experimental-loader');\n  if (userLoader)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href :\n      mainPath;\n    return esmLoader.import(main);\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  // Handle a Promise from running code that potentially does Top-Level Await.\n  // In that case\x2C it makes sense to set the exit code to a specific non-zero\n  // value if the main code never finishes running.\n  function handler() {\n    if (process.exitCode === undefined)\n      process.exitCode = 13;\n  }\n  process.on('exit'\x2C handler);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handler);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0x3157a91ce9de,114,0,2695,C0O0C4O2695,,
code-creation,Function,10,100002,0x3157a91cecd6,149, node:internal/modules/run_main:1:1,0x3157a91ce958,~
code-source-info,0x3157a91cecd6,114,0,2695,C0O0C60O25C66O85C72O85C77O133C83O141C89O153C95O212C101O212C106O193C112O254C118O254C122O254C124O2627C131O2648C137O2673C143O2642C148O2694,,
tick,0x7ff803e4b9ce,100055,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x31576e51dbd9,0x31576e50246a,0x3157b57fbe0d
code-creation,LazyCompile,10,100155,0x3157a91cf48e,163,initializeESMLoader node:internal/bootstrap/pre_execution:431:29,0x3157b57fe320,~
code-source-info,0x3157a91cf48e,92,13703,14791,C0O13785C6O13785C13O13834C16O13830C21O13828C25O13852C30O13856C34O13876C40O13905C41O13912C42O14012C48O14012C53O13928C58O13968C63O14058C69O14058C74O14259C79O14217C83O14329C88O14290C92O14495C100O14499C106O14615C112O14615C117O14564C122O14572C127O14590C132O14661C138O14661C143O14680C145O14690C149O14704C151O14724C155O14748C157O14767C162O14790,,
code-creation,LazyCompile,10,100242,0x3157a91cf6a6,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x31576e5202d0,~
code-source-info,0x3157a91cf6a6,99,2306,2346,C0O2311C4O2344,,
code-creation,LazyCompile,10,100294,0x3157a91cf74e,21,assert node:internal/assert:11:16,0x3157352577b8,~
script-source,16,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0x3157a91cf74e,16,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,100401,0x3157a91cf94e,53,loadPreloadModules node:internal/bootstrap/pre_execution:474:28,0x3157b57fe410,~
code-source-info,0x3157a91cf94e,92,15267,15587,C0O15354C8O15354C13O15385C15O15422C21O15429C26O15505C32O15505C37O15505C42O15472C47O15549C52O15586,,
code-creation,LazyCompile,10,100489,0x3157a91cfb3e,166,Module._preloadModules node:internal/modules/cjs/loader:1257:34,0x31576e520e70,~
code-source-info,0x3157a91cfb3e,99,39364,39938,C0O39379C5O39384C11O39412C12O39419C13O39423C17O39436C23O39631C33O39631C42O39681C45O39703C53O39728C58O39728C63O39703C68O39694C85O39756C88O39762C95O39767C100O39789C106O39802C114O39817C116O39817C119O39851C121O39867C125O39856C130O39891C137O39907C141O39891C146O39876C151O39838C154O39915C158O39928C165O39937,,
code-creation,LazyCompile,10,100592,0x3157a91cfd5e,94,Module node:internal/modules/cjs/loader:172:16,0x31576e51fc30,~
code-source-info,0x3157a91cfd5e,99,5284,5521,C14O5306C16O5314C20O5322C22O5334C25O5339C30O5339C35O5332C39O5354C40O5367C44O5375C49O5393C54O5393C60O5414C71O5414C76O5453C77O5467C81O5477C82O5489C86O5500C88O5514C93O5520,,
code-creation,LazyCompile,10,100698,0x3157a91cff96,162,dirname node:path:1275:10,0x315715868668,~
code-source-info,0x3157a91cff96,35,38742,39411,C0O38755C8O38755C13O38798C19O38805C24O38818C26O38829C27O38850C34O38850C42O38889C44O38885C48O38923C51O38950C53O38978C57O38985C61O38992C63O38992C68O39011C73O39015C81O39054C83O39050C88O39084C92O39115C97O39134C101O39221C103O39000C108O38960C111O39262C113O39270C118O39284C128O39311C129O39316C135O39335C140O39348C142O39360C143O39365C156O39372C161O39407,,
code-creation,LazyCompile,10,100790,0x3157a91d016e,45,updateChildren node:internal/modules/cjs/loader:165:24,0x31576e51fbe0,~
code-source-info,0x3157a91d016e,99,5049,5222,C0O5092C7O5098C15O5112C19O5130C23O5138C26O5138C33O5184C38O5184C44O5221,,
code-creation,LazyCompile,10,100889,0x3157a91d032e,183,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x31576e520710,~
code-source-info,0x3157a91d032e,99,18791,19922,C0O18846C5O18858C10O18858C17O19037C19O19046C24O19061C28O19086C29O19301C32O19327C36O19334C40O19343C42O19358C47O19368C48O19368C53O19400C58O19400C64O19442C66O19455C68O19451C73O19485C75O19495C77O19491C82O19512C89O19563C100O19563C108O19599C112O19512C117O19638C120O19656C124O19676C126O19682C131O19700C138O19711C144O19715C149O19737C156O19769C159O19376C164O19309C167O19856C175O19856C180O19905C182O19918,,
code-creation,LazyCompile,10,101030,0x3157a91d06ce,127,Module.require node:internal/modules/cjs/loader:997:36,0x31576e520a70,~
code-source-info,0x3157a91d06ce,99,31204,31495,C0O31213C8O31213C13O31241C15O31248C20O31262C36O31268C41O31262C42O31377C51O31389C60O31405C63O31419C76O31419C93O31474C102O31486C126O31494,,
code-creation,LazyCompile,10,101208,0x3157a91d09b6,619,Module._load node:internal/modules/cjs/loader:757:24,0x31576e5208d0,~
code-source-info,0x3157a91d09b6,99,23208,26126,C0O23242C2O23271C6O23289C14O23349C23O23289C28O23579C42O23590C47O23622C54O23642C58O23675C60O23732C63O23739C70O23745C74O23763C76O23805C88O23805C93O23875C99O23893C102O23900C106O23943C107O23972C111O23980C112O23995C119O24023C121O24081C124O24088C138O24088C144O24133C152O24137C159O24228C167O24228C173O24283C178O24283C184O24318C189O24329C198O24361C205O24367C210O24361C211O24434C215O24442C216O24471C219O24478C226O24484C230O24498C232O24536C244O24536C249O24602C255O24644C260O24658C265O24658C271O24683C273O24727C279O24743C282O24750C286O24793C287O24800C288O24825C294O24872C298O24880C299O24906C304O24906C310O24945C315O24952C324O24987C328O24995C329O25081C344O25097C350O25130C354O25148C359O25167C363O25181C365O25191C369O25205C372O25212C379O25229C383O25241C387O25273C394O25321C398O25352C403O25377C409O25377C414O25397C426O25403C427O25430C432O25449C436O25463C444O25470C446O25487C450O25523C458O25551C460O25604C467O25610C475O25630C481O25634C487O25684C493O25684C499O25735C501O25745C506O25767C522O25767C529O25861C537O25888C541O25903C547O25888C555O25930C559O25958C565O25930C573O25988C575O25967C580O26034C586O26062C594O26071C598O26034C614O26116C618O26124,,
tick,0x7ff803d507cc,101371,0,0x0,3,0x1077801f0,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,101401,0x3157a91d0e4e,104,logger node:internal/util/debuglog:96:18,0x31571587ad68,~
code-source-info,0x3157a91d0e4e,40,2899,3124,C0O2899C3O2931C30O2955C35O2962C38O2970C39O2985C45O3002C49O2992C53O3007C54O3022C60O3039C66O3048C70O3029C75O3053C76O3069C80O3076C87O3089C92O3085C98O3076C103O3114,,
code-creation,LazyCompile,10,101496,0x3157a91d0fa6,3, node:internal/per_context/primordials:276:21,0x31575b549950,~
code-source-info,0x3157a91d0fa6,6,7920,7949,C0O7931C2O7943,,
code-creation,LazyCompile,10,101586,0x3157a91d107e,155,debug node:internal/util/debuglog:76:15,0x31571587acc8,~
code-source-info,0x3157a91d107e,40,2357,2781,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C81O2612C86O2619C89O2627C90O2642C96O2659C100O2649C104O2664C105O2679C111O2696C117O2705C121O2686C126O2710C127O2726C131O2733C138O2746C143O2742C149O2733C154O2771,,
code-creation,LazyCompile,10,101653,0x3157a91d124e,41,init node:internal/util/debuglog:72:16,0x31571587ac78,~
code-source-info,0x3157a91d124e,40,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,101701,0x3157a91d133e,2,testEnabled node:internal/util/debuglog:32:19,0x31576e511ed0,~
code-source-info,0x3157a91d133e,40,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,101779,0x3157a91d14d6,116,debuglogImpl node:internal/util/debuglog:49:22,0x31571587aab0,~
code-source-info,0x3157a91d14d6,40,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
code-creation,LazyCompile,10,101844,0x3157a91d168e,10, node:internal/modules/cjs/loader:272:66,0x31576e5205a0,~
code-source-info,0x3157a91d168e,99,7709,7734,C0O7721C2O7727C9O7733,,
code-creation,LazyCompile,10,101886,0x3157a91d173e,2,noop node:internal/util/debuglog:47:14,0x31571587aa60,~
code-source-info,0x3157a91d173e,40,1419,1427,C1O1426,,
code-creation,LazyCompile,10,102083,0x3157a91d1b4e,812,Module._resolveFilename node:internal/modules/cjs/loader:848:35,0x31576e520958,~
code-source-info,0x3157a91d1b4e,99,26163,29160,C0O26202C10O26206C19O26259C23O26272C29O26272C36O26309C38O26324C39O26336C41O26346C51O26405C57O26430C63O26409C69O26465C79O26465C88O26519C96O26519C105O26576C111O26589C119O26589C128O26645C136O26645C142O26697C144O26739C151O26788C164O26788C170O26819C173O26853C175O26868C181O26874C185O26858C190O26920C198O26925C202O26940C206O26966C212O26966C217O26957C221O27020C225O27027C231O27027C238O27093C240O27112C244O27098C249O27139C257O27185C262O27144C269O27205C277O27242C282O27205C287O27121C292O27080C295O26883C300O26840C305O27301C311O27330C315O27345C321O27345C330O27402C340O27459C348O27408C353O27402C356O27488C360O27503C366O27503C373O27548C380O27558C389O27576C390O27587C397O27591C402O27620C406O27644C412O27620C420O27675C428O27679C441O27724C447O27766C453O27797C457O27818C463O27797C471O27863C478O27766C485O27895C491O27921C500O27731C505O27927C519O27960C523O27966C531O27971C536O28011C542O28017C546O28011C547O28058C549O28058C550O28155C554O28155C559O28205C563O28205C569O28237C571O28278C573O28286C578O28313C586O28320C592O28333C599O28339C607O28339C612O28295C616O28379C620O28386C628O28407C632O28427C634O28447C635O28533C639O28540C657O28540C663O28584C665O28598C667O28614C668O28638C671O28662C676O28674C680O28732C686O28772C695O28791C701O28732C706O28693C712O28713C718O28713C724O28644C727O28816C733O28839C745O28870C752O28877C757O28888C759O28906C766O28947C774O28947C779O28931C783O29058C791O29058C797O29080C799O29089C803O29113C805O29130C809O29148C811O29148,,
code-creation,LazyCompile,10,102248,0x3157a91d210e,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x31575b54f658,~
code-source-info,0x3157a91d210e,9,7353,7449,C0O7376C5O7389C10O7393C15O7393C21O7406C23O7424C27O7445,,
code-creation,LazyCompile,10,102352,0x3157a91d23c6,327,Module._resolveLookupPaths node:internal/modules/cjs/loader:667:38,0x31576e5207a0,~
code-source-info,0x3157a91d23c6,99,19964,21141,C0O19986C5O20003C10O20003C17O20040C25O20040C30O20084C31O20096C32O20139C39O20143C47O20177C52O20203C59O20210C66O20223C72O20223C80O20257C87O20274C93O20274C101O20308C108O20327C114O20340C120O20340C128O20374C133O20405C138O20422C145O20432C152O20439C161O20457C166O20493C171O20465C177O20519C191O20519C196O20583C202O20590C212O20609C213O20656C217O20679C223O20693C229O20864C234O20876C248O20876C253O20931C255O20948C256O20956C264O21023C272O20956C277O21049C286O21050C289O21055C294O21070C299O21055C311O21084C319O21084C324O21122C326O21139,,
tick,0x1074f4813,102511,0,0x0,3,0x1077801f0,0x3157a91d1d78,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,102550,0x3157a91d26e6,76,trySelfParentPath node:internal/modules/cjs/loader:427:27,0x31576e51ff50,~
code-source-info,0x3157a91d26e6,99,12270,12533,C0O12283C4O12296C5O12309C6O12324C12O12354C16O12363C17O12384C24O12387C29O12410C36O12413C44O12455C47O12470C52O12470C59O12478C62O12483C66O12476C69O12487C72O12508C73O12521C75O12532,,
code-creation,LazyCompile,10,102669,0x3157a91d2926,235,trySelf node:internal/modules/cjs/loader:441:17,0x31576e51ffa0,~
code-source-info,0x3157a91d2926,99,12551,13384,C0O12577C4O12594C5O12607C6O12648C9O12648C17O12625C22O12636C27O12686C31O12702C37O12725C38O12738C39O12756C47O12775C48O12788C49O12796C51O12829C55O12821C60O12841C65O12867C70O12913C82O12871C89O12929C94O12947C97O12981C102O12986C107O12947C112O12945C118O13010C119O13023C123O13041C128O13070C133O13099C138O13121C142O13099C149O13163C152O13163C159O13190C168O13070C183O13048C188O13236C200O13257C203O13263C210O13268C215O13302C222O13346C226O13308C231O13302C232O13370C234O13370,,
code-creation,LazyCompile,10,102776,0x3157a91d2bfe,129,readPackageScope node:internal/modules/cjs/loader:321:26,0x31576e51fd70,~
code-source-info,0x3157a91d2bfe,99,8919,9437,C0O8962C7O8996C10O8962C16O9008C18O9035C25O9090C28O9052C34O9100C47O9112C54O9168C61O9207C66O9211C70O9172C77O9236C78O9249C79O9268C84O9292C86O9290C90O9268C95O9302C97O9313C104O9334C110O9353C116O9370C117O9397C119O9397C124O9026C127O9422C128O9435,,
code-creation,LazyCompile,10,102905,0x3157a91d2f5e,234,readPackage node:internal/modules/cjs/loader:290:21,0x31576e51fd20,~
code-source-info,0x3157a91d2f5e,99,8102,8892,C0O8137C5O8142C13O8142C20O8200C25O8217C30O8217C36O8234C38O8262C40O8278C41O8297C46O8315C51O8315C57O8353C63O8366C72O8392C77O8402C79O8432C84O8449C91O8449C97O8475C98O8488C102O8521C107O8521C112O8559C117O8580C125O8605C133O8633C141O8664C149O8692C160O8708C165O8725C170O8725C176O8754C178O8770C190O8791C195O8798C199O8814C207O8843C213O8854C220O8865C224O8861C227O8824C231O8878C233O8878,,
code-creation,LazyCompile,10,103045,0x3157a91d3266,199,read node:internal/modules/package_json_reader:16:14,0x31576e5259a0,~
code-source-info,0x3157a91d3266,100,292,954,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O489C73O491C79O499C86O544C92O544C97O525C102O575C106O607C112O643C115O654C127O704C132O738C142O652C148O774C154O821C159O821C164O852C169O861C174O861C180O907C185O913C190O913C196O938C198O952,,
code-creation,LazyCompile,10,103115,0x3157a91d35b6,3,toNamespacedPath node:path:1266:19,0x315715868618,~
code-source-info,0x3157a91d35b6,35,38609,38669,C0O38653C2O38665,,
code-creation,LazyCompile,10,103430,0x3157a91d392e,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x31576e5205f0,~
code-source-info,0x3157a91d392e,99,14327,16931,C0O14380C5O14385C10O14385C16O14408C18O14435C26O14458C30O14478C36O14485C41O14498C42O14511C43O14536C45O14544C51O14555C57O14555C62O14553C66O14606C69O14613C76O14623C80O14637C82O14652C84O14665C85O14673C87O14709C93O14716C100O14727C103O14770C107O14777C111O14727C119O14790C121O14782C125O14812C127O14838C134O14874C137O14854C143O14943C145O14956C149O14948C154O15041C156O15046C160O15055C165O15070C172O15084C177O15089C179O15104C183O15158C186O15158C192O15198C194O15227C196O15250C197O15279C202O15284C207O15284C214O15319C216O15345C219O15345C224O15365C228O15393C229O15400C234O15427C238O15452C244O15488C249O15504C254O15504C262O15554C265O15565C272O15614C278O16228C283O16244C288O16244C296O16290C299O16301C304O16348C308O16419C312O16453C320O16478C325O16460C330O16500C342O16511C348O16569C354O16589C359O16674C363O16706C371O16731C376O16713C381O16751C396O16762C402O16818C406O16840C409O16847C416O16868C420O16886C422O16902C423O14965C428O14930C434O16916C435O16929,,
tick,0x7ff803d55227,103564,0,0x0,3,0x1077801f0,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,103614,0x3157a91d3cde,45,isAbsolute node:path:1156:13,0x315715868528,~
code-source-info,0x3157a91d3cde,35,35448,35594,C0O35461C8O35461C13O35507C19O35514C26O35532C31O35532C39O35571C41O35567C44O35590,,
code-creation,LazyCompile,10,103936,0x3157a91d3f16,85,stat node:internal/modules/cjs/loader:151:14,0x31576e51fb90,~
code-source-info,0x3157a91d3f16,99,4627,5024,C0O4642C5O4658C10O4658C17O4688C23O4733C28O4743C33O4743C39O4762C41O4788C43O4802C44O4824C49O4824C54O4856C61O4889C66O4969C71O4979C76O4979C82O5008C84O5022,,
code-creation,LazyCompile,10,104061,0x3157a91d406e,44,tryExtensions node:internal/modules/cjs/loader:400:23,0x31576e51feb0,~
code-source-info,0x3157a91d406e,99,11501,11685,C0O11536C2O11548C6O11541C11O11584C16O11600C19O11594C23O11584C29O11619C31O11641C33O11657C34O11557C39O11523C42O11670C43O11683,,
code-creation,LazyCompile,10,104129,0x3157a91d419e,50,tryFile node:internal/modules/cjs/loader:384:17,0x31576e51fe10,~
code-source-info,0x3157a91d419e,99,11077,11271,C0O11114C3O11114C8O11135C9O11142C14O11149C15O11156C16O11159C24O11184C26O11198C31O11210C36O11210C41O11231C42O11238C45O11245C49O11269,,
code-creation,LazyCompile,10,104208,0x3157a91d42e6,42,toRealPath node:internal/modules/cjs/loader:393:20,0x31576e51fe60,~
code-source-info,0x3157a91d42e6,99,11292,11404,C0O11310C5O11320C10O11333C17O11353C20O11364C28O11383C35O11320C41O11402,,
tick,0x1076a63ac,104569,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,104604,0x3157a91d4716,1036,realpathSync node:fs:2408:22,0x31572ee62988,~
script-source,77,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// When using FSReqCallback\x2C make sure to create the object only *after* all\n// parameter validation has happened\x2C so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst internalUtil = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateCallback\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateCallback(cb);\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateCallback(cb);\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateCallback(cb);\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void | never}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C internalUtil.promisify.custom\x2C {\n  value: (path) => {\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError());\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number | bigint} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C options\x2C callback)\n    let options = {};\n    if (arguments.length < 3) {\n      // This is fs.read(fd\x2C callback)\n      // buffer will be the callback\n      callback = buffer;\n    } else {\n      // This is fs.read(fd\x2C {}\x2C callback)\n      // buffer will be the options object\n      // offset is the callback\n      options = buffer;\n      callback = offset;\n    }\n\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength\x2C\n      position\n    } = options);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.read(fd\x2C buffer\x2C options)\n    const options = offset || {};\n\n    ({ offset = 0\x2C length = buffer.byteLength\x2C position } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | Object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C internalUtil.customPromisifyArgs\x2C\n                     { value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | Object} buffer\n * @param {number} [offset]\n * @param {number} [length]\n * @param {number} [position]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n  if (isArrayBufferView(buffer)) {\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C internalUtil.customPromisifyArgs\x2C {\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch { }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError();\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | Object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | Object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options\x2C {});\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\nconst emptyObj = ObjectCreate(null);\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options\x2C emptyObj);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard[base] = true;\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base] || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard[base] = true;\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks[id]) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      if (cache) cache.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard[base] = true;\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options\x2C {});\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = ObjectCreate(null);\n  const knownHard = ObjectCreate(null);\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard[base]) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard[base] = true;\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard[base]) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard[base] = true;\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks[id]) {\n        return gotTarget(null\x2C seenLinks[id]);\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options\x2C {});\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options\x2C {});\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {Object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {Object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 kb.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: Object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  promises: {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      if (promises === null)\n        promises = require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n
code-source-info,0x3157a91d4716,77,63994,67905,C0O64011C8O64041C12O64021C19O64054C25O64058C31O64080C35O64113C45O64128C51O64128C55O64147C61O64162C67O64162C74O64191C76O64199C78O64198C82O64246C86O64251C92O64253C101O64263C103O64292C105O64317C106O64343C115O64343C120O64383C129O64383C134O64422C137O64469C139O64544C141O64639C143O64715C145O64749C151O64766C157O64796C162O64878C168O64911C176O64919C183O64931C189O64939C197O64945C201O64956C207O64956C223O64939C228O65008C234O65008C238O65041C239O65057C243O65197C247O65193C252O65252C258O65252C264O65274C267O65298C269O65309C274O65338C280O65338C287O65374C289O65385C296O65397C298O65413C302O65435C309O65462C311O65473C317O65509C328O65473C340O65521C342O65539C355O65539C360O65537C364O65583C366O65596C370O65669C372O65682C384O65697C390O65699C402O65709C407O65727C413O65742C417O65750C425O65762C429O65731C442O65795C446O65803C454O65815C458O65784C465O65836C467O65857C469O65882C471O65928C478O65933C484O65935C493O65950C495O65983C502O66165C508O66176C514O66176C520O66218C528O66226C535O66254C541O66262C559O66262C565O66307C571O66307C575O66343C581O66366C585O66348C592O66386C593O66402C597O66418C604O66423C610O66425C619O66450C621O66604C624O66620C627O66630C633O66668C640O66697C649O66668C656O66727C664O66756C673O66727C680O66774C694O66789C700O66804C702O66817C707O66835C709O66857C714O66887C718O66934C726O66942C733O66958C739O66966C757O66966C762O67013C768O67013C772O67050C778O67071C796O67071C803O67126C809O67126C813O67169C819O67195C825O67195C832O67233C836O67250C842O67250C848O67281C854O67297C856O67311C860O67377C866O67392C874O67414C878O67414C885O67392C893O67473C899O67490C905O67522C910O67608C918O67635C923O67663C931O67671C938O67685C944O67693C952O67699C956O67710C962O67710C978O67693C983O67764C989O67764C993O67799C994O67815C998O65182C1004O67836C1011O67841C1017O67843C1026O67863C1030O67870C1035O67903,,
tick,0x7ff803e80ea8,112437,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80ec4,112479,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80d85,112494,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e4b9ce,112507,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80cfd,112519,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803d61c80,112531,0,0x0,3,0x1077801f0,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x1074ec185,112577,0,0x0,3,0x1077801f0,0x3157a91d4722,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,112627,0x3157a91dadb6,123,getOptions node:internal/fs/utils:314:20,0x31572ee6ad30,~
script-source,78,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsInteger\x2C\n  MathMin\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\n  }\x2C\n  hideStackFrames\x2C\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isUint8Array\x2C\n  isDate\x2C\n  isBigUint64Array\n} = require('internal/util/types');\nconst { once } = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats) {\n    super(name\x2C null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\n    return new DirentFromStats(name\x2C stats);\n  } else {\n    return new Dirent(name\x2C type);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions) {\n  if (options === null || options === undefined ||\n      typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return StringPrototypeReplace(path\x2C /\\//g\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() to the timestamp.\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\nfunction dateFromMs(ms) {\n  return new Date(Number(ms) + 0.5);\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigUint64Array} stats\n * @param {number} offset\n * @returns\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigUint64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\n  );\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C 'position');\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE('position'\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\n                                   ['integer'\x2C 'bigint']\x2C\n                                   position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n};\n
code-source-info,0x3157a91dadb6,78,7218,7841,C0O7248C14O7340C16O7362C17O7370C23O7409C29O7453C31O7477C35O7492C42O7527C48O7566C66O7572C71O7566C72O7659C79O7668C84O7686C87O7709C92O7686C96O7735C102O7763C107O7791C115O7763C120O7824C122O7839,,
tick,0x107046480,115081,0,0x0,3,0x1077801f0,0x3157a91d4722,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803df1e69,115108,0,0x0,3,0x1077801f0,0x3157a91d4722,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,115136,0x3157a91dcd0e,48,assertEncoding node:internal/fs/utils:151:24,0x31572ee6a738,~
code-source-info,0x3157a91dcd0e,78,3527,3704,C0O3542C6O3559C9O3566C14O3566C21O3609C24O3636C40O3642C45O3636C47O3703,,
code-creation,LazyCompile,10,115277,0x3157a91dce26,20,toPathIfFileURL node:internal/url:1496:25,0x31571585b160,~
script-source,33,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototypeBind\x2C\n  Int8Array\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateCallback\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII\x2C\n  domainToUnicode: _domainToUnicode\x2C\n  encodeAuth\x2C\n  parse\x2C\n  setURLConstructor\x2C\n  URL_FLAGS_CANNOT_BE_BASE\x2C\n  URL_FLAGS_HAS_FRAGMENT\x2C\n  URL_FLAGS_HAS_HOST\x2C\n  URL_FLAGS_HAS_PASSWORD\x2C\n  URL_FLAGS_HAS_PATH\x2C\n  URL_FLAGS_HAS_QUERY\x2C\n  URL_FLAGS_HAS_USERNAME\x2C\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\n  URL_FLAGS_SPECIAL\x2C\n  kFragment\x2C\n  kHost\x2C\n  kHostname\x2C\n  kPathStart\x2C\n  kPort\x2C\n  kQuery\x2C\n  kSchemeStart\n} = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\n          ArrayPrototypePush(pairs\x2C convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n            this[searchParams].push(typedKey\x2C typedValue);\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this\x2C init);\n    }\n\n    // "associated url object"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    update(this[context]\x2C this);\n  }\n\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context]\x2C this);\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateCallback(callback);\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: { enumerable: true }\x2C\n  delete: { enumerable: true }\x2C\n  get: { enumerable: true }\x2C\n  getAll: { enumerable: true }\x2C\n  has: { enumerable: true }\x2C\n  set: { enumerable: true }\x2C\n  sort: { enumerable: true }\x2C\n  entries: { enumerable: true }\x2C\n  forEach: { enumerable: true }\x2C\n  keys: { enumerable: true }\x2C\n  values: { enumerable: true }\x2C\n  toString: { enumerable: true }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams]\x2C query);\n}\n\nfunction onParseError(flags\x2C input) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\n}\n\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].fragment = fragment;\n}\n\nclass URL {\n  constructor(input\x2C base = undefined) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host\x2C scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  [kFormat](options) {\n    if (options)\n      validateObject(options\x2C 'options');\n\n    options = {\n      fragment: true\x2C\n      unicode: false\x2C\n      search: true\x2C\n      auth: true\x2C\n      ...options\n    };\n    const ctx = this[context];\n    // https://url.spec.whatwg.org/#url-serializing\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += '//';\n      const has_username = ctx.username !== '';\n      const has_password = ctx.password !== '';\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += '@';\n      }\n      ret += options.unicode ?\n        domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\n        ret += '/.';\n      }\n      if (ctx.path.length) {\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  toString() {\n    return this[kFormat]({});\n  }\n\n  get href() {\n    return this[kFormat]({});\n  }\n\n  set href(input) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\n  }\n\n  // readonly\n  get origin() {\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case 'blob:':\n        if (ctx.path.length > 0) {\n          try {\n            return (new URL(ctx.path[0])).origin;\n          } catch {\n            // Fall through... do nothing\n          }\n        }\n        return kOpaqueOrigin;\n      case 'ftp:':\n      case 'http:':\n      case 'https:':\n      case 'ws:':\n      case 'wss:':\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n\n  get protocol() {\n    return this[context].scheme;\n  }\n\n  set protocol(scheme) {\n    // toUSVString is not needed.\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\n  }\n\n  get username() {\n    return this[context].username;\n  }\n\n  set username(username) {\n    // toUSVString is not needed.\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === '') {\n      ctx.username = '';\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n\n  get password() {\n    return this[context].password;\n  }\n\n  set password(password) {\n    // toUSVString is not needed.\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === '') {\n      ctx.password = '';\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n\n  get host() {\n    const ctx = this[context];\n    let ret = ctx.host || '';\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n\n  set host(host) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\n  }\n\n  get hostname() {\n    return this[context].host || '';\n  }\n\n  set hostname(host) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\n  }\n\n  get port() {\n    const port = this[context].port;\n    return port === null ? '' : String(port);\n  }\n\n  set port(port) {\n    // toUSVString is not needed.\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === '') {\n      ctx.port = null;\n      return;\n    }\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\n  }\n\n  get pathname() {\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return '';\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\n  }\n\n  set pathname(path) {\n    // toUSVString is not needed.\n    path = `${path}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\n          onParsePathComplete.bind(this));\n  }\n\n  get search() {\n    const { query } = this[context];\n    if (query === null || query === '')\n      return '';\n    return `?${query}`;\n  }\n\n  set search(search) {\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === '') {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\n      ctx.query = '';\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\n      }\n    }\n    initSearchParams(this[searchParams]\x2C search);\n  }\n\n  // readonly\n  get searchParams() {\n    return this[searchParams];\n  }\n\n  get hash() {\n    const { fragment } = this[context];\n    if (fragment === null || fragment === '')\n      return '';\n    return `#${fragment}`;\n  }\n\n  set hash(hash) {\n    const ctx = this[context];\n    // toUSVString is not needed.\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\n    ctx.fragment = '';\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\n  }\n\n  toJSON() {\n    return this[kFormat]({});\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    // Yes\x2C lazy loading is annoying but because of circular\n    // references between the url\x2C internal/blob\x2C and buffer\n    // modules\x2C lazy loading here makes sure that things work.\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [kFormat]: { configurable: false\x2C writable: false }\x2C\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URL' }\x2C\n  toString: { enumerable: true }\x2C\n  href: { enumerable: true }\x2C\n  origin: { enumerable: true }\x2C\n  protocol: { enumerable: true }\x2C\n  username: { enumerable: true }\x2C\n  password: { enumerable: true }\x2C\n  host: { enumerable: true }\x2C\n  hostname: { enumerable: true }\x2C\n  port: { enumerable: true }\x2C\n  pathname: { enumerable: true }\x2C\n  search: { enumerable: true }\x2C\n  searchParams: { enumerable: true }\x2C\n  hash: { enumerable: true }\x2C\n  toJSON: { enumerable: true }\x2C\n});\n\nfunction update(url\x2C params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url\x2C init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\n    );\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol\x2C\n    hostname: typeof url.hostname === 'string' &&\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\n      url.hostname\x2C\n    hash: url.hash\x2C\n    search: url.search\x2C\n    pathname: url.pathname\x2C\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params\x2C query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  isURLInstance\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  formatSymbol: kFormat\x2C\n  searchParamsSymbol: searchParams\x2C\n  encodeStr\n};\n
code-source-info,0x3157a91dce26,33,41461,41582,C0O41481C3O41486C9O41520C11O41541C12O41544C15O41551C19O41580,,
tick,0x7ff803d55504,119236,0,0x0,3,0x1077801f0,0x3157a91d472f,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x10751dd90,119269,0,0x0,3,0x1077801f0,0x3157a91d472f,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80e5b,119286,0,0x0,3,0x1077801f0,0x3157a91d472f,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,119311,0x3157a91dff56,17,isURLInstance node:internal/url:1492:23,0x31571585b110,~
code-source-info,0x3157a91dff56,33,41338,41435,C0O41358C3O41379C6O41404C12O41426C16O41433,,
code-creation,LazyCompile,10,119430,0x3157a91e00b6,81, node:internal/fs/utils:668:38,0x31572ee6b758,~
code-source-info,0x3157a91e00b6,78,18141,18411,C14O18174C22O18207C25O18207C31O18233C36O18264C49O18239C54O18233C55O18329C68O18329C74O18366C76O18395C78O18395C80O18410,,
code-creation,LazyCompile,10,119515,0x3157a91e02c6,110, node:internal/fs/utils:357:35,0x31572ee6add0,~
code-source-info,0x3157a91e02c6,78,8569,9158,C16O8633C21O8686C26O8686C31O8780C37O8803C41O8831C45O8848C51O8848C60O8899C64O8920C69O8920C76O8965C77O8972C78O8992C94O8992C100O9106C104O9128C106O9128C107O9145C109O9156,,
code-creation,LazyCompile,10,119578,0x3157a91e043e,16,isUint8Array node:internal/util/types:13:22,0x315735256d90,~
script-source,15,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\n  }\x2C\n  isCryptoKey: {\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\n  }\n});\n
code-source-info,0x3157a91e043e,15,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,119908,0x3157a91e08b6,61,splitRoot node:fs:2362:33,0x31572ee62898,~
code-source-info,0x3157a91e08b6,77,62796,62988,C0O62821C2O62832C6O62826C11O62853C16O62857C24O62895C26O62891C31O62923C44O62930C49O62962C50O62842C55O62808C58O62973C60O62984,,
tick,0x1076700a1,119981,0,0x0,0,0x1074ad970,0x3157a91e08b8,0x3157a91d47ad,0x3157a91d4309,0x3157a91d41cb,0x3157a91d4085,0x3157a91d3a84,0x3157a91d1ddf,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,120025,0x3157a91e09ee,20,nextPart node:fs:2395:31,0x31572ee62938,~
code-source-info,0x3157a91e09ee,77,63703,63761,C0O63716C14O63723C19O63757,,
code-creation,LazyCompile,10,120172,0x3157a91e0bee,63,handleErrorFromBinding node:internal/fs/utils:340:32,0x31572ee6ad80,~
code-source-info,0x3157a91e0bee,78,7930,8428,C0O7948C6O8011C11O8011C16O8033C24O8033C29O8090C31O8090C32O8115C38O8343C43O8370C51O8343C56O8416C60O8406C62O8427,,
code-creation,LazyCompile,10,120251,0x3157a91e0d3e,34,isFileType node:fs:205:20,0x31572ee60528,~
code-source-info,0x3157a91e0d3e,77,5285,5526,C0O5419C2O5424C6O5431C10O5465C15O5472C20O5488C22O5503C24O5501C30O5511C33O5524,,
code-creation,LazyCompile,10,120533,0x3157a91e127e,72,encodeRealpathResult node:fs:2371:30,0x31572ee628e8,~
code-source-info,0x3157a91e127e,77,63022,63280,C0O63044C4O63069C10O63089C17O63098C22O63114C24O63128C25O63148C30O63155C35O63155C41O63183C48O63192C53O63212C55O63228C56O63251C61O63268C66O63251C71O63278,,
code-creation,LazyCompile,10,120642,0x3157a91e140e,62,loadNativeModule node:internal/modules/cjs/helpers:44:26,0x31576e51a5b8,~
code-source-info,0x3157a91e140e,98,1151,1431,C0O1187C5O1200C10O1204C15O1204C21O1221C26O1228C35O1258C43O1258C48O1384C53O1384C57O1414C59O1425C61O1430,,
code-creation,LazyCompile,10,120763,0x3157a91e1d5e,246,Module.load node:internal/modules/cjs/loader:969:33,0x31576e5209e8,~
code-source-info,0x3157a91e1d5e,99,30265,31078,C0O30280C8O30326C16O30280C21O30334C26O30347C32O30334C36O30358C38O30372C42O30386C45O30406C52O30423C55O30428C60O30428C66O30406C71O30397C75O30469C78O30469C83O30546C91O30550C101O30603C106O30614C112O30628C124O30634C129O30628C130O30674C133O30681C140O30692C144O30703C150O30723C151O30735C155O30764C160O30773C165O30875C170O30910C175O30921C187O30961C192O30968C197O30968C204O30982C206O30980C211O31014C216O31023C221O31023C228O31048C233O31057C238O31057C245O31077,,
code-creation,Function,11,120902,0x10f8c52a0,1304,dirname node:path:1275:10,0x315715868668,^
code-source-info,0x10f8c52a0,35,38742,39411,,,
code-creation,Function,11,120960,0x10f8c5820,1452,Module._nodeModulePaths node:internal/modules/cjs/loader:629:37,0x31576e520710,^
code-source-info,0x10f8c5820,99,18791,19922,,,
code-creation,Function,11,120990,0x10f8c5e40,44,toNamespacedPath node:path:1266:19,0x315715868618,^
code-source-info,0x10f8c5e40,35,38609,38669,,,
code-creation,Function,11,121015,0x10f8c5ee0,172,nextPart node:fs:2395:31,0x31572ee62938,^
code-source-info,0x10f8c5ee0,77,63703,63761,,,
code-creation,Function,11,121054,0x10f8c6000,320,isFileType node:fs:205:20,0x31572ee60528,^
code-source-info,0x10f8c6000,77,5285,5526,,,
code-creation,LazyCompile,10,121174,0x3157a91e239e,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:413:40,0x31576e51ff00,~
code-source-info,0x3157a91e239e,99,11813,12242,C0O11841C5O11846C10O11846C16O11872C18O11896C20O11922C22O11990C36O11943C44O11990C49O12004C51O12023C55O12032C56O12042C61O12049C63O12096C68O12115C74O12154C77O12165C84O12176C89O12196C91O12220C92O11927C95O12227C97O12240,,
tick,0x1072a5ca3,121284,0,0x0,2,0x1077801f0,0x3157a91e23a8,0x3157a91e1dac,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,121349,0x3157a91e257e,353,basename node:path:1306:11,0x3157158686b8,~
code-source-info,0x3157a91e257e,35,39512,41904,C0O39530C4O39559C12O39559C17O39591C25O39591C30O39638C32O39655C35O39682C37O39693C41O39722C47O39729C52O39740C57O39755C61O39747C66O39771C68O39779C73O39797C75O39807C76O39831C80O39838C84O39872C87O39900C91O39907C95O39914C96O39914C101O39948C106O39948C112O39992C114O40005C116O40001C121O40175C125O40208C127O40218C131O40235C135O40281C137O40302C142O40468C144O40502C146O40523C150O40550C151O40561C156O40632C158O40645C161O40645C166O40641C171O40701C178O40714C183O40850C190O41013C193O41040C198O39922C203O39882C206O41115C208O41125C213O41142C220O41177C222O41185C227O41212C232O41226C246O41233C251O41272C252O41301C256O41308C260O41315C261O41315C266O41334C271O41338C279O41377C281O41373C286O41541C290O41572C292O41582C296O41597C300O41627C302O41635C307O41755C309O41785C311O41793C315O41323C320O41283C323O41817C325O41825C330O41839C332O41849C333O41854C347O41861C352O41900,,
code-creation,LazyCompile,10,121551,0x3157a91e2a3e,485,Module._extensions..js node:internal/modules/cjs/loader:1110:37,0x31576e520b88,~
code-source-info,0x3157a91e2a3e,99,34668,36368,C0O34767C5O34781C10O34781C16O34800C18O34811C25O34821C34O34854C39O34866C40O34880C46O34908C51O34921C60O34921C67O34959C76O34963C83O35023C86O35023C91O35112C96O35119C103O35125C113O35132C118O35169C123O35187C128O35187C134O35225C139O35231C147O35273C152O35278C157O35290C167O35278C174O35335C179O35335C184O35376C203O35376C209O35547C212O35558C219O35564C224O35592C229O35630C235O35648C244O35648C254O35643C257O35709C261O35755C268O35789C271O35814C279O35821C283O35863C293O35821C300O35789C314O35755C321O35891C325O35948C335O35948C345O35917C352O35926C359O36011C365O36023C367O36058C376O36058C384O36104C387O36098C391O36136C403O36153C416O36162C429O36189C438O36220C443O36189C459O36243C464O36243C469O36308C471O36308C472O36338C477O36338C484O36367,,
code-creation,LazyCompile,10,121748,0x3157a91e2e9e,376,readFileSync node:fs:450:22,0x31572ee609e0,~
code-source-info,0x3157a91e2e9e,77,11355,12732,C0O11375C5O11396C10O11385C17O11440C22O11440C27O11494C35O11512C38O11515C43O11538C56O11515C62O11569C65O11569C71O11611C76O11629C79O11611C88O11645C95O11666C97O11675C99O11721C101O11766C102O11775C107O11788C112O11817C124O11826C130O11874C132O11888C133O11897C138O11921C143O11977C159O11933C165O11991C167O11998C174O12038C175O12032C182O12045C187O11910C192O12169C197O12185C207O12185C213O12210C232O12222C238O12272C239O12286C244O12303C249O12338C256O12338C263O12303C268O12374C270O12381C277O12415C278O12415C283O12069C286O12430C290O12449C295O12452C300O12452C305O12470C306O12479C311O12541C316O12557C321O12557C330O12588C332O12596C337O12626C344O12626C351O12660C357O12686C362O12703C367O12686C373O12716C375O12730,,
code-creation,LazyCompile,10,121883,0x3157a91e31be,30,isEncoding node:buffer:529:40,0x315735265138,~
code-source-info,0x3157a91e31be,18,14774,14906,C0O14789C6O14837C12O14844C20O14862C23O14862C28O14890C29O14904,,
code-creation,LazyCompile,10,121941,0x3157a91e32c6,30,normalizeEncoding node:internal/util:160:27,0x31575b569f70,~
code-source-info,0x3157a91e32c6,12,4206,4311,C0O4216C7O4239C14O4257C19O4270C21O4284C22O4287C25O4294C29O4309,,
code-creation,LazyCompile,10,121988,0x3157a91e33ae,9,isUint32 node:internal/validators:39:18,0x315735259d48,~
code-source-info,0x3157a91e33ae,17,777,822,C0O789C2O813C5O802C8O820,,
code-creation,LazyCompile,10,122061,0x3157a91e3506,113,openSync node:fs:576:18,0x31572ee60bc8,~
code-source-info,0x3157a91e3506,77,14426,14805,C0O14450C5O14457C11O14503C16O14503C21O14527C37O14534C44O14585C51O14587C58O14612C63O14620C70O14625C73O14636C78O14636C95O14620C101O14758C106O14758C110O14789C112O14803,,
code-creation,LazyCompile,10,122124,0x3157a91e3686,37, node:internal/fs/utils:680:42,0x31572ee6b7a8,~
code-source-info,0x3157a91e3686,78,18456,18591,C14O18511C19O18511C24O18545C29O18545C34O18577C36O18589,,
code-creation,LazyCompile,10,122232,0x3157a91e3a5e,515,stringToFlags node:internal/fs/utils:555:23,0x31572ee6b5c8,~
code-source-info,0x3157a91e3a5e,78,15047,16281,C14O15075C20O15112C25O15112C30O15144C32O15157C33O15165C38O15190C42O15206C43O15214C202O15246C206O15262C207O15312C214O15330C216O15328C219O15337C220O15354C224O15368C225O15420C232O15436C234O15434C237O15443C238O15460C245O15477C247O15475C253O15487C255O15485C258O15496C259O15546C266O15563C268O15561C274O15573C276O15571C282O15584C284O15582C287O15591C288O15609C295O15626C297O15624C303O15636C305O15634C308O15643C309O15693C316O15710C318O15708C324O15720C326O15718C332O15729C334O15727C337O15736C338O15753C345O15771C347O15769C353O15781C355O15779C358O15790C359O15840C366O15858C368O15856C374O15868C376O15866C382O15879C384O15877C387O15886C388O15936C395O15954C397O15952C403O15964C405O15962C411O15975C413O15973C416O15982C417O16000C424O16018C426O16016C432O16028C434O16026C437O16035C438O16085C445O16103C447O16101C453O16113C455O16111C461O16122C463O16120C466O16129C467O16179C474O16197C476O16195C482O16207C484O16205C490O16216C492O16214C495O16223C496O16231C509O16237C514O16231,,
code-creation,LazyCompile,10,122360,0x3157a91e3e4e,97,parseFileMode node:internal/validators:58:23,0x315735259d98,~
code-source-info,0x3157a91e3e4e,17,1468,1764,C0O1491C11O1508C17O1545C24O1570C27O1550C34O1596C41O1641C52O1602C57O1596C58O1662C66O1670C73O1703C89O1703C94O1749C96O1762,,
code-creation,LazyCompile,10,122442,0x3157a91e401e,206, node:internal/validators:83:3,0x315735259e58,~
code-source-info,0x3157a91e401e,17,2236,2817,C36O2377C39O2382C45O2406C51O2447C67O2453C72O2447C73O2516C78O2521C84O2555C100O2561C105O2555C106O2624C116O2663C129O2676C142O2630C147O2624C148O2701C150O2711C157O2726C162O2741C172O2780C185O2793C198O2747C203O2741C205O2816,,
code-creation,LazyCompile,10,122504,0x3157a91e41e6,9,isInt32 node:internal/validators:35:17,0x315735259990,~
code-source-info,0x3157a91e41e6,17,715,758,C0O727C2O751C5O740C8O756,,
tick,0x1075e3842,122598,0,0x0,0,0x10778a010,0x3157a91e3532,0x3157a91e2ed6,0x3157a91e2a7a,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,122647,0x3157a91e42ee,66,tryStatSync node:fs:404:21,0x31572ee608f0,~
code-source-info,0x3157a91e42ee,77,10330,10540,C0O10361C2O10381C7O10389C22O10389C28O10433C36O10457C38O10473C43O10476C48O10476C53O10495C58O10501C62O10495C63O10525C65O10538,,
code-creation,LazyCompile,10,122746,0x3157a91e4466,96,tryCreateBuffer node:fs:414:25,0x31572ee60940,~
code-source-info,0x3157a91e4466,77,10566,10853,C0O10603C2O10615C7O10635C9O10646C11O10644C16O10668C23O10674C28O10668C29O10717C34O10733C39O10733C45O10756C57O10762C58O10789C65O10803C67O10813C72O10816C77O10816C93O10837C95O10851,,
code-creation,LazyCompile,10,122803,0x3157a91e45be,17,allocUnsafe node:buffer:372:42,0x315735264cb0,~
code-source-info,0x3157a91e45be,18,10871,10926,C0O10882C5O10882C9O10902C12O10909C16O10924,,
code-creation,LazyCompile,10,122855,0x3157a91e46c6,54, node:buffer:348:36,0x315735264bf8,~
code-source-info,0x3157a91e46c6,18,10169,10324,C0O10183C8O10183C13O10215C14O10226C21O10242C23O10239C28O10261C33O10293C46O10267C51O10261C53O10323,,
code-creation,LazyCompile,10,122903,0x3157a91e47ee,30,validateNumber node:internal/validators:122:24,0x315735259f98,~
code-source-info,0x3157a91e47ee,17,3532,3641,C0O3550C6O3585C22O3591C27O3585C29O3640,,
code-creation,LazyCompile,10,122966,0x3157a91e4906,119,allocate node:buffer:397:18,0x315735264e00,~
code-source-info,0x3157a91e4906,18,11573,11888,C0O11584C1O11593C6O11605C11O11612C16O11629C17O11636C20O11655C24O11664C27O11645C32O11678C34O11690C39O11701C41O11699C44O11687C49O11720C52O11720C55O11748C62O11763C67O11774C75O11748C81O11797C88O11811C94O11808C100O11821C103O11821C106O11838C108O11847C109O11854C114O11861C118O11886,,
code-creation,LazyCompile,10,123049,0x3157a91e4ac6,86,tryReadSync node:fs:429:21,0x31572ee60990,~
code-source-info,0x3157a91e4ac6,77,10875,11110,C0O10924C2O10936C7O10959C12O10974C29O10974C35O11010C47O11016C48O11043C55O11057C57O11067C62O11070C67O11070C83O11091C85O11108,,
code-creation,LazyCompile,10,123145,0x3157a91e4cae,239,readSync node:fs:684:18,0x31572ee60c98,~
code-source-info,0x3157a91e4cae,77,17128,18059,C0O17128C2O17171C7O17176C13O17199C18O17199C22O17240C29O17247C34O17318C40O17340C52O17352C58O17368C64O17380C70O17410C75O17436C80O17463C93O17463C98O17508C105O17524C106O17535C111O17548C112O17557C113O17576C119O17587C124O17600C140O17606C145O17600C146O17728C151O17776C162O17728C167O17792C172O17818C176O17836C184O17836C189O17891C191O17912C196O17920C221O17920C227O18012C232O18012C236O18043C238O18057,,
code-creation,LazyCompile,10,123222,0x3157a91e4efe,52, node:internal/fs/utils:686:40,0x31572ee6b7f8,~
code-source-info,0x3157a91e4efe,78,18634,18755,C14O18663C22O18667C29O18691C30O18700C31O18708C44O18708C49O18743C51O18753,,
code-creation,LazyCompile,10,123287,0x3157a91e506e,51, node:internal/validators:190:40,0x31573525a1c0,~
code-source-info,0x3157a91e506e,17,5662,5892,C14O5695C19O5700C25O5733C30O5764C43O5739C48O5733C50O5891,,
code-creation,LazyCompile,10,123353,0x3157a91e51c6,151, node:internal/validators:72:3,0x315735259e08,~
code-source-info,0x3157a91e51c6,17,1809,2190,C12O1829C25O1859C32O1892C38O1929C54O1935C59O1929C60O1988C65O1993C71O2023C87O2029C92O2023C93O2082C95O2092C102O2107C107O2120C117O2159C130O2172C143O2126C148O2120C150O2189,,
code-creation,LazyCompile,10,123430,0x3157a91e53ce,103, node:internal/fs/utils:636:3,0x31572ee6b6b8,~
code-source-info,0x3157a91e53ce,78,17258,17637,C0O17298C1O17309C6O17322C22O17328C27O17322C28O17386C29O17397C34O17410C50O17416C55O17410C56O17474C58O17485C64O17494C69O17518C82O17607C95O17524C100O17518C102O17636,,
code-creation,LazyCompile,10,123515,0x3157a91e56d6,151, node:internal/fs/utils:886:42,0x31572ee6bb18,~
code-source-info,0x3157a91e56d6,78,23965,24523,C0O23989C6O24029C14O24029C21O24077C27O24117C32O24140C35O24135C37O24132C47O24166C53O24173C56O24160C61O24188C77O24271C80O24266C98O24291C104O24298C117O24194C122O24188C125O24371C143O24377C148O24371C150O24522,,
code-creation,LazyCompile,10,123603,0x3157a91e588e,47,closeSync node:fs:526:19,0x31572ee60af0,~
code-source-info,0x3157a91e588e,77,13295,13417,C0O13304C5O13309C11O13344C13O13350C18O13358C31O13358C36O13387C41O13387C46O13416,,
tick,0x7ff803e4b9ce,123692,0,0x0,3,0x1077801f0,0x3157a91e2fca,0x3157a91e2a7a,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,123737,0x3157a91e59c6,162,toString node:buffer:782:46,0x315735266b38,~
code-source-info,0x3157a91e59c6,18,23264,23826,C0O23264C2O23305C8O23312C13O23337C20O23355C25O23337C31O23363C32O23388C37O23399C38O23409C43O23419C48O23437C50O23447C55O23459C57O23469C58O23481C65O23496C71O23525C76O23536C83O23558C90O23571C92O23579C97O23593C99O23603C100O23607C104O23651C109O23651C115O23673C116O23689C119O23689C124O23717C126O23744C133O23750C138O23744C139O23800C156O23800C161O23824,,
code-creation,LazyCompile,10,123866,0x3157a91e5c86,499,getEncodingOps node:buffer:678:24,0x315735266990,~
code-source-info,0x3157a91e5c86,18,19931,21732,C0O19946C10O19981C62O20009C64O20022C69O20034C74O20053C78O20058C79O20065C81O20078C86O20090C91O20109C95O20114C96O20121C101O20132C107O20176C109O20189C114O20201C119O20220C123O20225C124O20232C126O20245C131O20257C136O20276C140O20281C141O20288C143O20313C145O20326C150O20339C155O20358C159O20363C160O20370C162O20383C167O20396C172O20415C176O20421C177O20428C179O20441C184O20454C189O20473C193O20478C194O20485C199O20496C205O20540C207O20553C212O20566C217O20585C221O20590C222O20597C224O20610C229O20623C234O20642C238O20648C239O20655C241O20668C246O20681C251O20700C255O20705C256O20712C258O20737C260O20750C267O20777C270O20777C277O20814C282O20837C287O20856C291O20864C292O20871C294O20896C296O20909C303O20937C306O20937C313O20974C318O20998C323O21017C327O21025C328O21032C330O21057C332O21070C339O21095C344O21117C349O21136C353O21143C354O21150C356O21163C361O21177C366O21196C370O21203C371O21210C376O21221C382O21265C384O21278C391O21303C396O21325C401O21344C405O21351C406O21358C408O21371C413O21385C418O21404C422O21411C423O21418C425O21443C427O21456C434O21469C437O21469C444O21506C449O21525C454O21544C458O21548C459O21555C461O21580C463O21593C470O21622C473O21622C480O21659C485O21684C490O21703C494O21713C495O21720C498O21731,,
code-creation,LazyCompile,10,123991,0x3157a91e606e,12,slice node:buffer:593:12,0x315735265358,~
code-source-info,0x3157a91e606e,18,16602,16648,C0O16627C5O16627C11O16648,,
code-creation,LazyCompile,10,124376,0x3157a91e6bae,499,Module._compile node:internal/modules/cjs/loader:1055:37,0x31576e520af8,~
code-source-info,0x3157a91e6bae,99,32760,34601,C0O32788C2O32805C4O32818C11O32828C20O32846C25O32858C30O32887C35O32906C40O32915C45O32915C51O32951C56O32958C61O32967C66O32967C72O33011C86O33011C91O33083C103O33083C109O33144C111O33152C119O33156C128O33199C135O33220C141O33314C144O33326C151O33330C159O33361C162O33383C170O33408C177O33412C185O33383C193O33374C203O33605C210O33612C215O33625C221O33625C226O33612C231O33605C237O33689C242O33702C248O33769C256O33790C262O33821C264O33817C269O33843C273O33858C279O33872C285O33891C290O33919C295O33969C300O33974C305O33974C311O34011C316O34011C322O34055C324O34086C329O34115C330O34141C333O34149C339O34166C344O34173C349O34185C357O34183C363O34202C367O34230C388O34239C396O34375C401O34414C410O34452C419O34461C428O34470C437O34478C446O34488C459O34384C465O34505C469O34531C475O34541C481O34558C486O34565C490O34575C496O34585C498O34599,,
code-creation,LazyCompile,10,124544,0x3157a91e711e,229,maybeCacheSourceMap node:internal/source_map/source_map_cache:74:29,0x31576e517720,~
code-source-info,0x3157a91e711e,96,2239,3273,C0O2308C3O2308C7O2334C10O2348C15O2352C23O2372C25O2392C26O2399C30O2412C35O2423C44O2421C54O2564C64O2574C69O2564C73O2586C74O2593C75O2614C80O2640C85O2614C91O2717C93O2747C96O2775C101O2782C106O2747C112O2817C117O2837C122O2844C127O2866C131O2897C136O2915C141O2919C148O2948C155O2979C165O3009C171O3023C175O2915C183O3149C188O3167C193O3171C201O3204C211O3234C217O3248C221O3167C228O3272,,
code-creation,LazyCompile,10,124625,0x3157a91e7b7e,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:43:30,0x31576e517680,~
code-source-info,0x3157a91e7b7e,96,1418,1563,C0O1425C6O1468C11O1489C17O1489C22O1468C26O1536C30O1561,,
code-creation,LazyCompile,10,124713,0x3157a91e7cf6,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:50:30,0x31576e5176d0,~
code-source-info,0x3157a91e7cf6,96,1594,2209,C0O1604C8O1604C13O1709C19O1709C24O1648C29O1674C34O1738C38O1767C42O1822C48O1822C53O1796C58O1878C64O1936C70O2095C76O2095C81O2068C86O2127C90O2183C92O2201C99O2208,,
code-creation,LazyCompile,10,124774,0x3157a91e7e6e,30,validateBoolean node:internal/validators:138:25,0x31573525a058,~
code-source-info,0x3157a91e7e6e,17,4042,4153,C0O4060C6O4096C22O4102C27O4096C29O4152,,
code-creation,LazyCompile,10,124891,0x3157a91e8266,165,wrapSafe node:internal/modules/cjs/loader:1017:18,0x31576e520180,~
code-source-info,0x3157a91e8266,99,31692,32552,C0O31692C9O31735C17O31770C22O31777C27O31777C33O31796C40O31806C45O31823C52O31840C56O31929C64O31806C70O32084C74O32101C81O32111C86O32127C98O32242C102O32258C113O32111C118O32427C130O32450C135O32462C142O32473C147O32502C157O32502C162O32536C164O32536,,
tick,0x7ff803e80ec4,124976,0,0x0,3,0x1077801f0,0x3157a91e6c15,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,125117,0x3157a91e8a6e,472,compileFunction node:vm:308:25,0x31572ee7cfb8,~
script-source,85,node:vm,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeUnshift\x2C\n  Symbol\x2C\n  PromiseReject\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  ContextifyScript\x2C\n  MicrotaskQueue\x2C\n  makeContext\x2C\n  isContext: _isContext\x2C\n  constants\x2C\n  compileFunction: _compileFunction\x2C\n  measureMemory: _measureMemory\x2C\n} = internalBinding('contextify');\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n} = require('internal/errors').codes;\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  kVmBreakFirstLineSymbol\x2C\n  emitExperimentalWarning\x2C\n} = require('internal/util');\nconst kParsingContext = Symbol('script parsing context');\n\nclass Script extends ContextifyScript {\n  constructor(code\x2C options = {}) {\n    code = `${code}`;\n    if (typeof options === 'string') {\n      options = { filename: options };\n    } else {\n      validateObject(options\x2C 'options');\n    }\n\n    const {\n      filename = 'evalmachine.<anonymous>'\x2C\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      cachedData\x2C\n      produceCachedData = false\x2C\n      importModuleDynamically\x2C\n      [kParsingContext]: parsingContext\x2C\n    } = options;\n\n    validateString(filename\x2C 'options.filename');\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n    validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\n    // protects against that.\n    try { // eslint-disable-line no-useless-catch\n      super(code\x2C\n            filename\x2C\n            lineOffset\x2C\n            columnOffset\x2C\n            cachedData\x2C\n            produceCachedData\x2C\n            parsingContext);\n    } catch (e) {\n      throw e; /* node-do-not-add-exception-line */\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C\n                       'options.importModuleDynamically');\n      const { importModuleDynamicallyWrap } =\n        require('internal/vm/module');\n      const { callbackMap } = internalBinding('module_wrap');\n      callbackMap.set(this\x2C {\n        importModuleDynamically:\n          importModuleDynamicallyWrap(importModuleDynamically)\x2C\n      });\n    }\n  }\n\n  runInThisContext(options) {\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInThisContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInThisContext\x2C this\x2C args);\n  }\n\n  runInContext(contextifiedObject\x2C options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\n    ArrayPrototypeUnshift(args\x2C contextifiedObject);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInContext\x2C this\x2C args);\n  }\n\n  runInNewContext(contextObject\x2C options) {\n    const context = createContext(contextObject\x2C getContextOptions(options));\n    return this.runInContext(context\x2C options);\n  }\n}\n\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject'\x2C 'vm.Context'\x2C\n                                   contextifiedObject);\n  }\n}\n\nfunction getRunInContextArgs(options = {}) {\n  validateObject(options\x2C 'options');\n\n  let timeout = options.timeout;\n  if (timeout === undefined) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout\x2C 'options.timeout'\x2C true);\n  }\n\n  const {\n    displayErrors = true\x2C\n    breakOnSigint = false\x2C\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\x2C\n  } = options;\n\n  validateBoolean(displayErrors\x2C 'options.displayErrors');\n  validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n\n  return {\n    breakOnSigint\x2C\n    args: [timeout\x2C displayErrors\x2C breakOnSigint\x2C breakFirstLine]\n  };\n}\n\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName\x2C\n    origin: options.contextOrigin\x2C\n    codeGeneration: undefined\x2C\n    microtaskMode: options.microtaskMode\x2C\n  };\n  if (contextOptions.name !== undefined)\n    validateString(contextOptions.name\x2C 'options.contextName');\n  if (contextOptions.origin !== undefined)\n    validateString(contextOptions.origin\x2C 'options.contextOrigin');\n  if (options.contextCodeGeneration !== undefined) {\n    validateObject(options.contextCodeGeneration\x2C\n                   'options.contextCodeGeneration');\n    const { strings\x2C wasm } = options.contextCodeGeneration;\n    if (strings !== undefined)\n      validateBoolean(strings\x2C 'options.contextCodeGeneration.strings');\n    if (wasm !== undefined)\n      validateBoolean(wasm\x2C 'options.contextCodeGeneration.wasm');\n    contextOptions.codeGeneration = { strings\x2C wasm };\n  }\n  if (options.microtaskMode !== undefined)\n    validateString(options.microtaskMode\x2C 'options.microtaskMode');\n  return contextOptions;\n}\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C { allowArray: true });\n\n  return _isContext(object);\n}\n\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}\x2C options = {}) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n\n  validateObject(options\x2C 'options');\n\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`\x2C\n    origin\x2C\n    codeGeneration\x2C\n    microtaskMode\n  } = options;\n\n  validateString(name\x2C 'options.name');\n  if (origin !== undefined)\n    validateString(origin\x2C 'options.origin');\n  if (codeGeneration !== undefined)\n    validateObject(codeGeneration\x2C 'options.codeGeneration');\n\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== undefined) {\n    ({ strings = true\x2C wasm = true } = codeGeneration);\n    validateBoolean(strings\x2C 'options.codeGeneration.strings');\n    validateBoolean(wasm\x2C 'options.codeGeneration.wasm');\n  }\n\n  let microtaskQueue = null;\n  if (microtaskMode !== undefined) {\n    validateOneOf(microtaskMode\x2C 'options.microtaskMode'\x2C\n                  ['afterEvaluate'\x2C undefined]);\n\n    if (microtaskMode === 'afterEvaluate')\n      microtaskQueue = new MicrotaskQueue();\n  }\n\n  makeContext(contextObject\x2C name\x2C origin\x2C strings\x2C wasm\x2C microtaskQueue);\n  return contextObject;\n}\n\nfunction createScript(code\x2C options) {\n  return new Script(code\x2C options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed\x2C so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn\x2C thisArg\x2C argsArray) {\n  const sigintListeners = process.rawListeners('SIGINT');\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return ReflectApply(fn\x2C thisArg\x2C argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    ArrayPrototypeForEach(sigintListeners\x2C (listener) => {\n      process.addListener('SIGINT'\x2C listener);\n    });\n  }\n}\n\nfunction runInContext(code\x2C contextifiedObject\x2C options) {\n  validateContext(contextifiedObject);\n  if (typeof options === 'string') {\n    options = {\n      filename: options\x2C\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options\x2C [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code\x2C options)\n    .runInContext(contextifiedObject\x2C options);\n}\n\nfunction runInNewContext(code\x2C contextObject\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject\x2C getContextOptions(options));\n  options = { ...options\x2C [kParsingContext]: contextObject };\n  return createScript(code\x2C options).runInNewContext(contextObject\x2C options);\n}\n\nfunction runInThisContext(code\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  return createScript(code\x2C options).runInThisContext(options);\n}\n\nfunction compileFunction(code\x2C params\x2C options = {}) {\n  validateString(code\x2C 'code');\n  if (params !== undefined) {\n    validateArray(params\x2C 'params');\n    ArrayPrototypeForEach(params\x2C\n                          (param\x2C i) => validateString(param\x2C `params[${i}]`));\n  }\n\n  const {\n    filename = ''\x2C\n    columnOffset = 0\x2C\n    lineOffset = 0\x2C\n    cachedData = undefined\x2C\n    produceCachedData = false\x2C\n    parsingContext = undefined\x2C\n    contextExtensions = []\x2C\n    importModuleDynamically\x2C\n  } = options;\n\n  validateString(filename\x2C 'options.filename');\n  validateUint32(columnOffset\x2C 'options.columnOffset');\n  validateUint32(lineOffset\x2C 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData\x2C 'options.cachedData');\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext'\x2C\n        'Context'\x2C\n        parsingContext\n      );\n    }\n  }\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension\x2C name\x2C { nullable: true });\n  });\n\n  const result = _compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n    const { importModuleDynamicallyWrap } =\n      require('internal/vm/module');\n    const { callbackMap } = internalBinding('module_wrap');\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey\x2C {\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\n    });\n  }\n\n  return result.function;\n}\n\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY\x2C\n  detailed: constants.measureMemory.mode.DETAILED\x2C\n};\n\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT\x2C\n  eager: constants.measureMemory.execution.EAGER\x2C\n};\n\nfunction measureMemory(options = {}) {\n  emitExperimentalWarning('vm.measureMemory');\n  validateObject(options\x2C 'options');\n  const { mode = 'summary'\x2C execution = 'default' } = options;\n  validateOneOf(mode\x2C 'options.mode'\x2C ['summary'\x2C 'detailed']);\n  validateOneOf(execution\x2C 'options.execution'\x2C ['default'\x2C 'eager']);\n  const result = _measureMemory(measureMemoryModes[mode]\x2C\n                                measureMemoryExecutions[execution]);\n  if (result === undefined) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\n\nmodule.exports = {\n  Script\x2C\n  createContext\x2C\n  createScript\x2C\n  runInContext\x2C\n  runInNewContext\x2C\n  runInThisContext\x2C\n  isContext\x2C\n  compileFunction\x2C\n  measureMemory\x2C\n};\n\n// The vm module is patched to include vm.Module\x2C vm.SourceTextModule\n// and vm.SyntheticModule in the pre-execution phase when\n// --experimental-vm-modules is on.\n
code-source-info,0x3157a91e8a6e,85,9562,11817,C10O9562C16O9595C25O9595C30O9627C34O9659C43O9659C48O9696C53O9718C59O9696C64O9825C76O9844C84O9866C92O9886C100O9914C108O9945C116O9977C125O10005C130O10048C139O10048C144O10096C153O10096C158O10152C167O10152C172O10204C176O10238C185O10238C190O10290C199O10290C204O10357C208O10397C221O10486C227O10526C244O10532C249O10526C250O10655C259O10655C264O10720C269O10742C275O10720C280O10914C312O10914C318O11091C322O11127C327O11164C331O11155C335O11202C341O11227C346O11256C350O11247C354O11275C358O11303C368O11324C379O11324C384O11473C393O11473C398O11435C403O11532C412O11532C417O11516C422O11584C426O11584C428O11662C432O11655C434O11688C439O11699C451O11742C459O11688C467O11806C471O11815,,
code-creation,LazyCompile,10,126446,0x3157a91e9c36,95, node:internal/validators:167:39,0x31573525a0f8,~
code-source-info,0x3157a91e9c36,17,4966,5244,C16O5002C21O5007C27O5034C43O5040C48O5034C49O5104C56O5111C61O5145C66O5168C71O5185C87O5191C92O5185C94O5243,,
tick,0x7ff803e98203,126510,0,0x0,3,0x1077801f0,0x3157a91e82d7,0x3157a91e6c15,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,126558,0x3157a91e9d96,27, node:vm:313:27,0x3157a91e8740,~
code-source-info,0x3157a91e9d96,85,9752,9803,C0O9766C10O9798C21O9766C26O9803,,
code-creation,LazyCompile,10,126653,0x3157a91e9f26,149, node:internal/validators:100:40,0x315735259ea8,~
code-source-info,0x3157a91e9f26,17,2861,3371,C0O2892C3O2897C9O2920C15O2959C31O2965C36O2959C37O3024C42O3029C48O3061C64O3067C69O3061C70O3138C80O3190C90O3229C109O3196C114O3190C115O3266C120O3288C125O3301C141O3307C146O3301C148O3370,,
code-creation,Eval,10,126749,0x3157a91ea25e,5, /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/no-cluster.js:1:1,0x3157a91ea118,~
script-source,115,/Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/no-cluster.js,const cluster = require('cluster')\n\ncluster.on('fork'\x2C () => {\n  throw new Error('0x does not support clustering.')\n})\n
code-source-info,0x3157a91ea25e,115,0,119,C0O0C4O119,,
code-creation,Function,10,126810,0x3157a91ea346,29, /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/no-cluster.js:1:1,0x3157a91ea1d8,~
code-source-info,0x3157a91ea346,115,0,119,C0O16C3O16C8O44C21O44C28O118,,
code-creation,LazyCompile,10,126941,0x3157a91ea5be,19,importModuleDynamicallyWrap node:internal/vm/module:435:37,0x3157a91c6b70,~
code-source-info,0x3157a91ea5be,113,11705,12148,C0O11705C13O11774C18O12146,,
code-creation,LazyCompile,10,127059,0x3157a91eb796,159,makeRequireFunction node:internal/modules/cjs/helpers:58:29,0x31576e51a608,~
code-source-info,0x3157a91eb796,98,1708,3678,C0O1708C22O1744C25O1748C29O1744C31O1768C33O1779C53O1811C58O1815C69O1831C73O1811C75O1858C81O1858C83O1885C89O1894C95O1922C104O3082C109O3313C111O3329C115O3469C117O3483C121O3495C126O3518C130O3508C134O3583C137O3611C141O3602C145O3627C148O3650C152O3641C156O3661C158O3676,,
code-creation,LazyCompile,10,127150,0x3157a91ebb16,14,require node:internal/modules/cjs/helpers:101:31,0x3157a91eb668,~
code-source-info,0x3157a91ebb16,98,3108,3154,C0O3123C3O3134C8O3134C13O3148,,
code-creation,LazyCompile,10,127213,0x3157a91ebc66,10, node:internal/modules/cjs/helpers:29:66,0x31576e51a7d8,~
code-source-info,0x3157a91ebc66,98,810,835,C0O822C2O828C9O834,,
code-creation,LazyCompile,10,127285,0x3157a91ebdde,129,compileForPublicLoader node:internal/bootstrap/loaders:246:25,0x31575b54f6d0,~
code-source-info,0x3157a91ebdde,9,7543,8215,C0O7562C6O7706C16O7749C33O7712C38O7706C39O7786C44O7786C48O7828C54O8017C61O8048C69O8017C75O8072C80O8090C90O8106C93O8122C98O8106C102O8088C106O8147C111O8147C115O8172C120O8172C124O8203C128O8211,,
code-creation,Eval,10,127385,0x3157a91ec13e,5, node:cluster:1:1,0x3157a91ebff8,~
script-source,116,node:cluster,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst childOrPrimary = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'primary';\nmodule.exports = require(`internal/cluster/${childOrPrimary}`);\n
code-source-info,0x3157a91ec13e,116,0,1291,C0O0C4O1291,,
code-creation,Function,10,127575,0x3157a91ec1e6,39, node:cluster:1:1,0x3157a91ec0b8,~
code-source-info,0x3157a91ec1e6,116,0,1291,C0O1172C3O1200C7O1189C19O1227C24O1272C29O1244C33O1242C38O1290,,
tick,0x7ff803ca60ee,127611,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,128022,0x3157a91ecdfe,5, node:internal/cluster/primary:1:1,0x3157a91eca78,~
script-source,117,node:internal/cluster/primary,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSome\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  RegExpPrototypeTest\x2C\n  SafeMap\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst assert = require('internal/assert');\nconst { fork } = require('child_process');\nconst path = require('path');\nconst EventEmitter = require('events');\nconst RoundRobinHandle = require('internal/cluster/round_robin_handle');\nconst SharedHandle = require('internal/cluster/shared_handle');\nconst Worker = require('internal/cluster/worker');\nconst { internal\x2C sendHelper } = require('internal/cluster/utils');\nconst cluster = new EventEmitter();\nconst intercom = new EventEmitter();\nconst SCHED_NONE = 1;\nconst SCHED_RR = 2;\nconst minPort = 1024;\nconst maxPort = 65535;\nconst { validatePort } = require('internal/validators');\n\nmodule.exports = cluster;\n\nconst handles = new SafeMap();\ncluster.isWorker = false;\ncluster.isMaster = true; // Deprecated alias. Must be same as isPrimary.\ncluster.isPrimary = true;\ncluster.Worker = Worker;\ncluster.workers = {};\ncluster.settings = {};\ncluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.\ncluster.SCHED_RR = SCHED_RR;      // Primary distributes connections.\n\nlet ids = 0;\nlet debugPortOffset = 1;\nlet initialized = false;\n\n// XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?\nlet schedulingPolicy = process.env.NODE_CLUSTER_SCHED_POLICY;\nif (schedulingPolicy === 'rr')\n  schedulingPolicy = SCHED_RR;\nelse if (schedulingPolicy === 'none')\n  schedulingPolicy = SCHED_NONE;\nelse if (process.platform === 'win32') {\n  // Round-robin doesn't perform well on\n  // Windows due to the way IOCP is wired up.\n  schedulingPolicy = SCHED_NONE;\n} else\n  schedulingPolicy = SCHED_RR;\n\ncluster.schedulingPolicy = schedulingPolicy;\n\ncluster.setupPrimary = function(options) {\n  const settings = {\n    args: ArrayPrototypeSlice(process.argv\x2C 2)\x2C\n    exec: process.argv[1]\x2C\n    execArgv: process.execArgv\x2C\n    silent: false\x2C\n    ...cluster.settings\x2C\n    ...options\n  };\n\n  // Tell V8 to write profile data for each process to a separate file.\n  // Without --logfile=v8-%p.log\x2C everything ends up in a single\x2C unusable\n  // file. (Unusable because what V8 logs are memory addresses and each\n  // process has its own memory mappings.)\n  if (ArrayPrototypeSome(settings.execArgv\x2C\n                         (s) => StringPrototypeStartsWith(s\x2C '--prof')) &&\n      !ArrayPrototypeSome(settings.execArgv\x2C\n                          (s) => StringPrototypeStartsWith(s\x2C '--logfile='))) {\n    settings.execArgv = [...settings.execArgv\x2C '--logfile=v8-%p.log'];\n  }\n\n  cluster.settings = settings;\n\n  if (initialized === true)\n    return process.nextTick(setupSettingsNT\x2C settings);\n\n  initialized = true;\n  schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.\n  assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR\x2C\n         `Bad cluster.schedulingPolicy: ${schedulingPolicy}`);\n\n  process.nextTick(setupSettingsNT\x2C settings);\n\n  process.on('internalMessage'\x2C (message) => {\n    if (message.cmd !== 'NODE_DEBUG_ENABLED')\n      return;\n\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.state === 'online' || worker.state === 'listening') {\n        process._debugProcess(worker.process.pid);\n      } else {\n        worker.once('online'\x2C function() {\n          process._debugProcess(this.process.pid);\n        });\n      }\n    }\n  });\n};\n\n// Deprecated alias must be same as setupPrimary\ncluster.setupMaster = cluster.setupPrimary;\n\nfunction setupSettingsNT(settings) {\n  cluster.emit('setup'\x2C settings);\n}\n\nfunction createWorkerProcess(id\x2C env) {\n  const workerEnv = { ...process.env\x2C ...env\x2C NODE_UNIQUE_ID: `${id}` };\n  const execArgv = [...cluster.settings.execArgv];\n  const debugArgRegex = /--inspect(?:-brk|-port)?|--debug-port/;\n  const nodeOptions = process.env.NODE_OPTIONS || '';\n\n  if (ArrayPrototypeSome(execArgv\x2C\n                         (arg) => RegExpPrototypeTest(debugArgRegex\x2C arg)) ||\n      RegExpPrototypeTest(debugArgRegex\x2C nodeOptions)) {\n    let inspectPort;\n    if ('inspectPort' in cluster.settings) {\n      if (typeof cluster.settings.inspectPort === 'function')\n        inspectPort = cluster.settings.inspectPort();\n      else\n        inspectPort = cluster.settings.inspectPort;\n\n      validatePort(inspectPort);\n    } else {\n      inspectPort = process.debugPort + debugPortOffset;\n      if (inspectPort > maxPort)\n        inspectPort = inspectPort - maxPort + minPort - 1;\n      debugPortOffset++;\n    }\n\n    ArrayPrototypePush(execArgv\x2C `--inspect-port=${inspectPort}`);\n  }\n\n  return fork(cluster.settings.exec\x2C cluster.settings.args\x2C {\n    cwd: cluster.settings.cwd\x2C\n    env: workerEnv\x2C\n    serialization: cluster.settings.serialization\x2C\n    silent: cluster.settings.silent\x2C\n    windowsHide: cluster.settings.windowsHide\x2C\n    execArgv: execArgv\x2C\n    stdio: cluster.settings.stdio\x2C\n    gid: cluster.settings.gid\x2C\n    uid: cluster.settings.uid\n  });\n}\n\nfunction removeWorker(worker) {\n  assert(worker);\n  delete cluster.workers[worker.id];\n\n  if (ObjectKeys(cluster.workers).length === 0) {\n    assert(handles.size === 0\x2C 'Resource leak detected.');\n    intercom.emit('disconnect');\n  }\n}\n\nfunction removeHandlesForWorker(worker) {\n  assert(worker);\n\n  handles.forEach((handle\x2C key) => {\n    if (handle.remove(worker))\n      handles.delete(key);\n  });\n}\n\ncluster.fork = function(env) {\n  cluster.setupPrimary();\n  const id = ++ids;\n  const workerProcess = createWorkerProcess(id\x2C env);\n  const worker = new Worker({\n    id: id\x2C\n    process: workerProcess\n  });\n\n  worker.on('message'\x2C function(message\x2C handle) {\n    cluster.emit('message'\x2C this\x2C message\x2C handle);\n  });\n\n  worker.process.once('exit'\x2C (exitCode\x2C signalCode) => {\n    /*\n     * Remove the worker from the workers list only\n     * if it has disconnected\x2C otherwise we might\n     * still want to access it.\n     */\n    if (!worker.isConnected()) {\n      removeHandlesForWorker(worker);\n      removeWorker(worker);\n    }\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'dead';\n    worker.emit('exit'\x2C exitCode\x2C signalCode);\n    cluster.emit('exit'\x2C worker\x2C exitCode\x2C signalCode);\n  });\n\n  worker.process.once('disconnect'\x2C () => {\n    /*\n     * Now is a good time to remove the handles\n     * associated with this worker because it is\n     * not connected to the primary anymore.\n     */\n    removeHandlesForWorker(worker);\n\n    /*\n     * Remove the worker from the workers list only\n     * if its process has exited. Otherwise\x2C we might\n     * still want to access it.\n     */\n    if (worker.isDead())\n      removeWorker(worker);\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'disconnected';\n    worker.emit('disconnect');\n    cluster.emit('disconnect'\x2C worker);\n  });\n\n  worker.process.on('internalMessage'\x2C internal(worker\x2C onmessage));\n  process.nextTick(emitForkNT\x2C worker);\n  cluster.workers[worker.id] = worker;\n  return worker;\n};\n\nfunction emitForkNT(worker) {\n  cluster.emit('fork'\x2C worker);\n}\n\ncluster.disconnect = function(cb) {\n  const workers = ObjectKeys(cluster.workers);\n\n  if (workers.length === 0) {\n    process.nextTick(() => intercom.emit('disconnect'));\n  } else {\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.isConnected()) {\n        worker.disconnect();\n      }\n    }\n  }\n\n  if (typeof cb === 'function')\n    intercom.once('disconnect'\x2C cb);\n};\n\nconst methodMessageMapping = {\n  close\x2C\n  exitedAfterDisconnect\x2C\n  listening\x2C\n  online\x2C\n  queryServer\x2C\n};\n\nfunction onmessage(message\x2C handle) {\n  const worker = this;\n\n  const fn = methodMessageMapping[message.act];\n\n  if (typeof fn === 'function')\n    fn(worker\x2C message);\n}\n\nfunction online(worker) {\n  worker.state = 'online';\n  worker.emit('online');\n  cluster.emit('online'\x2C worker);\n}\n\nfunction exitedAfterDisconnect(worker\x2C message) {\n  worker.exitedAfterDisconnect = true;\n  send(worker\x2C { ack: message.seq });\n}\n\nfunction queryServer(worker\x2C message) {\n  // Stop processing if worker already disconnecting\n  if (worker.exitedAfterDisconnect)\n    return;\n\n  const key = `${message.address}:${message.port}:${message.addressType}:` +\n              `${message.fd}:${message.index}`;\n  let handle = handles.get(key);\n\n  if (handle === undefined) {\n    let address = message.address;\n\n    // Find shortest path for unix sockets because of the ~100 byte limit\n    if (message.port < 0 && typeof address === 'string' &&\n        process.platform !== 'win32') {\n\n      address = path.relative(process.cwd()\x2C address);\n\n      if (message.address.length < address.length)\n        address = message.address;\n    }\n\n    // UDP is exempt from round-robin connection balancing for what should\n    // be obvious reasons: it's connectionless. There is nothing to send to\n    // the workers except raw datagrams and that's pointless.\n    if (schedulingPolicy !== SCHED_RR ||\n        message.addressType === 'udp4' ||\n        message.addressType === 'udp6') {\n      handle = new SharedHandle(key\x2C address\x2C message);\n    } else {\n      handle = new RoundRobinHandle(key\x2C address\x2C message);\n    }\n\n    handles.set(key\x2C handle);\n  }\n\n  if (!handle.data)\n    handle.data = message.data;\n\n  // Set custom server data\n  handle.add(worker\x2C (errno\x2C reply\x2C handle) => {\n    const { data } = handles.get(key);\n\n    if (errno)\n      handles.delete(key);  // Gives other workers a chance to retry.\n\n    send(worker\x2C {\n      errno\x2C\n      key\x2C\n      ack: message.seq\x2C\n      data\x2C\n      ...reply\n    }\x2C handle);\n  });\n}\n\nfunction listening(worker\x2C message) {\n  const info = {\n    addressType: message.addressType\x2C\n    address: message.address\x2C\n    port: message.port\x2C\n    fd: message.fd\n  };\n\n  worker.state = 'listening';\n  worker.emit('listening'\x2C info);\n  cluster.emit('listening'\x2C worker\x2C info);\n}\n\n// Server in worker is closing\x2C remove from list. The handle may have been\n// removed by a prior call to removeHandlesForWorker() so guard against that.\nfunction close(worker\x2C message) {\n  const key = message.key;\n  const handle = handles.get(key);\n\n  if (handle && handle.remove(worker))\n    handles.delete(key);\n}\n\nfunction send(worker\x2C message\x2C handle\x2C cb) {\n  return sendHelper(worker.process\x2C message\x2C handle\x2C cb);\n}\n\n// Extend generic Worker with methods specific to the primary process.\nWorker.prototype.disconnect = function() {\n  this.exitedAfterDisconnect = true;\n  send(this\x2C { act: 'disconnect' });\n  removeHandlesForWorker(this);\n  removeWorker(this);\n  return this;\n};\n\nWorker.prototype.destroy = function(signo) {\n  const proc = this.process;\n\n  signo = signo || 'SIGTERM';\n\n  if (this.isConnected()) {\n    this.once('disconnect'\x2C () => proc.kill(signo));\n    this.disconnect();\n    return;\n  }\n\n  proc.kill(signo);\n};\n
code-source-info,0x3157a91ecdfe,117,0,10794,C0O0C4O10794,,
code-creation,Function,10,129072,0x3157a91ed7c6,640, node:internal/cluster/primary:1:1,0x3157a91ecd78,~
code-source-info,0x3157a91ed7c6,117,0,10794,C0O0C160O25C166O47C172O70C178O92C184O106C190O122C196O145C201O156C207O216C210O216C214O216C216O261C219O261C224O252C230O300C233O300C237O300C239O338C242O338C247O382C250O382C254O382C256O451C259O451C263O451C265O509C268O509C272O509C274O578C277O578C282O553C288O563C294O629C296O629C301O629C303O666C305O666C310O666C312O705C314O705C316O725C318O725C320O744C324O744C326O766C332O766C334O798C337O798C342O781C348O831C350O846C354O874C356O874C361O874C363O889C367O906C371O915C375O932C379O988C383O1006C387O1014C392O1029C396O1039C400O1055C404O1061C408O1078C412O1084C417O1103C421O1155C426O1172C430O1236C431O1236C433O1261C435O1261C437O1282C438O1282C440O1385C443O1393C448O1397C452O1385C454O1424C459O1445C464O1457C466O1474C470O1491C475O1512C480O1526C482O1543C486O1562C489O1574C496O1583C501O1687C503O1704C507O1727C509O1744C511O1757C516O1782C520O1803C527O1824C531O3495C537O3525C541O3515C545O5393C552O5406C556O7086C563O7105C567O7510C574O7514C580O7523C586O7548C592O7561C598O7571C604O7510C606O10354C609O10361C618O10382C622O10544C625O10551C634O10569C639O10793,,
tick,0x1077e39d0,129212,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x1076a29f8,129752,1,0x10712a580,2,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,129851,0x3157a91ef6a6,5, node:child_process:1:1,0x3157a91ef1d0,~
script-source,118,node:child_process,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeLastIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Error\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeTest\x2C\n  SafeSet\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst {\n  promisify\x2C\n  convertToValidSignal\x2C\n  createDeferredPromise\x2C\n  getSystemErrorName\n} = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nlet debug = require('internal/util/debuglog').debuglog(\n  'child_process'\x2C\n  (fn) => {\n    debug = fn;\n  }\n);\nconst { Buffer } = require('buffer');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\n\nconst {\n  AbortError\x2C\n  codes: errorCodes\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_CHILD_PROCESS_IPC_REQUIRED\x2C\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = errorCodes;\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { getValidatedPath } = require('internal/fs/utils');\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst child_process = require('internal/child_process');\nconst {\n  getValidStdio\x2C\n  setupChannel\x2C\n  ChildProcess\x2C\n  stdioStringToArray\n} = child_process;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n/**\n * Spawns a new Node.js process + fork.\n * @param {string} modulePath\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   detached?: boolean;\n *   env?: Object;\n *   execPath?: string;\n *   execArgv?: string[];\n *   gid?: number;\n *   serialization?: string;\n *   signal?: AbortSignal;\n *   killSignal?: string | number;\n *   silent?: boolean;\n *   stdio?: Array | string;\n *   uid?: number;\n *   windowsVerbatimArguments?: boolean;\n *   timeout?: number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction fork(modulePath /* \x2C args\x2C options */) {\n  validateString(modulePath\x2C 'modulePath');\n\n  // Get options and args arguments.\n  let execArgv;\n  let options = {};\n  let args = [];\n  let pos = 1;\n  if (pos < arguments.length && ArrayIsArray(arguments[pos])) {\n    args = arguments[pos++];\n  }\n\n  if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && arguments[pos] != null) {\n    if (typeof arguments[pos] !== 'object') {\n      throw new ERR_INVALID_ARG_VALUE(`arguments[${pos}]`\x2C arguments[pos]);\n    }\n\n    options = { ...arguments[pos++] };\n  }\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf(execArgv\x2C process._eval);\n    if (index > 0) {\n      // Remove the -e switch to avoid fork bombing ourselves.\n      execArgv = ArrayPrototypeSlice(execArgv);\n      ArrayPrototypeSplice(execArgv\x2C index - 1\x2C 2);\n    }\n  }\n\n  args = [...execArgv\x2C modulePath\x2C ...args];\n\n  if (typeof options.stdio === 'string') {\n    options.stdio = stdioStringToArray(options.stdio\x2C 'ipc');\n  } else if (!ArrayIsArray(options.stdio)) {\n    // Use a separate fd=3 for the IPC channel. Inherit stdin\x2C stdout\x2C\n    // and stderr from the parent if silent isn't set.\n    options.stdio = stdioStringToArray(\n      options.silent ? 'pipe' : 'inherit'\x2C\n      'ipc');\n  } else if (!ArrayPrototypeIncludes(options.stdio\x2C 'ipc')) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');\n  }\n\n  options.execPath = options.execPath || process.execPath;\n  options.shell = false;\n\n  return spawn(options.execPath\x2C args\x2C options);\n}\n\nfunction _forkChild(fd\x2C serializationMode) {\n  // set process.send()\n  const p = new Pipe(PipeConstants.IPC);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process\x2C p\x2C serializationMode);\n  process.on('newListener'\x2C function onNewListener(name) {\n    if (name === 'message' || name === 'disconnect') control.refCounted();\n  });\n  process.on('removeListener'\x2C function onRemoveListener(name) {\n    if (name === 'message' || name === 'disconnect') control.unrefCounted();\n  });\n}\n\nfunction normalizeExecArgs(command\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command\x2C\n    options: options\x2C\n    callback: callback\n  };\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Object;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction exec(command\x2C options\x2C callback) {\n  const opts = normalizeExecArgs(command\x2C options\x2C callback);\n  return module.exports.execFile(opts.file\x2C\n                                 opts.options\x2C\n                                 opts.callback);\n}\n\nconst customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    const { promise\x2C resolve\x2C reject } = createDeferredPromise();\n\n    promise.child = orig(...args\x2C (err\x2C stdout\x2C stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout\x2C stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec\x2C promisify.custom\x2C {\n  enumerable: false\x2C\n  value: customPromiseExecFunction(exec)\n});\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Object;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction execFile(file /* \x2C args\x2C options\x2C callback */) {\n  let args = [];\n  let callback;\n  let options;\n\n  // Parse the optional positional parameters.\n  let pos = 1;\n  if (pos < arguments.length && ArrayIsArray(arguments[pos])) {\n    args = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && typeof arguments[pos] === 'object') {\n    options = arguments[pos++];\n  } else if (pos < arguments.length && arguments[pos] == null) {\n    pos++;\n  }\n\n  if (pos < arguments.length && typeof arguments[pos] === 'function') {\n    callback = arguments[pos++];\n  }\n\n  if (!callback && pos < arguments.length && arguments[pos] != null) {\n    throw new ERR_INVALID_ARG_VALUE('args'\x2C arguments[pos]);\n  }\n\n  options = {\n    encoding: 'utf8'\x2C\n    timeout: 0\x2C\n    maxBuffer: MAX_BUFFER\x2C\n    killSignal: 'SIGTERM'\x2C\n    cwd: null\x2C\n    env: null\x2C\n    shell: false\x2C\n    ...options\n  };\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file\x2C args\x2C {\n    cwd: options.cwd\x2C\n    env: options.env\x2C\n    gid: options.gid\x2C\n    shell: options.shell\x2C\n    signal: options.signal\x2C\n    uid: options.uid\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exithandler(code\x2C signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding ||\n      (\n        child.stdout &&\n        child.stdout.readableEncoding\n      )) {\n      stdout = ArrayPrototypeJoin(_stdout\x2C '');\n    } else {\n      stdout = Buffer.concat(_stdout);\n    }\n    if (encoding ||\n      (\n        child.stderr &&\n        child.stderr.readableEncoding\n      )) {\n      stderr = ArrayPrototypeJoin(_stderr\x2C '');\n    } else {\n      stderr = Buffer.concat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null\x2C stdout\x2C stderr);\n      return;\n    }\n\n    if (args.length !== 0)\n      cmd += ` ${ArrayPrototypeJoin(args\x2C ' ')}`;\n\n    if (!ex) {\n      // eslint-disable-next-line no-restricted-syntax\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code < 0 ? getSystemErrorName(code) : code;\n      ex.signal = signal;\n    }\n\n    ex.cmd = cmd;\n    callback(ex\x2C stdout\x2C stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }\x2C options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data'\x2C function onChildStdout(chunk) {\n      const encoding = child.stdout.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      const slice = encoding ? StringPrototypeSlice :\n        (buf\x2C ...args) => buf.slice(...args);\n      stdoutLen += length;\n\n      if (stdoutLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        ArrayPrototypePush(_stdout\x2C slice(chunk\x2C 0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');\n        kill();\n      } else {\n        ArrayPrototypePush(_stdout\x2C chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data'\x2C function onChildStderr(chunk) {\n      const encoding = child.stderr.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      stderrLen += length;\n\n      if (stderrLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        ArrayPrototypePush(_stderr\x2C\n                           chunk.slice(0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');\n        kill();\n      } else {\n        _stderr.push(chunk);\n      }\n    });\n  }\n\n  child.addListener('close'\x2C exithandler);\n  child.addListener('error'\x2C errorhandler);\n\n  return child;\n}\n\nObjectDefineProperty(execFile\x2C promisify.custom\x2C {\n  enumerable: false\x2C\n  value: customPromiseExecFunction(execFile)\n});\n\nfunction normalizeSpawnArguments(file\x2C args\x2C options) {\n  validateString(file\x2C 'file');\n\n  if (file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE('file'\x2C file\x2C 'cannot be empty');\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('args'\x2C 'object'\x2C args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  if (options === undefined)\n    options = {};\n  else\n    validateObject(options\x2C 'options');\n\n  let cwd = options.cwd;\n\n  // Validate the cwd\x2C if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd\x2C 'options.cwd');\n  }\n\n  // Validate detached\x2C if present.\n  if (options.detached != null) {\n    validateBoolean(options.detached\x2C 'options.detached');\n  }\n\n  // Validate the uid\x2C if present.\n  if (options.uid != null && !isInt32(options.uid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.uid'\x2C 'int32'\x2C options.uid);\n  }\n\n  // Validate the gid\x2C if present.\n  if (options.gid != null && !isInt32(options.gid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.gid'\x2C 'int32'\x2C options.gid);\n  }\n\n  // Validate the shell\x2C if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('options.shell'\x2C\n                                   ['boolean'\x2C 'string']\x2C options.shell);\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n  }\n\n  // Validate windowsHide\x2C if present.\n  if (options.windowsHide != null) {\n    validateBoolean(options.windowsHide\x2C 'options.windowsHide');\n  }\n\n  // Validate windowsVerbatimArguments\x2C if present.\n  let { windowsVerbatimArguments } = options;\n  if (windowsVerbatimArguments != null) {\n    validateBoolean(windowsVerbatimArguments\x2C\n                    'options.windowsVerbatimArguments');\n  }\n\n  if (options.shell) {\n    const command = ArrayPrototypeJoin([file\x2C ...args]\x2C ' ');\n    // Set the shell\x2C switches\x2C and commands.\n    if (process.platform === 'win32') {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else\n        file = process.env.comspec || 'cmd.exe';\n      // '/d /s /c' is used only for cmd.exe.\n      if (RegExpPrototypeTest(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i\x2C file)) {\n        args = ['/d'\x2C '/s'\x2C '/c'\x2C `"${command}"`];\n        windowsVerbatimArguments = true;\n      } else {\n        args = ['-c'\x2C command];\n      }\n    } else {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else if (process.platform === 'android')\n        file = '/system/bin/sh';\n      else\n        file = '/bin/sh';\n      args = ['-c'\x2C command];\n    }\n  }\n\n  if (typeof options.argv0 === 'string') {\n    ArrayPrototypeUnshift(args\x2C options.argv0);\n  } else {\n    ArrayPrototypeUnshift(args\x2C file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = [];\n\n  // process.env.NODE_V8_COVERAGE always propagates\x2C making it possible to\n  // collect coverage for programs that spawn with white-listed environment.\n  if (process.env.NODE_V8_COVERAGE &&\n      !ObjectPrototypeHasOwnProperty(options.env || {}\x2C 'NODE_V8_COVERAGE')) {\n    env.NODE_V8_COVERAGE = process.env.NODE_V8_COVERAGE;\n  }\n\n  let envKeys = [];\n  // Prototype values are intentionally included.\n  for (const key in env) {\n    ArrayPrototypePush(envKeys\x2C key);\n  }\n\n  if (process.platform === 'win32') {\n    // On Windows env keys are case insensitive. Filter out duplicates\x2C\n    // keeping only the first one (in lexicographic order)\n    const sawKey = new SafeSet();\n    envKeys = ArrayPrototypeFilter(\n      ArrayPrototypeSort(envKeys)\x2C\n      (key) => {\n        const uppercaseKey = StringPrototypeToUpperCase(key);\n        if (sawKey.has(uppercaseKey)) {\n          return false;\n        }\n        sawKey.add(uppercaseKey);\n        return true;\n      }\n    );\n  }\n\n  for (const key of envKeys) {\n    const value = env[key];\n    if (value !== undefined) {\n      ArrayPrototypePush(envPairs\x2C `${key}=${value}`);\n    }\n  }\n\n  return {\n    // Make a shallow copy so we don't clobber the user's options object.\n    ...options\x2C\n    args\x2C\n    cwd\x2C\n    detached: !!options.detached\x2C\n    envPairs\x2C\n    file\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!windowsVerbatimArguments\x2C\n  };\n}\n\nfunction abortChildProcess(child\x2C killSignal) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit('error'\x2C new AbortError());\n    }\n  } catch (err) {\n    child.emit('error'\x2C err);\n  }\n}\n\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Object;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction spawn(file\x2C args\x2C options) {\n  options = normalizeSpawnArguments(file\x2C args\x2C options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug('spawn'\x2C options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit('error'\x2C err);\n        }\n        timeoutId = null;\n      }\n    }\x2C options.timeout);\n\n    child.once('exit'\x2C () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener('abort'\x2C onAbortListener\x2C { once: true });\n      child.once('exit'\x2C\n                 () => signal.removeEventListener('abort'\x2C onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child\x2C killSignal);\n    }\n  }\n\n  return child;\n}\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Object;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nfunction spawnSync(file\x2C args\x2C options) {\n  options = {\n    maxBuffer: MAX_BUFFER\x2C\n    ...normalizeSpawnArguments(file\x2C args\x2C options)\n  };\n\n  debug('spawnSync'\x2C options);\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  // Validate and translate the kill signal\x2C if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  options.stdio = getValidStdio(options.stdio || 'pipe'\x2C true).stdio;\n\n  if (options.input) {\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd\x2C ensure it is a valid buffer\n  for (let i = 0; i < options.stdio.length; i++) {\n    const input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\n      if (isArrayBufferView(input)) {\n        pipe.input = input;\n      } else if (typeof input === 'string') {\n        pipe.input = Buffer.from(input\x2C options.encoding);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`\x2C\n                                       ['Buffer'\x2C\n                                        'TypedArray'\x2C\n                                        'DataView'\x2C\n                                        'string']\x2C\n                                       input);\n      }\n    }\n  }\n\n  return child_process.spawnSync(options);\n}\n\n\nfunction checkExecSyncError(ret\x2C args\x2C cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n  } else if (ret.status !== 0) {\n    let msg = 'Command failed: ';\n    msg += cmd || ArrayPrototypeJoin(args\x2C ' ');\n    if (ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    // eslint-disable-next-line no-restricted-syntax\n    err = new Error(msg);\n  }\n  if (err) {\n    ObjectAssign(err\x2C ret);\n  }\n  return err;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} command\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Object;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execFileSync(command\x2C args\x2C options) {\n  options = normalizeSpawnArguments(command\x2C args\x2C options);\n\n  const inheritStderr = !options.stdio;\n  const ret = spawnSync(options.file\x2C\n                        ArrayPrototypeSlice(options.args\x2C 1)\x2C options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C options.args\x2C undefined);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Object;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execSync(command\x2C options) {\n  const opts = normalizeExecArgs(command\x2C options\x2C null);\n  const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file\x2C opts.options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C opts.args\x2C command);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE('timeout'\x2C 'an unsigned integer'\x2C timeout);\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE('options.maxBuffer'\x2C\n                               'a positive number'\x2C\n                               maxBuffer);\n  }\n}\n\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE('options.killSignal'\x2C\n                                   ['string'\x2C 'number']\x2C\n                                   killSignal);\n  }\n}\n\nmodule.exports = {\n  _forkChild\x2C\n  ChildProcess\x2C\n  exec\x2C\n  execFile\x2C\n  execFileSync\x2C\n  execSync\x2C\n  fork\x2C\n  spawn\x2C\n  spawnSync\n};\n
code-source-info,0x3157a91ef6a6,118,0,24635,C0O0C4O24635,,
code-creation,Function,10,132156,0x3157a91f0106,748, node:child_process:1:1,0x3157a91ef620,~
code-source-info,0x3157a91f0106,118,0,24635,C0O0C235O1159C241O1175C247O1199C253O1225C259O1247C265O1276C271O1298C277O1321C283O1343C289O1367C295O1392C301O1401C307O1420C313O1436C318O1460C324O1493C330O1516C336O1527C342O1551C348O1692C351O1692C356O1607C361O1620C367O1644C373O1669C379O1748C382O1748C387O1726C393O1792C396O1792C401O1825C414O1826C420O1792C422O1909C425O1909C430O1898C436O1971C439O1971C444O1936C450O1953C456O2049C459O2049C464O2012C470O2033C475O2087C481O2112C487O2146C493O2183C499O2207C505O2278C508O2278C513O2249C519O2263C525O2326C528O2326C533O2305C539O2457C542O2457C547O2366C553O2377C559O2400C565O2419C571O2437C577O2511C580O2511C584O2511C586O2628C589O2556C595O2573C601O2589C607O2605C613O2663C619O2663C621O6605C626O7009C636O7049C647O6972C652O12818C662O12858C673O12777C678O24506C688O24527C694O24541C700O24557C706O24565C712O24577C718O24593C724O24605C730O24613C736O24622C742O24521C747O24634,,
tick,0x7ff803e80c86,132302,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80bf5,132333,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,133202,0x3157a91f5616,5, node:internal/child_process:1:1,0x3157a91f4f28,~
script-source,119,node:internal/child_process,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototype\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_INVALID_SYNC_FORK_INPUT\x2C\n    ERR_IPC_CHANNEL_CLOSED\x2C\n    ERR_IPC_DISCONNECTED\x2C\n    ERR_IPC_ONE_PIPE\x2C\n    ERR_IPC_SYNC_FORK\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst EventEmitter = require('events');\nconst net = require('net');\nconst dgram = require('dgram');\nconst inspect = require('internal/util/inspect').inspect;\nconst assert = require('internal/assert');\n\nconst { Process } = internalBinding('process_wrap');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\n} = internalBinding('stream_wrap');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\nconst { TCP } = internalBinding('tcp_wrap');\nconst { TTY } = internalBinding('tty_wrap');\nconst { UDP } = internalBinding('udp_wrap');\nconst SocketList = require('internal/socket_list');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { convertToValidSignal\x2C deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst spawn_sync = internalBinding('spawn_sync');\nconst { kStateSymbol } = require('internal/dgram');\n\nconst {\n  UV_EACCES\x2C\n  UV_EAGAIN\x2C\n  UV_EINVAL\x2C\n  UV_EMFILE\x2C\n  UV_ENFILE\x2C\n  UV_ENOENT\x2C\n  UV_ENOSYS\x2C\n  UV_ESRCH\n} = internalBinding('uv');\n\nconst { SocketListSend\x2C SocketListReceive } = SocketList;\n\n// Lazy loaded for startup performance and to allow monkey patching of\n// internalBinding('http_parser').HTTPParser.\nlet freeParser;\nlet HTTPParser;\n\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\nconst kChannelHandle = Symbol('kChannelHandle');\nconst kIsUsedAsStdio = Symbol('kIsUsedAsStdio');\n\n// This object contain function to convert TCP objects to native handle objects\n// and back again.\nconst handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'net.Server': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C server\x2C options) {\n      return server._handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const server = new net.Server();\n      server.listen(handle\x2C () => {\n        emit(server);\n      });\n    }\n  }\x2C\n\n  'net.Socket': {\n    send(message\x2C socket\x2C options) {\n      if (!socket._handle)\n        return;\n\n      // If the socket was created by net.Server\n      if (socket.server) {\n        // The worker should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\n        const socketList = getSocketList('send'\x2C this\x2C message.key);\n\n        // The server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the workers\n        if (firstTime) socket.server._setupWorker(socketList);\n\n        // Act like socket is detached\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n\n      const handle = socket._handle;\n\n      // Remove handle from socket object\x2C it will be closed when the socket\n      // will be sent\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n        socket.setTimeout(0);\n\n        if (freeParser === undefined)\n          freeParser = require('_http_common').freeParser;\n        if (HTTPParser === undefined)\n          HTTPParser = require('_http_common').HTTPParser;\n\n        // In case of an HTTP connection socket\x2C release the associated\n        // resources\n        if (socket.parser && socket.parser instanceof HTTPParser) {\n          freeParser(socket.parser\x2C null\x2C socket);\n          if (socket._httpMessage)\n            socket._httpMessage.detachSocket(socket);\n        }\n      }\n\n      return handle;\n    }\x2C\n\n    postSend(message\x2C handle\x2C options\x2C callback\x2C target) {\n      // Store the handle after successfully sending it\x2C so it can be closed\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent\x2C\n      // just close it.\n      if (handle && !options.keepOpen) {\n        if (target) {\n          // There can only be one _pendingMessage as passing handles are\n          // processed one at a time: handles are stored in _handleQueue while\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\n          assert(!target._pendingMessage);\n          target._pendingMessage =\n              { callback\x2C message\x2C handle\x2C options\x2C retransmissions: 0 };\n        } else {\n          handle.close();\n        }\n      }\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new net.Socket({\n        handle: handle\x2C\n        readable: true\x2C\n        writable: true\n      });\n\n      // If the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // Add socket to connections list\n        const socketList = getSocketList('got'\x2C this\x2C message.key);\n        socketList.add({\n          socket: socket\n        });\n      }\n\n      emit(socket);\n    }\n  }\x2C\n\n  'dgram.Native': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'dgram.Socket': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C socket\x2C options) {\n      message.dgramType = socket.type;\n\n      return socket[kStateSymbol].handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle\x2C () => {\n        emit(socket);\n      });\n    }\n  }\n};\n\nfunction stdioStringToArray(stdio\x2C channel) {\n  const options = [];\n\n  switch (stdio) {\n    case 'ignore':\n    case 'overlapped':\n    case 'pipe': ArrayPrototypePush(options\x2C stdio\x2C stdio\x2C stdio); break;\n    case 'inherit': ArrayPrototypePush(options\x2C 0\x2C 1\x2C 2); break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  if (channel) ArrayPrototypePush(options\x2C channel);\n\n  return options;\n}\n\nfunction ChildProcess() {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle[owner_symbol] = this;\n\n  this._handle.onexit = (exitCode\x2C signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n\n    this._handle.close();\n    this._handle = null;\n\n    if (exitCode < 0) {\n      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\n      const err = errnoException(exitCode\x2C syscall);\n\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs\x2C 1);\n      this.emit('error'\x2C err);\n    } else {\n      this.emit('exit'\x2C this.exitCode\x2C this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched\x2C\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output\x2C if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio\x2C this);\n\n    maybeClose(this);\n  };\n}\nObjectSetPrototypeOf(ChildProcess.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(ChildProcess\x2C EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream\x2C e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\n\nfunction createSocket(pipe\x2C readable) {\n  return net.Socket({ handle: pipe\x2C readable\x2C writable: !readable });\n}\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe) return 'pipe';\n  if (stream instanceof TTY) return 'tty';\n  if (stream instanceof TCP) return 'tcp';\n  if (stream instanceof UDP) return 'udp';\n\n  return false;\n}\n\nfunction closePendingHandle(target) {\n  target._pendingMessage.handle.close();\n  target._pendingMessage = null;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  let i = 0;\n\n  validateObject(options\x2C 'options');\n\n  // If no `stdio` option was given - use default\n  let stdio = options.stdio || 'pipe';\n\n  stdio = getValidStdio(stdio\x2C false);\n\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n\n  validateOneOf(options.serialization\x2C 'options.serialization'\x2C\n                [undefined\x2C 'json'\x2C 'advanced']);\n  const serialization = options.serialization || 'json';\n\n  if (ipc !== undefined) {\n    // Let child process know about opened IPC channel\n    if (options.envPairs === undefined)\n      options.envPairs = [];\n    else\n      validateArray(options.envPairs\x2C 'options.envPairs');\n\n    ArrayPrototypePush(options.envPairs\x2C `NODE_CHANNEL_FD=${ipcFd}`);\n    ArrayPrototypePush(options.envPairs\x2C\n                       `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`);\n  }\n\n  validateString(options.file\x2C 'options.file');\n  this.spawnfile = options.file;\n\n  if (options.args === undefined) {\n    this.spawnargs = [];\n  } else {\n    validateArray(options.args\x2C 'options.args');\n    this.spawnargs = options.args;\n  }\n\n  const err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error\x2C not throw an exception.\n  if (err === UV_EACCES ||\n      err === UV_EAGAIN ||\n      err === UV_EMFILE ||\n      err === UV_ENFILE ||\n      err === UV_ENOENT) {\n    process.nextTick(onErrorNT\x2C this\x2C err);\n\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    if (err === UV_EMFILE || err === UV_ENFILE)\n      return err;\n  } else if (err) {\n    // Close all opened fds on error\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === 'pipe') {\n        stream.handle.close();\n      }\n    }\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err\x2C 'spawn');\n  } else {\n    process.nextTick(onSpawnNT\x2C this);\n  }\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === 'ignore') continue;\n\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n\n    // The stream is already cloned and piped\x2C thus stop its readable side\x2C\n    // otherwise we might attempt to read from the stream when at the same time\n    // the child process does.\n    if (stream.type === 'wrap') {\n      stream.handle.reading = false;\n      stream.handle.readStop();\n      stream._stdio.pause();\n      stream._stdio.readableFlowing = false;\n      stream._stdio._readableState.reading = false;\n      stream._stdio[kIsUsedAsStdio] = true;\n      continue;\n    }\n\n    if (stream.handle) {\n      // When i === 0 - we're dealing with stdin\n      // (which is the only one writable pipe).\n      stream.socket = createSocket(this.pid !== 0 ?\n        stream.handle : null\x2C i > 0);\n\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on('close'\x2C () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\n    stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\n    stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\n    stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i < stdio.length; i++)\n    ArrayPrototypePush(this.stdio\x2C\n                       stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  // Add .send() method and start listening for IPC data\n  if (ipc !== undefined) setupChannel(this\x2C ipc\x2C serialization);\n\n  return err;\n};\n\n\nfunction onErrorNT(self\x2C err) {\n  self._handle.onexit(err);\n}\n\n\nfunction onSpawnNT(self) {\n  self.emit('spawn');\n}\n\n\nChildProcess.prototype.kill = function(sig) {\n\n  const signal = sig === 0 ? sig :\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\n\n  if (this._handle) {\n    const err = this._handle.kill(signal);\n    if (err === 0) {\n      /* Success. */\n      this.killed = true;\n      return true;\n    }\n    if (err === UV_ESRCH) {\n      /* Already dead. */\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\n      /* The underlying platform doesn't support this signal. */\n      throw errnoException(err\x2C 'kill');\n    } else {\n      /* Other error\x2C almost certainly EPERM. */\n      this.emit('error'\x2C errnoException(err\x2C 'kill'));\n    }\n  }\n\n  /* Kill didn't succeed. */\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\nclass Control extends EventEmitter {\n  #channel = null;\n  #refs = 0;\n  #refExplicitlySet = false;\n\n  constructor(channel) {\n    super();\n    this.#channel = channel;\n  }\n\n  // The methods keeping track of the counter are being used to track the\n  // listener count on the child process object as well as when writes are\n  // in progress. Once the user has explicitly requested a certain state\x2C these\n  // methods become no-ops in order to not interfere with the user's intentions.\n  refCounted() {\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\n      this.#channel.ref();\n    }\n  }\n\n  unrefCounted() {\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\n      this.#channel.unref();\n      this.emit('unref');\n    }\n  }\n\n  ref() {\n    this.#refExplicitlySet = true;\n    this.#channel.ref();\n  }\n\n  unref() {\n    this.#refExplicitlySet = true;\n    this.#channel.unref();\n  }\n\n  get fd() {\n    return this.#channel ? this.#channel.fd : undefined;\n  }\n}\n\nconst channelDeprecationMsg = '_channel is deprecated. ' +\n                              'Use ChildProcess.channel instead.';\n\nlet serialization;\nfunction setupChannel(target\x2C channel\x2C serializationMode) {\n  const control = new Control(channel);\n  target.channel = control;\n  target[kChannelHandle] = channel;\n\n  ObjectDefineProperty(target\x2C '_channel'\x2C {\n    get: deprecate(() => {\n      return target.channel;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    set: deprecate((val) => {\n      target.channel = val;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n\n  target._handleQueue = null;\n  target._pendingMessage = null;\n\n  if (serialization === undefined)\n    serialization = require('internal/child_process/serialization');\n  const {\n    initMessageChannel\x2C\n    parseChannelMessages\x2C\n    writeChannelMessage\n  } = serialization[serializationMode];\n\n  let pendingHandle = null;\n  initMessageChannel(channel);\n  channel.pendingHandle = null;\n  channel.onread = function(arrayBuffer) {\n    const recvHandle = channel.pendingHandle;\n    channel.pendingHandle = null;\n    if (arrayBuffer) {\n      const nread = streamBaseState[kReadBytesOrError];\n      const offset = streamBaseState[kArrayBufferOffset];\n      const pool = new Uint8Array(arrayBuffer\x2C offset\x2C nread);\n      if (recvHandle)\n        pendingHandle = recvHandle;\n\n      for (const message of parseChannelMessages(channel\x2C pool)) {\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (isInternal(message)) {\n          if (message.cmd === 'NODE_HANDLE') {\n            handleMessage(message\x2C pendingHandle\x2C true);\n            pendingHandle = null;\n          } else {\n            handleMessage(message\x2C undefined\x2C true);\n          }\n        } else {\n          handleMessage(message\x2C undefined\x2C false);\n        }\n      }\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n\n  // Object where socket lists will live\n  channel.sockets = { got: {}\x2C send: {} };\n\n  // Handlers will go through this\n  target.on('internalMessage'\x2C function(message\x2C handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK' ||\n        message.cmd === 'NODE_HANDLE_NACK') {\n\n      if (target._pendingMessage) {\n        if (message.cmd === 'NODE_HANDLE_ACK') {\n          closePendingHandle(target);\n        } else if (target._pendingMessage.retransmissions++ ===\n                   MAX_HANDLE_RETRANSMISSIONS) {\n          closePendingHandle(target);\n          process.emitWarning('Handle did not reach the receiving process ' +\n                              'correctly'\x2C 'SentHandleNotReceivedWarning');\n        }\n      }\n\n      assert(ArrayIsArray(target._handleQueue));\n      const queue = target._handleQueue;\n      target._handleQueue = null;\n\n      if (target._pendingMessage) {\n        target._send(target._pendingMessage.message\x2C\n                     target._pendingMessage.handle\x2C\n                     target._pendingMessage.options\x2C\n                     target._pendingMessage.callback);\n      }\n\n      for (let i = 0; i < queue.length; i++) {\n        const args = queue[i];\n        target._send(args.message\x2C args.handle\x2C args.options\x2C args.callback);\n      }\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // It is possible that the handle is not received because of some error on\n    // ancillary data reception such as MSG_CTRUNC. In this case\x2C report the\n    // sender about it by sending a NODE_HANDLE_NACK message.\n    if (!handle)\n      return target._send({ cmd: 'NODE_HANDLE_NACK' }\x2C null\x2C true);\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }\x2C null\x2C true);\n\n    const obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle.setSimultaneousAccepts(false);\n    }\n\n    // Convert handle object\n    obj.got.call(this\x2C message\x2C handle\x2C (handle) => {\n      handleMessage(message.msg\x2C handle\x2C isInternal(message.msg));\n    });\n  });\n\n  target.send = function(message\x2C handle\x2C options\x2C callback) {\n    if (typeof handle === 'function') {\n      callback = handle;\n      handle = undefined;\n      options = undefined;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options !== undefined) {\n      validateObject(options\x2C 'options');\n    }\n\n    options = { swallowErrors: false\x2C ...options };\n\n    if (this.connected) {\n      return this._send(message\x2C handle\x2C options\x2C callback);\n    }\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n    } else {\n      process.nextTick(() => this.emit('error'\x2C ex));\n    }\n    return false;\n  };\n\n  target._send = function(message\x2C handle\x2C options\x2C callback) {\n    assert(this.connected || this.channel);\n\n    if (message === undefined)\n      throw new ERR_MISSING_ARGS('message');\n\n    // Non-serializable messages should not reach the remote\n    // end point; as any failure in the stringification there\n    // will result in error message that is weakly consumable.\n    // So perform a final check on message prior to sending.\n    if (typeof message !== 'string' &&\n        typeof message !== 'object' &&\n        typeof message !== 'number' &&\n        typeof message !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'message'\x2C ['string'\x2C 'object'\x2C 'number'\x2C 'boolean']\x2C message);\n    }\n\n    // Support legacy function signature\n    if (typeof options === 'boolean') {\n      options = { swallowErrors: options };\n    }\n\n    let obj;\n\n    // Package messages with a handle object\n    if (handle) {\n      // This message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE'\x2C\n        type: null\x2C\n        msg: message\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new ERR_INVALID_HANDLE_TYPE();\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        ArrayPrototypePush(this._handleQueue\x2C {\n          callback: callback\x2C\n          handle: handle\x2C\n          options: options\x2C\n          message: message.msg\x2C\n        });\n        return this._handleQueue.length === 1;\n      }\n\n      obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = ReflectApply(handleConversion[message.type].send\x2C\n                            target\x2C [message\x2C handle\x2C options]);\n\n      // If handle was sent twice\x2C or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts && process.platform === 'win32') {\n        handle.setSimultaneousAccepts(true);\n      }\n    } else if (this._handleQueue &&\n               !(message && (message.cmd === 'NODE_HANDLE_ACK' ||\n                             message.cmd === 'NODE_HANDLE_NACK'))) {\n      // Queue request anyway to avoid out-of-order messages.\n      ArrayPrototypePush(this._handleQueue\x2C {\n        callback: callback\x2C\n        handle: null\x2C\n        options: options\x2C\n        message: message\x2C\n      });\n      return this._handleQueue.length === 1;\n    }\n\n    const req = new WriteWrap();\n\n    const err = writeChannelMessage(channel\x2C req\x2C message\x2C handle);\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\n\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(message\x2C handle\x2C options\x2C callback\x2C target);\n      }\n\n      if (wasAsyncWrite) {\n        req.oncomplete = () => {\n          control.unrefCounted();\n          if (typeof callback === 'function')\n            callback(null);\n        };\n        control.refCounted();\n      } else if (typeof callback === 'function') {\n        process.nextTick(callback\x2C null);\n      }\n    } else {\n      // Cleanup handle on error\n      if (obj && obj.postSend)\n        obj.postSend(message\x2C handle\x2C options\x2C callback);\n\n      if (!options.swallowErrors) {\n        const ex = errnoException(err\x2C 'write');\n        if (typeof callback === 'function') {\n          process.nextTick(callback\x2C ex);\n        } else {\n          process.nextTick(() => this.emit('error'\x2C ex));\n        }\n      }\n    }\n\n    /* If the primary is > 2 read() calls behind\x2C please stop sending. */\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // Connected will be set to false immediately when a disconnect() is\n  // requested\x2C even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: channel is not null and connected\n  //   is true\n  // - disconnect() requested\x2C messages in the queue: channel is not null\n  //   and connected is false\n  // - disconnect() requested\x2C channel actually disconnected: channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error'\x2C new ERR_IPC_DISCONNECTED());\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages\x2C disconnect immediately. Otherwise\x2C\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this.channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this.channel = null;\n    this[kChannelHandle] = null;\n\n    if (this._pendingMessage)\n      closePendingHandle(this);\n\n    let fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read\x2C then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message'\x2C finish);\n      this.once('internalMessage'\x2C finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  function emit(event\x2C message\x2C handle) {\n    target.emit(event\x2C message\x2C handle);\n  }\n\n  function handleMessage(message\x2C handle\x2C internal) {\n    if (!target.channel)\n      return;\n\n    const eventName = (internal ? 'internalMessage' : 'message');\n\n    process.nextTick(emit\x2C eventName\x2C message\x2C handle);\n  }\n\n  channel.readStart();\n  return control;\n}\n\nconst INTERNAL_PREFIX = 'NODE_';\nfunction isInternal(message) {\n  return (message !== null &&\n          typeof message === 'object' &&\n          typeof message.cmd === 'string' &&\n          message.cmd.length > INTERNAL_PREFIX.length &&\n          StringPrototypeSlice(message.cmd\x2C 0\x2C INTERNAL_PREFIX.length) ===\n            INTERNAL_PREFIX);\n}\n\nconst nop = FunctionPrototype;\n\nfunction getValidStdio(stdio\x2C sync) {\n  let ipc;\n  let ipcFd;\n\n  // Replace shortcut with an array\n  if (typeof stdio === 'string') {\n    stdio = stdioStringToArray(stdio);\n  } else if (!ArrayIsArray(stdio)) {\n    throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse\x2C and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See https://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) ArrayPrototypePush(stdio\x2C undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = ArrayPrototypeReduce(stdio\x2C (acc\x2C stdio\x2C i) => {\n    function cleanup() {\n      for (let i = 0; i < acc.length; i++) {\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    // Defaults\n    if (stdio == null) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === 'ignore') {\n      ArrayPrototypePush(acc\x2C { type: 'ignore' });\n    } else if (stdio === 'pipe' || stdio === 'overlapped' ||\n               (typeof stdio === 'number' && stdio < 0)) {\n      const a = {\n        type: stdio === 'overlapped' ? 'overlapped' : 'pipe'\x2C\n        readable: i === 0\x2C\n        writable: i !== 0\n      };\n\n      if (!sync)\n        a.handle = new Pipe(PipeConstants.SOCKET);\n\n      ArrayPrototypePush(acc\x2C a);\n    } else if (stdio === 'ipc') {\n      if (sync || ipc !== undefined) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw new ERR_IPC_ONE_PIPE();\n        else\n          throw new ERR_IPC_SYNC_FORK();\n      }\n\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'pipe'\x2C\n        handle: ipc\x2C\n        ipc: true\n      });\n    } else if (stdio === 'inherit') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'inherit'\x2C\n        fd: i\n      });\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'fd'\x2C\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      const handle = getHandleWrapType(stdio) ?\n        stdio :\n        getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'wrap'\x2C\n        wrapType: getHandleWrapType(handle)\x2C\n        handle: handle\x2C\n        _stdio: stdio\n      });\n    } else if (isArrayBufferView(stdio) || typeof stdio === 'string') {\n      if (!sync) {\n        cleanup();\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n    }\n\n    return acc;\n  }\x2C []);\n\n  return { stdio\x2C ipc\x2C ipcFd };\n}\n\n\nfunction getSocketList(type\x2C worker\x2C key) {\n  const sockets = worker[kChannelHandle].sockets[type];\n  let socketList = sockets[key];\n  if (!socketList) {\n    const Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(worker\x2C key);\n  }\n  return socketList;\n}\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit('close'\x2C subprocess.exitCode\x2C subprocess.signalCode);\n  }\n}\n\nfunction spawnSync(options) {\n  const result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\n    for (let i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error) {\n    result.error = errnoException(result.error\x2C 'spawnSync ' + options.file);\n    result.error.path = options.file;\n    result.error.spawnargs = ArrayPrototypeSlice(options.args\x2C 1);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  ChildProcess\x2C\n  kChannelHandle\x2C\n  setupChannel\x2C\n  getValidStdio\x2C\n  stdioStringToArray\x2C\n  spawnSync\n};\n
code-source-info,0x3157a91f5616,119,0,30803,C0O0C4O30803,,
code-creation,Function,10,136086,0x3157a91f6c26,1253, node:internal/child_process:1:1,0x3157a91f5590,~
code-source-info,0x3157a91f6c26,119,0,30803,C0O0C293O25C299O41C305O63C311O87C317O110C322O131C328O156C334O180C339O204C345O220C351O244C356O254C362O564C368O564C373O294C384O325C390O351C396O378C402O407C408O440C414O468C420O494C426O516C432O539C438O674C444O674C449O602C455O619C461O637C467O654C473O727C479O727C483O727C485O758C491O758C495O758C497O788C503O788C507O788C509O822C515O822C520O854C524O822C526O879C532O879C536O879C538O928C541O928C546O916C552O1069C555O1069C560O971C566O984C572O1005C578O1027C584O1049C590O1144C593O1144C598O1109C604O1126C610O1190C613O1190C618O1182C624O1235C627O1235C632O1227C638O1280C641O1280C646O1272C652O1328C658O1328C663O1386C669O1386C674O1417C679O1369C685O1471C691O1471C696O1435C702O1457C708O1527C714O1527C719O1505C725O1578C728O1578C732O1578C734O1634C740O1634C745O1617C751O1776C754O1776C759O1672C765O1685C771O1698C777O1711C783O1724C789O1737C795O1750C801O1763C807O1808C813O1824C819O1980C820O1980C822O1996C823O1996C825O2044C827O2044C829O2070C832O2070C836O2070C838O2119C841O2119C845O2119C847O2270C852O2288C857O2326C865O2392C879O2469C884O2507C892O2581C906O2745C911O2751C919O4312C927O5065C941O5545C946O5584C954O5650C968O5729C973O5768C981O5895C997O2270C999O7893C1007O7917C1012O7859C1017O7929C1020O7929C1025O8936C1034O8952C1038O12752C1047O12767C1051O13451C1060O13465C1064O13538C1073O13554C1125O13637C1181O13615C1183O14611C1188O14638C1191O14611C1193O14712C1194O14712C1196O26213C1198O26213C1200O26546C1202O26546C1204O30680C1211O30701C1217O30717C1223O30735C1229O30751C1235O30768C1241O30790C1247O30695C1252O30802,,
code-creation,Function,10,136217,0x3157a91f738e,35,<instance_members_initializer> node:internal/child_process:524:3,0x3157a91f62f0,~
code-source-info,0x3157a91f738e,119,13654,13711,C3O13665C16O13681C26O13706C34O13711,,
tick,0x7ff803df1f1c,136252,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803d551c3,136299,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803df1e83,136318,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x1074fbaf1,137378,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e11,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
new,MemoryChunk,0x315766f80000,262144
code-creation,Eval,10,137612,0x3157a91fb4ce,5, node:net:1:1,0x3157a91facf0,~
script-source,120,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  Boolean\x2C\n  Error\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  uvExceptionWithHostPort\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n} = require('internal/dtrace');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\n\nconst { clearTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode'\x2C\n      options.objectMode\x2C\n      'is not supported'\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`\x2C\n      options.readableObjectMode || options.writableObjectMode\x2C\n      'is not supported'\n    );\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kSetNoDelay] = false;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        value: 0\x2C writable: true\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed\x2C\n        self._readableState);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  // eslint-disable-next-line no-restricted-syntax\n  const er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  if (!this._handle) {\n    this.once('connect'\x2C\n              enable ? this.setNoDelay : () => this.setNoDelay(enable));\n    return this;\n  }\n\n  // Backwards compatibility: assume true when `enable` is omitted\n  const newValue = enable === undefined ? true : !!enable;\n  if (this._handle.setNoDelay && newValue !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = newValue;\n    this._handle.setNoDelay(newValue);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(setting\x2C msecs) {\n  if (!this._handle) {\n    this.once('connect'\x2C () => this.setKeepAlive(setting\x2C msecs));\n    return this;\n  }\n\n  if (this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting\x2C ~~(msecs / 1000));\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  get: function() {\n    return this.connecting;\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  get: function() {\n    return this._unrefTimer;\n  }\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    this._handle.close(() => {\n      debug('emit close');\n      this.emit('close'\x2C isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    this._peername = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getpeername(this._peername);\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address\x2C afterConnect);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  }\n}\n\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort } = options;\n  const host = options.host || 'localhost';\n  let { port } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n    });\n    return;\n  }\n\n  if (options.lookup !== undefined)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: options.family\x2C\n    hints: options.hints || 0\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n      }\n    });\n  });\n}\n\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  let self = handle[owner_symbol];\n\n  if (self.constructor.name === 'ReusedHandle') {\n    self = self.handle;\n  }\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n\n  } else {\n    self.connecting = false;\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n  };\n\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C pipeName\x2C -1\x2C -1\x2C\n                    backlog\x2C undefined\x2C options.exclusive);\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\n  });\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n};\n
code-source-info,0x3157a91fb4ce,120,0,47747,C0O0C4O47747,,
code-creation,Function,10,142143,0x3157a91fe39e,2513, node:net:1:1,0x3157a91fb448,~
code-source-info,0x3157a91fe39e,120,0,47747,C0O0C411O1159C417O1175C423O1200C429O1211C435O1220C441O1230C447O1245C453O1263C459O1287C464O1311C469O1358C475O1358C479O1358C481O1392C487O1392C491O1392C493O1423C499O1423C504O1456C518O1457C524O1423C526O1581C532O1581C537O1511C543O1519C548O1529C553O1539C559O1563C565O1621C571O1621C575O1621C577O1705C580O1705C585O1659C591O1676C597O1689C603O1748C609O1748C614O1737C620O1795C623O1795C628O1775C634O1845C637O1845C642O1828C648O1940C651O1940C656O1887C662O1894C668O1923C674O2035C677O2035C682O1979C688O1987C694O2017C700O2166C706O2166C711O2075C717O2089C728O2130C734O2147C740O2364C746O2364C751O2209C757O2226C763O2242C769O2258C774O2278C780O2289C785O2305C790O2325C796O2336C802O2349C808O2744C814O2744C819O2744C824O2428C830O2460C836O2486C842O2513C848O2538C854O2566C860O2597C866O2625C872O2648C878O2673C884O2691C890O2716C896O2797C902O2797C907O2780C913O2952C919O2952C924O2839C930O2862C936O2882C942O2899C948O2917C954O2933C960O3012C963O3012C967O3012C969O3110C975O3110C980O3052C986O3084C992O3190C993O3190C995O3203C996O3203C998O3212C999O3212C1001O3227C1002O3227C1004O3268C1010O3268C1015O3251C1021O3308C1027O3308C1032O3295C1038O3363C1040O3363C1042O3400C1044O3400C1046O3425C1049O3433C1056O3442C1059O3425C1061O3469C1065O3469C1067O6921C1070O6921C1074O6921C1076O6965C1079O6965C1083O6965C1085O7010C1088O7010C1092O7010C1094O11101C1097O11129C1105O11147C1110O11154C1115O11101C1120O11166C1126O11202C1131O11166C1136O11242C1139O11249C1148O11271C1152O11497C1155O11504C1164O11521C1168O13067C1171O13074C1178O13095C1182O13117C1185O13124C1194O13145C1198O13655C1201O13662C1210O13683C1214O14138C1217O14145C1226O14168C1230O14421C1233O14428C1242O14446C1246O14496C1252O14524C1266O14559C1274O14496C1279O14609C1285O14637C1299O14663C1307O14609C1312O14748C1318O14776C1332O14810C1340O14748C1345O15132C1351O15160C1365O15194C1373O15132C1378O15280C1384O15308C1389O15319C1395O15342C1406O15280C1411O15707C1414O15714C1423O15730C1427O15965C1430O15972C1439O15986C1443O16179C1446O16186C1455O16202C1459O16542C1462O16549C1471O16566C1475O16756C1478O16763C1487O16778C1491O17115C1494O17122C1503O17144C1507O17297C1510O17304C1519O17323C1523O18282C1526O18289C1535O18312C1539O18773C1547O18773C1552O18893C1560O18893C1565O18992C1573O18992C1578O19088C1586O19088C1596O19179C1599O19186C1608O19209C1616O19491C1624O19491C1634O19589C1642O19589C1652O19678C1655O19685C1660O19695C1664O19713C1672O19765C1675O19772C1684O19796C1692O20563C1695O20570C1704O20588C1712O20662C1715O20669C1724O20686C1732O20930C1740O20930C1750O21070C1758O21070C1768O24542C1771O24549C1780O24567C1788O28968C1791O28975C1800O28989C1808O29182C1811O29189C1820O29205C1828O32017C1831O32045C1843O32069C1852O32017C1862O32081C1868O32081C1878O36067C1881O36074C1892O36093C1900O37541C1903O37548C1916O37565C1924O41522C1930O41550C1951O41583C1963O41522C1973O41674C1976O41681C1989O41699C1997O42769C2000O42776C2013O42801C2021O43560C2024O43567C2037O43583C2045O44455C2048O44462C2061O44492C2069O44970C2072O44977C2084O45000C2097O45024C2105O45342C2111O45367C2132O45391C2144O45431C2156O45342C2166O45478C2172O45506C2189O45532C2201O45567C2213O45478C2223O45609C2226O45616C2239O45639C2247O45885C2250O45892C2263O45906C2271O46009C2274O46016C2287O46032C2295O46140C2297O46195C2298O46195C2300O46202C2311O46225C2312O46225C2314O46249C2323O46957C2328O47229C2338O47271C2348O47309C2358O47326C2368O47585C2378O47614C2388O47625C2398O47647C2408O47663C2418O47681C2428O47691C2438O47701C2448O47719C2503O47244C2512O47746,,
tick,0x1070463ac,142441,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e11,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80ea8,142473,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e11,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803d76c84,142493,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e11,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x1070464ad,142527,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e11,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,142785,0x315766f85af6,5, node:internal/net:1:1,0x315766f85930,~
script-source,121,node:internal/net,'use strict';\n\nconst {\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n} = primordials;\n\nconst Buffer = require('buffer').Buffer;\nconst { writeBuffer } = internalBinding('fs');\nconst errors = require('internal/errors');\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\nconst IPv6Reg = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\n\nfunction isIPv4(s) {\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\n}\n\nfunction isIPv6(s) {\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nfunction makeSyncWrite(fd) {\n  return function(chunk\x2C enc\x2C cb) {\n    if (enc !== 'buffer')\n      chunk = Buffer.from(chunk\x2C enc);\n\n    this._handle.bytesWritten += chunk.length;\n\n    const ctx = {};\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\n    if (ctx.errno !== undefined) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\n\nmodule.exports = {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  makeSyncWrite\x2C\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n
code-source-info,0x315766f85af6,121,0,1749,C0O0C4O1749,,
code-creation,Function,10,142985,0x315766f85ee6,617, node:internal/net:1:1,0x315766f85a70,~
code-source-info,0x315766f85ee6,121,0,1749,C0O0C45O25C50O35C56O58C61O99C64O99C69O116C73O99C75O149C78O149C83O133C89O187C92O187C96O187C98O246C101O316C106O320C119O335C124O360C129O375C142O360C147O360C149O417C152O457C160O483C173O499C183O473C192O521C205O537C218O547C228O511C237O569C250O586C263O597C273O559C282O625C295O643C308O658C321O669C331O615C340O697C353O715C366O730C379O741C389O687C398O769C411O787C424O802C437O813C447O759C456O841C469O859C482O874C495O885C505O831C514O919C527O934C540O947C550O903C556O965C562O457C567O457C569O1633C576O1654C582O1662C588O1672C594O1682C601O1721C611O1648C616O1748,,
code-creation,Eval,10,143323,0x315766f87726,5, node:internal/dtrace:1:1,0x315766f875e0,~
script-source,122,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n};\n
code-source-info,0x315766f87726,122,0,568,C0O0C4O568,,
code-creation,Function,10,143454,0x315766f87bfe,140, node:internal/dtrace:1:1,0x315766f876a0,~
code-source-info,0x315766f87bfe,122,0,568,C0O30C3O30C8O322C17O334C25O68C36O109C47O151C58O192C69O234C80O277C91O368C98O389C104O419C110O450C116O480C122O511C128O543C134O383C139O567,,
tick,0x7ff803e80c81,143501,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91fe76d,0x10f8c4be3,0x10f8c4865,0x3157a91f6e11,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,143730,0x315766f88a8e,34,protoGetter node:net:718:21,0x3157a91fb910,~
code-source-info,0x315766f88a8e,120,18631,18771,C0O18652C8O18680C13O18691C20O18755C27O18652C33O18770,,
code-creation,Eval,10,144537,0x315766f8dc86,5, node:dgram:1:1,0x315766f8d710,~
script-source,123,node:dgram,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\x2C\n} = require('internal/dgram');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MISSING_ARGS\x2C\n  ERR_SOCKET_ALREADY_BOUND\x2C\n  ERR_SOCKET_BAD_BUFFER_SIZE\x2C\n  ERR_SOCKET_BUFFER_SIZE\x2C\n  ERR_SOCKET_DGRAM_IS_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_RUNNING\x2C\n  ERR_INVALID_FD_TYPE\n} = errors.codes;\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateString\x2C\n  validateNumber\x2C\n  validatePort\x2C\n} = require('internal/validators');\nconst { Buffer } = require('buffer');\nconst { deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst EventEmitter = require('events');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst { UV_UDP_REUSEADDR } = internalBinding('constants').os;\n\nconst {\n  constants: { UV_UDP_IPV6ONLY }\x2C\n  UDP\x2C\n  SendWrap\n} = internalBinding('udp_wrap');\n\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\n\nconst CONNECT_STATE_DISCONNECTED = 0;\nconst CONNECT_STATE_CONNECTING = 1;\nconst CONNECT_STATE_CONNECTED = 2;\n\nconst RECV_BUFFER = true;\nconst SEND_BUFFER = false;\n\n// Lazily loaded\nlet _cluster = null;\nfunction lazyLoadCluster() {\n  if (!_cluster) _cluster = require('cluster');\n  return _cluster;\n}\n\nconst errnoException = errors.errnoException;\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\n\n\nfunction Socket(type\x2C listener) {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n  let lookup;\n  let recvBufferSize;\n  let sendBufferSize;\n\n  let options;\n  if (type !== null && typeof type === 'object') {\n    options = type;\n    type = options.type;\n    lookup = options.lookup;\n    recvBufferSize = options.recvBufferSize;\n    sendBufferSize = options.sendBufferSize;\n  }\n\n  const handle = newHandle(type\x2C lookup);\n  handle[owner_symbol] = this;\n\n  this[async_id_symbol] = handle.getAsyncId();\n  this.type = type;\n\n  if (typeof listener === 'function')\n    this.on('message'\x2C listener);\n\n  this[kStateSymbol] = {\n    handle\x2C\n    receiving: false\x2C\n    bindState: BIND_STATE_UNBOUND\x2C\n    connectState: CONNECT_STATE_DISCONNECTED\x2C\n    queue: undefined\x2C\n    reuseAddr: options && options.reuseAddr\x2C // Use UV_UDP_REUSEADDR if true.\n    ipv6Only: options && options.ipv6Only\x2C\n    recvBufferSize\x2C\n    sendBufferSize\n  };\n\n  if (options?.signal !== undefined) {\n    const { signal } = options;\n    validateAbortSignal(signal\x2C 'options.signal');\n    const onAborted = () => {\n      this.close();\n    };\n    if (signal.aborted) {\n      onAborted();\n    } else {\n      signal.addEventListener('abort'\x2C onAborted);\n      this.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n}\nObjectSetPrototypeOf(Socket.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Socket\x2C EventEmitter);\n\n\nfunction createSocket(type\x2C listener) {\n  return new Socket(type\x2C listener);\n}\n\n\nfunction startListening(socket) {\n  const state = socket[kStateSymbol];\n\n  state.handle.onmessage = onMessage;\n  // Todo: handle errors\n  state.handle.recvStart();\n  state.receiving = true;\n  state.bindState = BIND_STATE_BOUND;\n\n  if (state.recvBufferSize)\n    bufferSize(socket\x2C state.recvBufferSize\x2C RECV_BUFFER);\n\n  if (state.sendBufferSize)\n    bufferSize(socket\x2C state.sendBufferSize\x2C SEND_BUFFER);\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self\x2C newHandle) {\n  const state = self[kStateSymbol];\n  const oldHandle = state.handle;\n\n  // Set up the handle that we got from primary.\n  newHandle.lookup = oldHandle.lookup;\n  newHandle.bind = oldHandle.bind;\n  newHandle.send = oldHandle.send;\n  newHandle[owner_symbol] = self;\n\n  // Replace the existing handle by the handle we got from primary.\n  oldHandle.close();\n  state.handle = newHandle;\n  // Check if the udp handle was connected and set the state accordingly\n  if (isConnected(self))\n    state.connectState = CONNECT_STATE_CONNECTED;\n}\n\nfunction bufferSize(self\x2C size\x2C buffer) {\n  if (size >>> 0 !== size)\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n\n  const ctx = {};\n  const ret = self[kStateSymbol].handle.bufferSize(size\x2C buffer\x2C ctx);\n  if (ret === undefined) {\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n  }\n  return ret;\n}\n\n// Query primary process to get the server handle and utilize it.\nfunction bindServerHandle(self\x2C options\x2C errCb) {\n  const cluster = lazyLoadCluster();\n\n  const state = self[kStateSymbol];\n  cluster._getServer(self\x2C options\x2C (err\x2C handle) => {\n    if (err) {\n      errCb(err);\n      return;\n    }\n\n    if (!state.handle) {\n      // Handle has been closed in the mean time.\n      return handle.close();\n    }\n\n    replaceHandle(self\x2C handle);\n    startListening(self);\n  });\n}\n\nSocket.prototype.bind = function(port_\x2C address_ /* \x2C callback */) {\n  let port = port_;\n\n  healthCheck(this);\n  const state = this[kStateSymbol];\n\n  if (state.bindState !== BIND_STATE_UNBOUND)\n    throw new ERR_SOCKET_ALREADY_BOUND();\n\n  state.bindState = BIND_STATE_BINDING;\n\n  const cb = arguments.length && arguments[arguments.length - 1];\n  if (typeof cb === 'function') {\n    function removeListeners() {\n      this.removeListener('error'\x2C removeListeners);\n      this.removeListener('listening'\x2C onListening);\n    }\n\n    function onListening() {\n      FunctionPrototypeCall(removeListeners\x2C this);\n      FunctionPrototypeCall(cb\x2C this);\n    }\n\n    this.on('error'\x2C removeListeners);\n    this.on('listening'\x2C onListening);\n  }\n\n  if (port !== null &&\n      typeof port === 'object' &&\n      typeof port.recvStart === 'function') {\n    replaceHandle(this\x2C port);\n    startListening(this);\n    return this;\n  }\n\n  // Open an existing fd instead of creating a new one.\n  if (port !== null && typeof port === 'object' &&\n      isInt32(port.fd) && port.fd > 0) {\n    const fd = port.fd;\n    const exclusive = !!port.exclusive;\n    const state = this[kStateSymbol];\n\n    const cluster = lazyLoadCluster();\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: null\x2C\n        port: null\x2C\n        addressType: this.type\x2C\n        fd\x2C\n        flags: null\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = errnoException(err\x2C 'open');\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n      return this;\n    }\n\n    const type = guessHandleType(fd);\n    if (type !== 'UDP')\n      throw new ERR_INVALID_FD_TYPE(type);\n    const err = state.handle.open(fd);\n\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    // Check if the udp handle was connected and set the state accordingly\n    if (isConnected(this))\n      state.connectState = CONNECT_STATE_CONNECTED;\n\n    startListening(this);\n    return this;\n  }\n\n  let address;\n  let exclusive;\n\n  if (port !== null && typeof port === 'object') {\n    address = port.address || '';\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === 'function' ? '' : address_;\n    exclusive = false;\n  }\n\n  // Defaulting address for bind to all interfaces\n  if (!address) {\n    if (this.type === 'udp4')\n      address = '0.0.0.0';\n    else\n      address = '::';\n  }\n\n  // Resolve address first\n  state.handle.lookup(address\x2C (err\x2C ip) => {\n    if (err) {\n      state.bindState = BIND_STATE_UNBOUND;\n      this.emit('error'\x2C err);\n      return;\n    }\n\n    const cluster = lazyLoadCluster();\n\n    let flags = 0;\n    if (state.reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n    if (state.ipv6Only)\n      flags |= UV_UDP_IPV6ONLY;\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: ip\x2C\n        port: port\x2C\n        addressType: this.type\x2C\n        fd: -1\x2C\n        flags: flags\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n    } else {\n      if (!state.handle)\n        return; // Handle has been closed in the mean time\n\n      const err = state.handle.bind(ip\x2C port || 0\x2C flags);\n      if (err) {\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n        // Todo: close?\n        return;\n      }\n\n      startListening(this);\n    }\n  });\n\n  return this;\n};\n\nSocket.prototype.connect = function(port\x2C address\x2C callback) {\n  port = validatePort(port\x2C 'Port'\x2C false);\n  if (typeof address === 'function') {\n    callback = address;\n    address = '';\n  } else if (address === undefined) {\n    address = '';\n  }\n\n  validateString(address\x2C 'address');\n\n  const state = this[kStateSymbol];\n\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n\n  state.connectState = CONNECT_STATE_CONNECTING;\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(_connect\x2C this\x2C\n                                        port\x2C address\x2C callback));\n    return;\n  }\n\n  ReflectApply(_connect\x2C this\x2C [port\x2C address\x2C callback]);\n};\n\n\nfunction _connect(port\x2C address\x2C callback) {\n  const state = this[kStateSymbol];\n  if (callback)\n    this.once('connect'\x2C callback);\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doConnect\x2C\n      ex\x2C this\x2C ip\x2C address\x2C port\x2C callback\n    );\n  };\n\n  state.handle.lookup(address\x2C afterDns);\n}\n\n\nfunction doConnect(ex\x2C self\x2C ip\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n  if (!state.handle)\n    return;\n\n  if (!ex) {\n    const err = state.handle.connect(ip\x2C port);\n    if (err) {\n      ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port);\n    }\n  }\n\n  if (ex) {\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n    return process.nextTick(() => {\n      if (callback) {\n        self.removeListener('connect'\x2C callback);\n        callback(ex);\n      } else {\n        self.emit('error'\x2C ex);\n      }\n    });\n  }\n\n  state.connectState = CONNECT_STATE_CONNECTED;\n  process.nextTick(() => self.emit('connect'));\n}\n\n\nSocket.prototype.disconnect = function() {\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const err = state.handle.disconnect();\n  if (err)\n    throw errnoException(err\x2C 'connect');\n  else\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n};\n\n\n// Thin wrapper around `send`\x2C here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer\x2C\n                                   offset\x2C\n                                   length\x2C\n                                   port\x2C\n                                   address\x2C\n                                   callback) {\n  validateNumber(offset\x2C 'offset');\n  validateNumber(length\x2C 'length');\n  validateNumber(port\x2C 'port');\n  validateString(address\x2C 'address');\n\n  this.send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback);\n};\n\n\nfunction sliceBuffer(buffer\x2C offset\x2C length) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  offset = offset >>> 0;\n  length = length >>> 0;\n  if (offset > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n  }\n\n  if (offset + length > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n  }\n\n  return Buffer.from(buffer.buffer\x2C buffer.byteOffset + offset\x2C length);\n}\n\n\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n\n  for (let i = 0\x2C l = list.length; i < l; i++) {\n    const buf = list[i];\n    if (typeof buf === 'string')\n      newlist[i] = Buffer.from(buf);\n    else if (!isArrayBufferView(buf))\n      return null;\n    else\n      newlist[i] = Buffer.from(buf.buffer\x2C buf.byteOffset\x2C buf.byteLength);\n  }\n\n  return newlist;\n}\n\n\nfunction enqueue(self\x2C toEnqueue) {\n  const state = self[kStateSymbol];\n\n  // If the send queue hasn't been initialized yet\x2C do it\x2C and install an\n  // event handler that flushes the send queue after binding is done.\n  if (state.queue === undefined) {\n    state.queue = [];\n    self.once(EventEmitter.errorMonitor\x2C onListenError);\n    self.once('listening'\x2C onListenSuccess);\n  }\n  ArrayPrototypePush(state.queue\x2C toEnqueue);\n}\n\n\nfunction onListenSuccess() {\n  this.removeListener(EventEmitter.errorMonitor\x2C onListenError);\n  FunctionPrototypeCall(clearQueue\x2C this);\n}\n\n\nfunction onListenError(err) {\n  this.removeListener('listening'\x2C onListenSuccess);\n  this[kStateSymbol].queue = undefined;\n}\n\n\nfunction clearQueue() {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  state.queue = undefined;\n\n  // Flush the send queue.\n  for (const queueEntry of queue)\n    queueEntry();\n}\n\nfunction isConnected(self) {\n  try {\n    self.remoteAddress();\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n\n// valid combinations\n// For connectionless sockets\n// send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port\x2C address)\n// send(buffer\x2C offset\x2C length\x2C port\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port)\n// send(bufferOrList\x2C port\x2C address\x2C callback)\n// send(bufferOrList\x2C port\x2C address)\n// send(bufferOrList\x2C port\x2C callback)\n// send(bufferOrList\x2C port)\n// For connected sockets\n// send(buffer\x2C offset\x2C length\x2C callback)\n// send(buffer\x2C offset\x2C length)\n// send(bufferOrList\x2C callback)\n// send(bufferOrList)\nSocket.prototype.send = function(buffer\x2C\n                                 offset\x2C\n                                 length\x2C\n                                 port\x2C\n                                 address\x2C\n                                 callback) {\n\n  let list;\n  const state = this[kStateSymbol];\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\n  if (!connected) {\n    if (address || (port && typeof port !== 'function')) {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n    } else {\n      callback = port;\n      port = offset;\n      address = length;\n    }\n  } else {\n    if (typeof length === 'number') {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n      if (typeof port === 'function') {\n        callback = port;\n        port = null;\n      }\n    } else {\n      callback = offset;\n    }\n\n    if (port || address)\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  }\n\n  if (!ArrayIsArray(buffer)) {\n    if (typeof buffer === 'string') {\n      list = [ Buffer.from(buffer) ];\n    } else if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                     ['Buffer'\x2C\n                                      'TypedArray'\x2C\n                                      'DataView'\x2C\n                                      'string']\x2C\n                                     buffer);\n    } else {\n      list = [ buffer ];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new ERR_INVALID_ARG_TYPE('buffer list arguments'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  if (!connected)\n    port = validatePort(port\x2C 'Port'\x2C false);\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (typeof callback !== 'function')\n    callback = undefined;\n\n  if (typeof address === 'function') {\n    callback = address;\n    address = undefined;\n  } else if (address && typeof address !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('address'\x2C ['string'\x2C 'falsy']\x2C address);\n  }\n\n  healthCheck(this);\n\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (list.length === 0)\n    ArrayPrototypePush(list\x2C Buffer.alloc(0));\n\n  // If the socket hasn't been bound yet\x2C push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(this.send\x2C this\x2C\n                                        list\x2C port\x2C address\x2C callback));\n    return;\n  }\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doSend\x2C\n      ex\x2C this\x2C ip\x2C list\x2C address\x2C port\x2C callback\n    );\n  };\n\n  if (!connected) {\n    state.handle.lookup(address\x2C afterDns);\n  } else {\n    afterDns(null\x2C null);\n  }\n};\n\nfunction doSend(ex\x2C self\x2C ip\x2C list\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n\n  if (ex) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n      return;\n    }\n\n    process.nextTick(() => self.emit('error'\x2C ex));\n    return;\n  } else if (!state.handle) {\n    return;\n  }\n\n  const req = new SendWrap();\n  req.list = list;  // Keep reference alive.\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n\n  let err;\n  if (port)\n    err = state.handle.send(req\x2C list\x2C list.length\x2C port\x2C ip\x2C !!callback);\n  else\n    err = state.handle.send(req\x2C list\x2C list.length\x2C !!callback);\n\n  if (err >= 1) {\n    // Synchronous finish. The return code is msg_length + 1 so that we can\n    // distinguish between synchronous success and asynchronous success.\n    if (callback)\n      process.nextTick(callback\x2C null\x2C err - 1);\n    return;\n  }\n\n  if (err && callback) {\n    // Don't emit as error\x2C dgram_legacy.js compatibility\n    const ex = exceptionWithHostPort(err\x2C 'send'\x2C address\x2C port);\n    process.nextTick(callback\x2C ex);\n  }\n}\n\nfunction afterSend(err\x2C sent) {\n  if (err) {\n    err = exceptionWithHostPort(err\x2C 'send'\x2C this.address\x2C this.port);\n  } else {\n    err = null;\n  }\n\n  this.callback(err\x2C sent);\n}\n\nSocket.prototype.close = function(callback) {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n\n  if (typeof callback === 'function')\n    this.on('close'\x2C callback);\n\n  if (queue !== undefined) {\n    ArrayPrototypePush(queue\x2C FunctionPrototypeBind(this.close\x2C this));\n    return this;\n  }\n\n  healthCheck(this);\n  stopReceiving(this);\n  state.handle.close();\n  state.handle = null;\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             socketCloseNT\x2C\n                             this);\n\n  return this;\n};\n\n\nfunction socketCloseNT(self) {\n  self.emit('close');\n}\n\n\nSocket.prototype.address = function() {\n  healthCheck(this);\n\n  const out = {};\n  const err = this[kStateSymbol].handle.getsockname(out);\n  if (err) {\n    throw errnoException(err\x2C 'getsockname');\n  }\n\n  return out;\n};\n\nSocket.prototype.remoteAddress = function() {\n  healthCheck(this);\n\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const out = {};\n  const err = state.handle.getpeername(out);\n  if (err)\n    throw errnoException(err\x2C 'getpeername');\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\n  healthCheck(this);\n  validateString(interfaceAddress\x2C 'interfaceAddress');\n\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastInterface');\n  }\n};\n\nSocket.prototype.addMembership = function(multicastAddress\x2C\n                                          interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.addMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress\x2C\n                                           interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.dropMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropMembership');\n  }\n};\n\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress\x2C\n                                                        groupAddress\x2C\n                                                        interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress\x2C\n                                                          groupAddress\x2C\n                                                          interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addSourceSpecificMembership');\n  }\n};\n\n\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress\x2C\n                                                         groupAddress\x2C\n                                                         interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress\x2C\n                                                           groupAddress\x2C\n                                                           interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropSourceSpecificMembership');\n  }\n};\n\n\nfunction healthCheck(socket) {\n  if (!socket[kStateSymbol].handle) {\n    // Error message from dgram_legacy.js.\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n  }\n}\n\n\nfunction stopReceiving(socket) {\n  const state = socket[kStateSymbol];\n\n  if (!state.receiving)\n    return;\n\n  state.handle.recvStop();\n  state.receiving = false;\n}\n\n\nfunction onMessage(nread\x2C handle\x2C buf\x2C rinfo) {\n  const self = handle[owner_symbol];\n  if (nread < 0) {\n    return self.emit('error'\x2C errnoException(nread\x2C 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message'\x2C buf\x2C rinfo);\n}\n\n\nSocket.prototype.ref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.unref();\n\n  return this;\n};\n\n\nSocket.prototype.setRecvBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.setSendBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C SEND_BUFFER);\n};\n\n\nSocket.prototype.getRecvBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.getSendBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C SEND_BUFFER);\n};\n\n\n// Deprecated private APIs.\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].handle;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].handle = val;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_receiving'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].receiving;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].receiving = val;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_bindState'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].bindState;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].bindState = val;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_queue'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].queue;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].queue = val;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_reuseAddr'\x2C {\n  get: deprecate(function() {\n    return this[kStateSymbol].reuseAddr;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].reuseAddr = val;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\n});\n\n\nSocket.prototype._healthCheck = deprecate(function() {\n  healthCheck(this);\n}\x2C 'Socket.prototype._healthCheck() is deprecated'\x2C 'DEP0112');\n\n\nSocket.prototype._stopReceiving = deprecate(function() {\n  stopReceiving(this);\n}\x2C 'Socket.prototype._stopReceiving() is deprecated'\x2C 'DEP0112');\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(UDP.prototype\x2C 'owner'\x2C {\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\n\nmodule.exports = {\n  _createSocketHandle: deprecate(\n    _createSocketHandle\x2C\n    'dgram._createSocketHandle() is deprecated'\x2C\n    'DEP0112'\n  )\x2C\n  createSocket\x2C\n  Socket\n};\n
code-source-info,0x315766f8dc86,123,0,27703,C0O0C4O27703,,
code-creation,Function,10,146969,0x315766f8fbee,1507, node:dgram:1:1,0x315766f8dc00,~
code-source-info,0x315766f8fbee,123,0,27703,C0O0C276O1159C282O1168C288O1184C294O1206C300O1231C306O1256C311O1280C316O1304C322O1351C328O1351C333O1443C339O1443C344O1389C350O1405C355O1428C361O1498C364O1498C369O1478C375O1819C380O1533C386O1561C392O1585C398O1605C404O1633C410O1663C416O1689C422O1722C428O1756C434O1788C440O1924C446O1924C451O1836C457O1847C463O1870C469O1888C475O1906C481O1975C487O1975C492O1964C498O2016C504O2016C509O2002C514O2072C520O2072C525O2050C531O2125C537O2125C541O2125C543O2231C549O2231C554O2154C565O2195C571O2212C577O2293C580O2293C585O2321C590O2272C596O2391C599O2391C604O2391C609O2350C615O2371C620O2378C626O2448C627O2448C629O2478C631O2478C633O2506C635O2506C637O2545C638O2545C640O2581C642O2581C644O2616C646O2616C648O2640C649O2640C651O2666C652O2666C654O2706C655O2706C657O2841C661O2834C663O2894C667O2887C669O4215C672O4243C680O4267C685O4215C690O4279C696O4279C701O6188C704O6195C713O6210C717O9811C720O9818C729O9836C733O11631C736O11638C745O11659C749O12047C752O12054C761O12071C765O15228C768O15235C777O15250C781O19527C784O19534C793O19550C797O20181C800O20188C809O20206C813O20401C816O20408C825O20432C829O20748C832O20755C841O20778C845O20932C848O20939C857O20956C861O21136C864O21143C873O21169C877O21367C880O21374C889O21405C893O21611C896O21618C905O21650C909O21917C912O21924C921O21948C925O22328C928O22335C937O22360C941O22742C944O22749C953O22787C957O23400C960O23407C969O23446C973O24655C976O24662C985O24676C989O24789C992O24796C1001O24812C1005O24927C1008O24934C1017O24962C1021O25025C1024O25032C1033O25060C1037O25123C1040O25130C1049O25158C1053O25221C1056O25228C1065O25256C1069O25347C1072O25375C1085O25406C1096O25406C1105O25533C1116O25533C1125O25347C1130O25660C1133O25688C1146O25722C1157O25722C1166O25855C1177O25855C1186O25660C1191O25988C1194O26016C1207O26050C1218O26050C1227O26183C1238O26183C1247O25988C1252O26316C1255O26344C1268O26374C1279O26374C1288O26499C1299O26499C1308O26316C1313O26624C1316O26652C1329O26686C1340O26686C1349O26819C1360O26819C1369O26624C1374O26952C1377O26959C1382O26984C1393O26984C1398O26982C1402O27094C1405O27101C1410O27128C1421O27128C1426O27126C1430O27417C1443O27441C1451O27481C1459O27392C1464O27529C1478O27571C1489O27677C1495O27693C1501O27544C1506O27702,,
tick,0x7ff803e80d7f,147197,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e1d,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803d55336,147225,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e1d,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803d51f6f,147242,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6e1d,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,147470,0x315766f930a6,5, node:internal/dgram:1:1,0x315766f92ea0,~
script-source,124,node:internal/dgram,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\nconst { UDP } = internalBinding('udp_wrap');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  isInt32\x2C\n  validateFunction\x2C\n} = require('internal/validators');\nconst { UV_EINVAL } = internalBinding('uv');\nconst {\n  ERR_SOCKET_BAD_TYPE\x2C\n} = codes;\nconst kStateSymbol = Symbol('state symbol');\nlet dns;  // Lazy load for startup performance.\n\n\nfunction lookup4(lookup\x2C address\x2C callback) {\n  return lookup(address || '127.0.0.1'\x2C 4\x2C callback);\n}\n\n\nfunction lookup6(lookup\x2C address\x2C callback) {\n  return lookup(address || '::1'\x2C 6\x2C callback);\n}\n\nfunction newHandle(type\x2C lookup) {\n  if (lookup === undefined) {\n    if (dns === undefined) {\n      dns = require('dns');\n    }\n\n    lookup = dns.lookup;\n  } else {\n    validateFunction(lookup\x2C 'lookup');\n  }\n\n  if (type === 'udp4') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup4\x2C handle\x2C lookup);\n    return handle;\n  }\n\n  if (type === 'udp6') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup6\x2C handle\x2C lookup);\n    handle.bind = handle.bind6;\n    handle.connect = handle.connect6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  throw new ERR_SOCKET_BAD_TYPE();\n}\n\n\nfunction _createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  const handle = newHandle(addressType);\n  let err;\n\n  if (isInt32(fd) && fd > 0) {\n    const type = guessHandleType(fd);\n    if (type !== 'UDP') {\n      err = UV_EINVAL;\n    } else {\n      err = handle.open(fd);\n    }\n  } else if (port || address) {\n    err = handle.bind(address\x2C port || 0\x2C flags);\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\n\nmodule.exports = {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\n};\n
code-source-info,0x315766f930a6,124,0,1849,C0O0C4O1849,,
code-creation,Function,10,147680,0x315766f9336e,196, node:internal/dgram:1:1,0x315766f93020,~
code-source-info,0x315766f9336e,124,0,1849,C0O0C56O25C62O50C67O94C73O94C78O84C83O138C86O138C91O130C97O195C100O195C105O175C111O263C117O263C122O230C128O241C134O317C137O317C142O303C148O350C154O403C157O403C162O431C163O431C165O1776C172O1797C178O1813C184O1836C190O1791C195O1848,,
code-creation,Eval,10,148051,0x315766f96eee,5, node:internal/socket_list:1:1,0x315766f96d98,~
script-source,125,node:internal/socket_list,'use strict';\n\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require('internal/errors').codes;\n\nconst EventEmitter = require('events');\n\n// This object keeps track of the sockets that are sent\nclass SocketListSend extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n    this.key = key;\n    this.child = child;\n    child.once('exit'\x2C () => this.emit('exit'\x2C this));\n  }\n\n  _request(msg\x2C cmd\x2C swallowErrors\x2C callback) {\n    const self = this;\n\n    if (!this.child.connected) return onclose();\n    this.child._send(msg\x2C undefined\x2C swallowErrors);\n\n    function onclose() {\n      self.child.removeListener('internalMessage'\x2C onreply);\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\n    }\n\n    function onreply(msg) {\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\n      self.child.removeListener('disconnect'\x2C onclose);\n      self.child.removeListener('internalMessage'\x2C onreply);\n\n      callback(null\x2C msg);\n    }\n\n    this.child.once('disconnect'\x2C onclose);\n    this.child.on('internalMessage'\x2C onreply);\n  }\n\n  close(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_ALL_CLOSED'\x2C true\x2C callback);\n  }\n\n  getConnections(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_GET_COUNT'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_COUNT'\x2C false\x2C (err\x2C msg) => {\n      if (err) return callback(err);\n      callback(null\x2C msg.count);\n    });\n  }\n}\n\n\n// This object keeps track of the sockets that are received\nclass SocketListReceive extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n\n    function onempty(self) {\n      if (!self.child.connected) return;\n\n      self.child._send({\n        cmd: 'NODE_SOCKET_ALL_CLOSED'\x2C\n        key: self.key\n      }\x2C undefined\x2C true);\n    }\n\n    this.child.on('internalMessage'\x2C (msg) => {\n      if (msg.key !== this.key) return;\n\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n        // Already empty\n        if (this.connections === 0) return onempty(this);\n\n        // Wait for sockets to get closed\n        this.once('empty'\x2C onempty);\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n        if (!this.child.connected) return;\n        this.child._send({\n          cmd: 'NODE_SOCKET_COUNT'\x2C\n          key: this.key\x2C\n          count: this.connections\n        });\n      }\n    });\n  }\n\n  add(obj) {\n    this.connections++;\n\n    // Notify the previous owner of the socket about its state change\n    obj.socket.once('close'\x2C () => {\n      this.connections--;\n\n      if (this.connections === 0) this.emit('empty'\x2C this);\n    });\n  }\n}\n\nmodule.exports = { SocketListSend\x2C SocketListReceive };\n
code-source-info,0x315766f96eee,125,0,2705,C0O0C4O2705,,
code-creation,Function,10,148294,0x315766f9752e,126, node:internal/socket_list:1:1,0x315766f96e68,~
code-source-info,0x315766f9752e,125,0,2705,C0O0C8O57C11O57C16O83C21O23C27O113C30O113C35O218C73O1525C101O2649C108O2668C114O2684C120O2664C125O2704,,
tick,0x10810b77c,148374,1,0x10712a580,6,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91f6eb8,0x10f8c4be3,0x10f8c4865,0x3157a91f034a,0x10f8c4be3,0x10f8c4865,0x3157a91ed8a1,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,148539,0x315766f98146,14,customPromiseExecFunction node:child_process:231:35,0x3157a91efc88,~
code-source-info,0x315766f98146,118,6605,6969,C0O6605C9O6619C13O6967,,
code-creation,Eval,10,148706,0x315766f9a326,5, node:internal/cluster/round_robin_handle:1:1,0x315766f9a150,~
script-source,126,node:internal/cluster/round_robin_handle,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  Boolean\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst assert = require('internal/assert');\nconst net = require('net');\nconst { sendHelper } = require('internal/cluster/utils');\nconst { constants } = internalBinding('tcp_wrap');\n\nmodule.exports = RoundRobinHandle;\n\nfunction RoundRobinHandle(key\x2C address\x2C { port\x2C fd\x2C flags }) {\n  this.key = key;\n  this.all = new SafeMap();\n  this.free = new SafeMap();\n  this.handles = [];\n  this.handle = null;\n  this.server = net.createServer(assert.fail);\n\n  if (fd >= 0)\n    this.server.listen({ fd });\n  else if (port >= 0) {\n    this.server.listen({\n      port\x2C\n      host: address\x2C\n      // Currently\x2C net module only supports `ipv6Only` option in `flags`.\n      ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY)\x2C\n    });\n  } else\n    this.server.listen(address);  // UNIX socket path.\n\n  this.server.once('listening'\x2C () => {\n    this.handle = this.server._handle;\n    this.handle.onconnection = (err\x2C handle) => this.distribute(err\x2C handle);\n    this.server._handle = null;\n    this.server = null;\n  });\n}\n\nRoundRobinHandle.prototype.add = function(worker\x2C send) {\n  assert(this.all.has(worker.id) === false);\n  this.all.set(worker.id\x2C worker);\n\n  const done = () => {\n    if (this.handle.getsockname) {\n      const out = {};\n      this.handle.getsockname(out);\n      // TODO(bnoordhuis) Check err.\n      send(null\x2C { sockname: out }\x2C null);\n    } else {\n      send(null\x2C null\x2C null);  // UNIX socket.\n    }\n\n    this.handoff(worker);  // In case there are connections pending.\n  };\n\n  if (this.server === null)\n    return done();\n\n  // Still busy binding.\n  this.server.once('listening'\x2C done);\n  this.server.once('error'\x2C (err) => {\n    send(err.errno\x2C null);\n  });\n};\n\nRoundRobinHandle.prototype.remove = function(worker) {\n  const existed = this.all.delete(worker.id);\n\n  if (!existed)\n    return false;\n\n  this.free.delete(worker.id);\n\n  if (this.all.size !== 0)\n    return false;\n\n  for (const handle of this.handles) {\n    handle.close();\n  }\n  this.handles = [];\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n\nRoundRobinHandle.prototype.distribute = function(err\x2C handle) {\n  ArrayPrototypePush(this.handles\x2C handle);\n  // eslint-disable-next-line node-core/no-array-destructuring\n  const [ workerEntry ] = this.free; // this.free is a SafeMap\n\n  if (ArrayIsArray(workerEntry)) {\n    const { 0: workerId\x2C 1: worker } = workerEntry;\n    this.free.delete(workerId);\n    this.handoff(worker);\n  }\n};\n\nRoundRobinHandle.prototype.handoff = function(worker) {\n  if (!this.all.has(worker.id)) {\n    return;  // Worker is closing (or has closed) the server.\n  }\n\n  const handle = ArrayPrototypeShift(this.handles);\n\n  if (handle === undefined) {\n    this.free.set(worker.id\x2C worker);  // Add to ready queue again.\n    return;\n  }\n\n  const message = { act: 'newconn'\x2C key: this.key };\n\n  sendHelper(worker.process\x2C message\x2C handle\x2C (reply) => {\n    if (reply.accepted)\n      handle.close();\n    else\n      this.distribute(0\x2C handle);  // Worker is shutting down. Send to another.\n\n    this.handoff(worker);\n  });\n};\n
code-source-info,0x315766f9a326,126,0,3155,C0O0C4O3155,,
code-creation,Function,10,148972,0x315766f9a6ce,173, node:internal/cluster/round_robin_handle:1:1,0x315766f9a2a0,~
code-source-info,0x315766f9a6ce,126,0,3155,C0O0C37O25C43O41C49O63C55O86C61O97C67O139C70O139C74O139C76O179C79O179C83O179C85O218C88O218C93O203C99O275C102O275C107O261C113O305C115O320C119O1146C128O1160C132O1811C141O1828C145O2175C154O2196C158O2563C167O2581C172O3154,,
code-creation,Eval,10,149128,0x315766f9af8e,5, node:internal/cluster/utils:1:1,0x315766f9ae18,~
script-source,127,node:internal/cluster/utils,'use strict';\n\nconst {\n  ReflectApply\x2C\n  SafeMap\x2C\n} = primordials;\n\nmodule.exports = {\n  sendHelper\x2C\n  internal\n};\n\nconst callbacks = new SafeMap();\nlet seq = 0;\n\nfunction sendHelper(proc\x2C message\x2C handle\x2C cb) {\n  if (!proc.connected)\n    return false;\n\n  // Mark message as internal. See INTERNAL_PREFIX\n  // in lib/internal/child_process.js\n  message = { cmd: 'NODE_CLUSTER'\x2C ...message\x2C seq };\n\n  if (typeof cb === 'function')\n    callbacks.set(seq\x2C cb);\n\n  seq += 1;\n  return proc.send(message\x2C handle);\n}\n\n// Returns an internalMessage listener that hands off normal messages\n// to the callback but intercepts and redirects ACK messages.\nfunction internal(worker\x2C cb) {\n  return function onInternalMessage(message\x2C handle) {\n    if (message.cmd !== 'NODE_CLUSTER')\n      return;\n\n    let fn = cb;\n\n    if (message.ack !== undefined) {\n      const callback = callbacks.get(message.ack);\n\n      if (callback !== undefined) {\n        fn = callback;\n        callbacks.delete(message.ack);\n      }\n    }\n\n    ReflectApply(fn\x2C worker\x2C arguments);\n  };\n}\n
code-source-info,0x315766f9af8e,127,0,1053,C0O0C4O1053,,
code-creation,Function,10,149240,0x315766f9b14e,72, node:internal/cluster/utils:1:1,0x315766f9af08,~
code-source-info,0x315766f9b14e,127,0,1053,C0O0C24O25C30O41C35O68C42O89C48O103C54O83C58O134C60O134C65O134C67O159C68O159C71O1052,,
code-creation,Eval,10,149370,0x315766f9b75e,5, node:internal/cluster/shared_handle:1:1,0x315766f9b5d8,~
script-source,128,node:internal/cluster/shared_handle,'use strict';\nconst { SafeMap } = primordials;\nconst assert = require('internal/assert');\nconst dgram = require('internal/dgram');\nconst net = require('net');\n\nmodule.exports = SharedHandle;\n\nfunction SharedHandle(key\x2C address\x2C { port\x2C addressType\x2C fd\x2C flags }) {\n  this.key = key;\n  this.workers = new SafeMap();\n  this.handle = null;\n  this.errno = 0;\n\n  let rval;\n  if (addressType === 'udp4' || addressType === 'udp6')\n    rval = dgram._createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n  else\n    rval = net._createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n  if (typeof rval === 'number')\n    this.errno = rval;\n  else\n    this.handle = rval;\n}\n\nSharedHandle.prototype.add = function(worker\x2C send) {\n  assert(!this.workers.has(worker.id));\n  this.workers.set(worker.id\x2C worker);\n  send(this.errno\x2C null\x2C this.handle);\n};\n\nSharedHandle.prototype.remove = function(worker) {\n  if (!this.workers.has(worker.id))\n    return false;\n\n  this.workers.delete(worker.id);\n\n  if (this.workers.size !== 0)\n    return false;\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n
code-source-info,0x315766f9b75e,128,0,1102,C0O0C4O1102,,
code-creation,Function,10,149485,0x315766f9b996,89, node:internal/cluster/shared_handle:1:1,0x315766f9b6d8,~
code-source-info,0x315766f9b996,128,0,1102,C0O0C22O22C28O62C31O62C35O62C37O104C40O104C44O104C46O143C49O143C53O143C55O160C57O175C61O685C70O699C74O861C83O878C88O1101,,
code-creation,Eval,10,149640,0x315766f9bf5e,5, node:internal/cluster/worker:1:1,0x315766f9bde8,~
script-source,129,node:internal/cluster/worker,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\n\nmodule.exports = Worker;\n\n// Common Worker implementation shared between the cluster primary and workers.\nfunction Worker(options) {\n  if (!(this instanceof Worker))\n    return new Worker(options);\n\n  ReflectApply(EventEmitter\x2C this\x2C []);\n\n  if (options === null || typeof options !== 'object')\n    options = {};\n\n  this.exitedAfterDisconnect = undefined;\n\n  this.state = options.state || 'none';\n  this.id = options.id | 0;\n\n  if (options.process) {\n    this.process = options.process;\n    this.process.on('error'\x2C (code\x2C signal) =>\n      this.emit('error'\x2C code\x2C signal)\n    );\n    this.process.on('message'\x2C (message\x2C handle) =>\n      this.emit('message'\x2C message\x2C handle)\n    );\n  }\n}\n\nObjectSetPrototypeOf(Worker.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Worker\x2C EventEmitter);\n\nWorker.prototype.kill = function() {\n  ReflectApply(this.destroy\x2C this\x2C arguments);\n};\n\nWorker.prototype.send = function() {\n  return ReflectApply(this.process.send\x2C this.process\x2C arguments);\n};\n\nWorker.prototype.isDead = function() {\n  return this.process.exitCode != null || this.process.signalCode != null;\n};\n\nWorker.prototype.isConnected = function() {\n  return this.process.connected;\n};\n
code-source-info,0x315766f9bf5e,129,0,1315,C0O0C4O1315,,
code-creation,Function,10,149783,0x315766f9c2c6,141, node:internal/cluster/worker:1:1,0x315766f9bed8,~
code-source-info,0x315766f9c2c6,129,0,1315,C0O0C17O25C22O49C28O102C31O102C35O102C37O122C39O137C43O812C46O840C54O864C59O812C64O876C70O876C75O921C78O928C87O943C91O1009C94O1016C103O1031C107O1117C110O1124C119O1141C123O1235C126O1242C135O1264C140O1314,,
tick,0x1074ee27e,149822,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x3157a91ed8d2,0x10f8c4be3,0x10f8c4865,0x3157a91ec203,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x3157a91ea349,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,149876,0x315766f9c816,21,EventEmitter node:events:84:22,0x31575b571ba8,~
code-source-info,0x315766f9c816,13,2479,2527,C0O2490C3O2503C8O2508C13O2508C20O2526,,
code-creation,LazyCompile,10,149938,0x315766f9c95e,149,EventEmitter.init node:events:194:29,0x31575b5728a8,~
code-source-info,0x315766f9c95e,13,5579,6168,C0O5600C6O5636C13O5648C16O5648C21O5674C25O5644C30O5690C32O5705C37O5705C41O5703C45O5729C46O5747C50O5785C60O5778C64O5817C71O5825C80O5852C85O5873C93O5852C98O5926C100O5931C105O5943C108O5956C113O5943C117O5941C123O6112C125O6117C131O6142C138O6152C140O6151C143O6127C148O6167,,
code-creation,LazyCompile,10,150068,0x315766f9cd76,151,getESMFacade node:internal/bootstrap/loaders:264:15,0x31575b54f748,~
code-source-info,0x315766f9cd76,9,8231,8860,C0O8231C8O8249C14O8269C18O8276C19O8304C29O8304C34O8289C39O8352C42O8365C51O8396C53O8396C55O8426C62O8451C67O8426C72O8468C82O8468C87O8516C89O8568C102O8530C107O8528C111O8774C116O8781C121O8781C125O8805C130O8812C140O8812C146O8849C150O8856,,
code-creation,LazyCompile,10,150162,0x315766f9d15e,40, node:internal/bootstrap/loaders:273:15,0x315766f9cc70,~
code-source-info,0x315766f9d15e,9,8595,8700,C0O8608C5O8621C10O8621C14O8649C24O8670C27O8683C32O8649C39O8699,,
code-creation,LazyCompile,10,150221,0x315766f9d2b6,89,syncExports node:internal/bootstrap/loaders:287:14,0x31575b54f7b8,~
code-source-info,0x315766f9d2b6,9,9167,9500,C0O9195C5O9220C11O9249C13O9262C17O9254C22O9304C24O9309C28O9322C30O9337C35O9352C37O9375C42O9382C51O9434C54O9446C59O9472C67O9434C73O9382C79O9271C84O9236C88O9499,,
code-creation,LazyCompile,10,150271,0x315766f9d41e,35,getOwn node:internal/bootstrap/loaders:180:16,0x31575b54f450,~
code-source-info,0x315766f9d41e,9,5498,5652,C0O5534C5O5541C14O5595C26O5595C34O5650,,
code-creation,Function,11,150336,0x10f8c61a0,672,syncExports node:internal/bootstrap/loaders:287:14,0x31575b54f7b8,^
code-source-info,0x10f8c61a0,9,9167,9500,,,
code-creation,Function,11,150366,0x10f8c64a0,272,validateString node:internal/validators:117:24,0x315735259ef8,^
code-source-info,0x10f8c64a0,17,3398,3507,,,
code-creation,Function,11,150393,0x10f8c6620,548,internalBinding node:internal/bootstrap/loaders:164:45,0x31575b54f378,^
code-source-info,0x10f8c6620,9,5115,5353,,,
code-creation,Function,11,150439,0x10f8c68c0,1344,deprecate node:internal/util:96:19,0x31575b569cc0,^
code-source-info,0x10f8c68c0,12,2408,3584,,,
code-creation,Function,11,150463,0x10f8c6e60,304,getOwn node:internal/bootstrap/loaders:180:16,0x31575b54f450,^
code-source-info,0x10f8c6e60,9,5498,5652,,,
code-creation,RegExp,3,150634,0x10f8c7000,1524,(?:^|\\/)\\.?\\.$
tick,0x1072945bc,150937,1,0x1070ca120,2,0x1072c15f0,0x3157a91e8ba6,0x3157a91e82d7,0x3157a91e6c15,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,150961,0x315766f9dd5e,5, /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/redir-stdout.js:1:1,0x315766f9dbb8,~
script-source,130,/Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/redir-stdout.js,'use strict'\nconst net = require('net')\n\nlet isWorker = false\ntry {\n  // Skip redirecting stdout in Worker threads.\n  isWorker = !require('worker_threads').isMainThread\n} catch (e) {}\n\nif (!isWorker) {\n  const socket = new net.Socket({\n    fd: 3\x2C\n    readable: false\x2C\n    writable: true\n  })\n  Object.defineProperty(process\x2C 'stdout'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: () => socket\n  })\n  Object.defineProperty(process.stdout\x2C 'fd'\x2C {\n    value: socket._handle.fd\n  })\n}\n
code-source-info,0x315766f9dd5e,130,0,494,C0O0C4O494,,
code-creation,Function,10,151040,0x315766f9e006,157, /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/redir-stdout.js:1:1,0x315766f9dcd8,~
code-source-info,0x315766f9e006,130,0,494,C0O25C3O25C8O56C13O118C16O130C21O155C30O127C42O185C53O227C65O219C70O219C72O294C76O301C81O316C93O392C101O301C106O412C110O419C115O434C119O442C135O476C140O484C148O419C156O493,,
code-creation,LazyCompile,10,151137,0x315766f9e506,37,get BlockList node:net:1779:16,0x3157a91fd840,~
code-source-info,0x315766f9e506,120,47366,47455,C0O47375C14O47389C19O47418C26O47385C32O47434C36O47451,,
code-creation,Eval,10,151312,0x315766f9e9d6,5, node:internal/blocklist:1:1,0x315766f9e7f0,~
script-source,131,node:internal/blocklist,'use strict';\n\nconst {\n  Boolean\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\n} = primordials;\n\nconst {\n  BlockList: BlockListHandle\x2C\n} = internalBinding('block_list');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  SocketAddress\x2C\n  kHandle: kSocketAddressHandle\x2C\n} = require('internal/socketaddress');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst kHandle = Symbol('kHandle');\nconst { owner_symbol } = internalBinding('symbols');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\n\nconst { validateInt32\x2C validateString } = require('internal/validators');\n\nclass BlockList extends JSTransferable {\n  constructor() {\n    super();\n    this[kHandle] = new BlockListHandle();\n    this[kHandle][owner_symbol] = this;\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `BlockList ${inspect({\n      rules: this.rules\n    }\x2C opts)}`;\n  }\n\n  addAddress(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      address = new SocketAddress({\n        address\x2C\n        family\x2C\n      });\n    }\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\n  }\n\n  addRange(start\x2C end\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(start)) {\n      validateString(start\x2C 'start');\n      validateString(family\x2C 'family');\n      start = new SocketAddress({\n        address: start\x2C\n        family\x2C\n      });\n    }\n    if (!SocketAddress.isSocketAddress(end)) {\n      validateString(end\x2C 'end');\n      validateString(family\x2C 'family');\n      end = new SocketAddress({\n        address: end\x2C\n        family\x2C\n      });\n    }\n    const ret = this[kHandle].addRange(\n      start[kSocketAddressHandle]\x2C\n      end[kSocketAddressHandle]);\n    if (ret === false)\n      throw new ERR_INVALID_ARG_VALUE('start'\x2C start\x2C 'must come before end');\n  }\n\n  addSubnet(network\x2C prefix\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(network)) {\n      validateString(network\x2C 'network');\n      validateString(family\x2C 'family');\n      network = new SocketAddress({\n        address: network\x2C\n        family\x2C\n      });\n    }\n    switch (network.family) {\n      case 'ipv4':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 32);\n        break;\n      case 'ipv6':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 128);\n        break;\n    }\n    this[kHandle].addSubnet(network[kSocketAddressHandle]\x2C prefix);\n  }\n\n  check(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      try {\n        address = new SocketAddress({\n          address\x2C\n          family\x2C\n        });\n      } catch {\n        // Ignore the error. If it's not a valid address\x2C return false.\n        return false;\n      }\n    }\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n  }\n\n  get rules() {\n    return this[kHandle].getRules();\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/blocklist:InternalBlockList'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kHandle][owner_symbol] = this;\n  }\n}\n\nclass InternalBlockList extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    if (handle !== undefined)\n      handle[owner_symbol] = this;\n  }\n}\n\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\nObjectSetPrototypeOf(InternalBlockList.prototype\x2C BlockList.prototype);\n\nmodule.exports = {\n  BlockList\x2C\n  InternalBlockList\x2C\n};\n
code-source-info,0x315766f9e9d6,131,0,3877,C0O0C4O3877,,
code-creation,Function,10,151641,0x315766f9f3de,359, node:internal/blocklist:1:1,0x315766f9e950,~
code-source-info,0x315766f9f3de,131,0,3877,C0O0C35O25C41O36C46O60C51O127C54O127C59O106C65O204C68O204C73O190C78O293C81O293C86O241C92O267C98O385C101O385C106O339C111O357C116O367C121O450C124O450C129O438C135O501C138O501C142O501C144O545C147O545C152O528C158O611C161O611C166O637C171O584C177O688C180O688C185O654C191O669C197O745C204O884C241O3223C251O3384C278O3519C301O3691C306O3725C311O3735C315O3713C319O3787C324O3808C329O3748C334O3821C341O3842C347O3855C353O3836C358O3876,,
code-creation,Eval,10,151900,0x315766fa0cae,5, node:internal/socketaddress:1:1,0x315766fa0ab8,~
script-source,132,node:internal/socketaddress,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  SocketAddress: _SocketAddress\x2C\n  AF_INET\x2C\n  AF_INET6\x2C\n} = internalBinding('block_list');\n\nconst {\n  validateObject\x2C\n  validateString\x2C\n  validatePort\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst kHandle = Symbol('kHandle');\nconst kDetail = Symbol('kDetail');\n\nclass SocketAddress extends JSTransferable {\n  static isSocketAddress(value) {\n    return value?.[kHandle] !== undefined;\n  }\n\n  constructor(options = {}) {\n    super();\n    validateObject(options\x2C 'options');\n    let { family = 'ipv4' } = options;\n    const {\n      address = (family === 'ipv4' ? '127.0.0.1' : '::')\x2C\n      port = 0\x2C\n      flowlabel = 0\x2C\n    } = options;\n\n    let type;\n    if (typeof family?.toLowerCase === 'function')\n      family = family.toLowerCase();\n    switch (family) {\n      case 'ipv4':\n        type = AF_INET;\n        break;\n      case 'ipv6':\n        type = AF_INET6;\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE('options.family'\x2C options.family);\n    }\n\n    validateString(address\x2C 'options.address');\n    validatePort(port\x2C 'options.port');\n    validateUint32(flowlabel\x2C 'options.flowlabel'\x2C false);\n\n    this[kHandle] = new _SocketAddress(address\x2C port\x2C type\x2C flowlabel);\n    this[kDetail] = this[kHandle].detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  get address() {\n    return this[kDetail].address;\n  }\n\n  get port() {\n    return this[kDetail].port;\n  }\n\n  get family() {\n    return this[kDetail].family === AF_INET ? 'ipv4' : 'ipv6';\n  }\n\n  get flowlabel() {\n    // The flow label can be changed internally.\n    return this[kHandle].flowlabel();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `SocketAddress ${inspect(this.toJSON()\x2C opts)}`;\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/socketaddress:InternalSocketAddress'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kDetail] = handle.detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  toJSON() {\n    return {\n      address: this.address\x2C\n      port: this.port\x2C\n      family: this.family\x2C\n      flowlabel: this.flowlabel\x2C\n    };\n  }\n}\n\nclass InternalSocketAddress extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\n\nInternalSocketAddress.prototype.constructor =\n  SocketAddress.prototype.constructor;\nObjectSetPrototypeOf(InternalSocketAddress.prototype\x2C SocketAddress.prototype);\n\nmodule.exports = {\n  SocketAddress\x2C\n  InternalSocketAddress\x2C\n  kHandle\x2C\n};\n
code-source-info,0x315766fa0cae,132,0,3207,C0O0C4O3207,,
code-creation,Function,10,152166,0x315766fa17d6,366, node:internal/socketaddress:1:1,0x315766fa0c28,~
code-source-info,0x315766fa17d6,132,0,3207,C0O0C38O25C43O49C48O143C51O143C56O100C62O118C68O129C74O257C77O257C82O185C88O203C94O221C100O237C106O345C109O345C114O345C119O313C125O419C128O419C133O405C138O466C141O466C146O454C152O557C155O557C160O511C165O529C170O539C175O618C178O618C182O618C184O653C187O653C191O653C193O701C226O2071C236O2313C246O2482C279O2877C302O2988C307O3028C312O3038C316O3010C320O3094C325O3119C330O3051C335O3132C342O3153C348O3170C354O3195C360O3147C365O3206,,
tick,0x7ff803e80ec4,152239,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x315766f9f42f,0x10f8c4be3,0x10f8c4865,0x315766f9e514,0x107b7f91f,0x10f8c6f67,0x10f8c63a1,0x315766f9d168,0x10709caa0,0x315766f9ce02,0x3157a91ebe4d,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x315766f9e009,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,152338,0x315766fa222e,37,get SocketAddress node:net:1783:20,0x3157a91fd8b8,~
code-source-info,0x315766fa222e,120,47476,47581,C0O47485C14O47503C19O47536C26O47499C32O47556C36O47577,,
code-creation,Eval,10,152437,0x315766fa2626,5, node:worker_threads:1:1,0x315766fa24e0,~
script-source,133,node:worker_threads,'use strict';\n\nconst {\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  threadId\x2C\n  Worker\n} = require('internal/worker');\n\nconst {\n  MessagePort\x2C\n  MessageChannel\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  BroadcastChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  markAsUntransferable\x2C\n} = require('internal/buffer');\n\nmodule.exports = {\n  isMainThread\x2C\n  MessagePort\x2C\n  MessageChannel\x2C\n  markAsUntransferable\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  resourceLimits\x2C\n  threadId\x2C\n  SHARE_ENV\x2C\n  Worker\x2C\n  parentPort: null\x2C\n  workerData: null\x2C\n  BroadcastChannel\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n};\n
code-source-info,0x315766fa2626,133,0,686,C0O0C4O686,,
code-creation,Function,10,152546,0x315766fa2836,180, node:worker_threads:1:1,0x315766fa25a0,~
code-source-info,0x315766fa2836,133,0,686,C0O139C3O139C8O25C13O41C18O54C23O72C28O94C33O116C38O128C43O285C46O285C51O178C56O193C61O211C66O239C71O263C76O353C79O353C84O327C89O382C96O403C102O419C108O434C114O452C120O476C126O504C132O528C138O546C144O558C150O571C156O621C162O641C168O663C174O397C179O685,,
code-creation,Eval,10,153044,0x315766fa37be,5, node:internal/worker:1:1,0x315766fa31e0,~
script-source,134,node:internal/worker,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  Float64Array\x2C\n  FunctionPrototypeBind\x2C\n  JSONStringify\x2C\n  MathMax\x2C\n  ObjectCreate\x2C\n  ObjectEntries\x2C\n  Promise\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  TypedArrayPrototypeFill\x2C\n  Uint32Array\x2C\n  globalThis: { Atomics\x2C SharedArrayBuffer }\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst assert = require('internal/assert');\nconst path = require('path');\nconst { now } = require('internal/perf/utils');\n\nconst errorCodes = require('internal/errors').codes;\nconst {\n  ERR_WORKER_NOT_RUNNING\x2C\n  ERR_WORKER_PATH\x2C\n  ERR_WORKER_UNSERIALIZABLE_ERROR\x2C\n  ERR_WORKER_INVALID_EXEC_ARGV\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n} = errorCodes;\nconst { getOptionValue } = require('internal/options');\n\nconst workerIo = require('internal/worker/io');\nconst {\n  drainMessagePort\x2C\n  MessageChannel\x2C\n  messageTypes\x2C\n  kPort\x2C\n  kIncrementsPortRef\x2C\n  kWaitingStreams\x2C\n  kStdioWantsMoreDataCallback\x2C\n  setupPortReferencing\x2C\n  ReadableWorkerStdio\x2C\n  WritableWorkerStdio\n} = workerIo;\nconst { deserializeError } = require('internal/error_serdes');\nconst { fileURLToPath\x2C isURLInstance\x2C pathToFileURL } = require('internal/url');\nconst { validateArray } = require('internal/validators');\n\nconst {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  resourceLimits: resourceLimitsRaw\x2C\n  threadId\x2C\n  Worker: WorkerImpl\x2C\n  kMaxYoungGenerationSizeMb\x2C\n  kMaxOldGenerationSizeMb\x2C\n  kCodeRangeSizeMb\x2C\n  kStackSizeMb\x2C\n  kTotalResourceLimitCount\n} = internalBinding('worker');\n\nconst kHandle = Symbol('kHandle');\nconst kPublicPort = Symbol('kPublicPort');\nconst kDispose = Symbol('kDispose');\nconst kOnExit = Symbol('kOnExit');\nconst kOnMessage = Symbol('kOnMessage');\nconst kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\nconst kOnErrorMessage = Symbol('kOnErrorMessage');\nconst kParentSideStdio = Symbol('kParentSideStdio');\nconst kLoopStartTime = Symbol('kLoopStartTime');\nconst kIsOnline = Symbol('kIsOnline');\n\nconst SHARE_ENV = SymbolFor('nodejs.worker_threads.SHARE_ENV');\nlet debug = require('internal/util/debuglog').debuglog('worker'\x2C (fn) => {\n  debug = fn;\n});\n\nlet cwdCounter;\n\nconst environmentData = new SafeMap();\n\nif (isMainThread) {\n  cwdCounter = new Uint32Array(new SharedArrayBuffer(4));\n  const originalChdir = process.chdir;\n  process.chdir = function(path) {\n    Atomics.add(cwdCounter\x2C 0\x2C 1);\n    originalChdir(path);\n  };\n}\n\nfunction setEnvironmentData(key\x2C value) {\n  if (value === undefined)\n    environmentData.delete(key);\n  else\n    environmentData.set(key\x2C value);\n}\n\nfunction getEnvironmentData(key) {\n  return environmentData.get(key);\n}\n\nfunction assignEnvironmentData(data) {\n  if (data === undefined) return;\n  data.forEach((value\x2C key) => {\n    environmentData.set(key\x2C value);\n  });\n}\n\nclass Worker extends EventEmitter {\n  constructor(filename\x2C options = {}) {\n    super();\n    debug(`[${threadId}] create new worker`\x2C filename\x2C options);\n    if (options.execArgv)\n      validateArray(options.execArgv\x2C 'options.execArgv');\n\n    let argv;\n    if (options.argv) {\n      validateArray(options.argv\x2C 'options.argv');\n      argv = ArrayPrototypeMap(options.argv\x2C String);\n    }\n\n    let url\x2C doEval;\n    if (options.eval) {\n      if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_VALUE(\n          'options.eval'\x2C\n          options.eval\x2C\n          'must be false when \\'filename\\' is not a string'\n        );\n      }\n      url = null;\n      doEval = 'classic';\n    } else if (isURLInstance(filename) && filename.protocol === 'data:') {\n      url = null;\n      doEval = 'module';\n      filename = `import ${JSONStringify(`${filename}`)}`;\n    } else {\n      doEval = false;\n      if (isURLInstance(filename)) {\n        url = filename;\n        filename = fileURLToPath(filename);\n      } else if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_TYPE(\n          'filename'\x2C\n          ['string'\x2C 'URL']\x2C\n          filename\n        );\n      } else if (path.isAbsolute(filename) ||\n                 RegExpPrototypeTest(/^\\.\\.?[\\\\/]/\x2C filename)) {\n        filename = path.resolve(filename);\n        url = pathToFileURL(filename);\n      } else {\n        throw new ERR_WORKER_PATH(filename);\n      }\n    }\n\n    let env;\n    if (typeof options.env === 'object' && options.env !== null) {\n      env = ObjectCreate(null);\n      ArrayPrototypeForEach(\n        ObjectEntries(options.env)\x2C\n        ({ 0: key\x2C 1: value }) => { env[key] = `${value}`; }\n      );\n    } else if (options.env == null) {\n      env = process.env;\n    } else if (options.env !== SHARE_ENV) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.env'\x2C\n        ['object'\x2C 'undefined'\x2C 'null'\x2C 'worker_threads.SHARE_ENV']\x2C\n        options.env);\n    }\n\n    // Set up the C++ handle for the worker\x2C as well as some internal wiring.\n    this[kHandle] = new WorkerImpl(url\x2C\n                                   env === process.env ? null : env\x2C\n                                   options.execArgv\x2C\n                                   parseResourceLimits(options.resourceLimits)\x2C\n                                   !!(options.trackUnmanagedFds ?? true));\n    if (this[kHandle].invalidExecArgv) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidExecArgv);\n    }\n    if (this[kHandle].invalidNodeOptions) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(\n        this[kHandle].invalidNodeOptions\x2C 'invalid NODE_OPTIONS env variable');\n    }\n    this[kHandle].onexit = (code\x2C customErr\x2C customErrReason) => {\n      this[kOnExit](code\x2C customErr\x2C customErrReason);\n    };\n    this[kPort] = this[kHandle].messagePort;\n    this[kPort].on('message'\x2C (data) => this[kOnMessage](data));\n    this[kPort].start();\n    this[kPort].unref();\n    this[kPort][kWaitingStreams] = 0;\n    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n\n    let stdin = null;\n    if (options.stdin)\n      stdin = new WritableWorkerStdio(this[kPort]\x2C 'stdin');\n    const stdout = new ReadableWorkerStdio(this[kPort]\x2C 'stdout');\n    if (!options.stdout) {\n      stdout[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stdout\x2C process.stdout);\n    }\n    const stderr = new ReadableWorkerStdio(this[kPort]\x2C 'stderr');\n    if (!options.stderr) {\n      stderr[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stderr\x2C process.stderr);\n    }\n\n    this[kParentSideStdio] = { stdin\x2C stdout\x2C stderr };\n\n    const { port1\x2C port2 } = new MessageChannel();\n    const transferList = [port2];\n    // If transferList is provided.\n    if (options.transferList)\n      ArrayPrototypePush(transferList\x2C\n                         ...new SafeArrayIterator(options.transferList));\n\n    this[kPublicPort] = port1;\n    ArrayPrototypeForEach(['message'\x2C 'messageerror']\x2C (event) => {\n      this[kPublicPort].on(event\x2C (message) => this.emit(event\x2C message));\n    });\n    setupPortReferencing(this[kPublicPort]\x2C this\x2C 'message');\n    this[kPort].postMessage({\n      argv\x2C\n      type: messageTypes.LOAD_SCRIPT\x2C\n      filename\x2C\n      doEval\x2C\n      cwdCounter: cwdCounter || workerIo.sharedCwdCounter\x2C\n      workerData: options.workerData\x2C\n      environmentData\x2C\n      publicPort: port2\x2C\n      manifestURL: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').url :\n        null\x2C\n      manifestSrc: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').src :\n        null\x2C\n      hasStdin: !!options.stdin\n    }\x2C transferList);\n    // Use this to cache the Worker's loopStart value once available.\n    this[kLoopStartTime] = -1;\n    this[kIsOnline] = false;\n    this.performance = {\n      eventLoopUtilization: FunctionPrototypeBind(eventLoopUtilization\x2C this)\x2C\n    };\n    // Actually start the new thread now that everything is in place.\n    this[kHandle].startThread();\n\n    process.nextTick(() => process.emit('worker'\x2C this));\n  }\n\n  [kOnExit](code\x2C customErr\x2C customErrReason) {\n    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n    drainMessagePort(this[kPublicPort]);\n    drainMessagePort(this[kPort]);\n    this.removeAllListeners('message');\n    this.removeAllListeners('messageerrors');\n    this[kPublicPort].unref();\n    this[kPort].unref();\n    this[kDispose]();\n    if (customErr) {\n      debug(`[${threadId}] failing with custom error ${customErr} \\\n        and with reason ${customErrReason}`);\n      this.emit('error'\x2C new errorCodes[customErr](customErrReason));\n    }\n    this.emit('exit'\x2C code);\n    this.removeAllListeners();\n  }\n\n  [kOnCouldNotSerializeErr]() {\n    this.emit('error'\x2C new ERR_WORKER_UNSERIALIZABLE_ERROR());\n  }\n\n  [kOnErrorMessage](serialized) {\n    // This is what is called for uncaught exceptions.\n    const error = deserializeError(serialized);\n    this.emit('error'\x2C error);\n  }\n\n  [kOnMessage](message) {\n    switch (message.type) {\n      case messageTypes.UP_AND_RUNNING:\n        this[kIsOnline] = true;\n        return this.emit('online');\n      case messageTypes.COULD_NOT_SERIALIZE_ERROR:\n        return this[kOnCouldNotSerializeErr]();\n      case messageTypes.ERROR_MESSAGE:\n        return this[kOnErrorMessage](message.error);\n      case messageTypes.STDIO_PAYLOAD:\n      {\n        const { stream\x2C chunks } = message;\n        const readable = this[kParentSideStdio][stream];\n        ArrayPrototypeForEach(chunks\x2C ({ chunk\x2C encoding }) => {\n          readable.push(chunk\x2C encoding);\n        });\n        return;\n      }\n      case messageTypes.STDIO_WANTS_MORE_DATA:\n      {\n        const { stream } = message;\n        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\n      }\n    }\n\n    assert.fail(`Unknown worker message type ${message.type}`);\n  }\n\n  [kDispose]() {\n    this[kHandle].onexit = null;\n    this[kHandle] = null;\n    this[kPort] = null;\n    this[kPublicPort] = null;\n\n    const { stdout\x2C stderr } = this[kParentSideStdio];\n\n    if (!stdout.readableEnded) {\n      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\n      stdout.push(null);\n    }\n    if (!stderr.readableEnded) {\n      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\n      stderr.push(null);\n    }\n  }\n\n  postMessage(...args) {\n    if (this[kPublicPort] === null) return;\n\n    ReflectApply(this[kPublicPort].postMessage\x2C this[kPublicPort]\x2C args);\n  }\n\n  terminate(callback) {\n    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\n\n    this.ref();\n\n    if (typeof callback === 'function') {\n      process.emitWarning(\n        'Passing a callback to worker.terminate() is deprecated. ' +\n        'It returns a Promise instead.'\x2C\n        'DeprecationWarning'\x2C 'DEP0132');\n      if (this[kHandle] === null) return PromiseResolve();\n      this.once('exit'\x2C (exitCode) => callback(null\x2C exitCode));\n    }\n\n    if (this[kHandle] === null) return PromiseResolve();\n\n    this[kHandle].stopThread();\n\n    // Do not use events.once() here\x2C because the 'exit' event will always be\n    // emitted regardless of any errors\x2C and the point is to only resolve\n    // once the thread has actually stopped.\n    return new Promise((resolve) => {\n      this.once('exit'\x2C resolve);\n    });\n  }\n\n  ref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].ref();\n    this[kPublicPort].ref();\n  }\n\n  unref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].unref();\n    this[kPublicPort].unref();\n  }\n\n  get threadId() {\n    if (this[kHandle] === null) return -1;\n\n    return this[kHandle].threadId;\n  }\n\n  get stdin() {\n    return this[kParentSideStdio].stdin;\n  }\n\n  get stdout() {\n    return this[kParentSideStdio].stdout;\n  }\n\n  get stderr() {\n    return this[kParentSideStdio].stderr;\n  }\n\n  get resourceLimits() {\n    if (this[kHandle] === null) return {};\n\n    return makeResourceLimits(this[kHandle].getResourceLimits());\n  }\n\n  getHeapSnapshot() {\n    const heapSnapshotTaker = this[kHandle] && this[kHandle].takeHeapSnapshot();\n    return new Promise((resolve\x2C reject) => {\n      if (!heapSnapshotTaker) return reject(new ERR_WORKER_NOT_RUNNING());\n      heapSnapshotTaker.ondone = (handle) => {\n        const { HeapSnapshotStream } = require('internal/heap_utils');\n        resolve(new HeapSnapshotStream(handle));\n      };\n    });\n  }\n}\n\nfunction pipeWithoutWarning(source\x2C dest) {\n  const sourceMaxListeners = source._maxListeners;\n  const destMaxListeners = dest._maxListeners;\n  source.setMaxListeners(Infinity);\n  dest.setMaxListeners(Infinity);\n\n  source.pipe(dest);\n\n  source._maxListeners = sourceMaxListeners;\n  dest._maxListeners = destMaxListeners;\n}\n\nconst resourceLimitsArray = new Float64Array(kTotalResourceLimitCount);\nfunction parseResourceLimits(obj) {\n  const ret = resourceLimitsArray;\n  TypedArrayPrototypeFill(ret\x2C -1);\n  if (typeof obj !== 'object' || obj === null) return ret;\n\n  if (typeof obj.maxOldGenerationSizeMb === 'number')\n    ret[kMaxOldGenerationSizeMb] = MathMax(obj.maxOldGenerationSizeMb\x2C 2);\n  if (typeof obj.maxYoungGenerationSizeMb === 'number')\n    ret[kMaxYoungGenerationSizeMb] = obj.maxYoungGenerationSizeMb;\n  if (typeof obj.codeRangeSizeMb === 'number')\n    ret[kCodeRangeSizeMb] = obj.codeRangeSizeMb;\n  if (typeof obj.stackSizeMb === 'number')\n    ret[kStackSizeMb] = obj.stackSizeMb;\n  return ret;\n}\n\nfunction makeResourceLimits(float64arr) {\n  return {\n    maxYoungGenerationSizeMb: float64arr[kMaxYoungGenerationSizeMb]\x2C\n    maxOldGenerationSizeMb: float64arr[kMaxOldGenerationSizeMb]\x2C\n    codeRangeSizeMb: float64arr[kCodeRangeSizeMb]\x2C\n    stackSizeMb: float64arr[kStackSizeMb]\n  };\n}\n\nfunction eventLoopUtilization(util1\x2C util2) {\n  // TODO(trevnorris): Works to solve the thread-safe read/write issue of\n  // loopTime\x2C but has the drawback that it can't be set until the event loop\n  // has had a chance to turn. So it will be impossible to read the ELU of\n  // a worker thread immediately after it's been created.\n  if (!this[kIsOnline] || !this[kHandle]) {\n    return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  // Cache loopStart\x2C since it's only written to once.\n  if (this[kLoopStartTime] === -1) {\n    this[kLoopStartTime] = this[kHandle].loopStartTime();\n    if (this[kLoopStartTime] === -1)\n      return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  if (util2) {\n    const idle = util1.idle - util2.idle;\n    const active = util1.active - util2.active;\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  const idle = this[kHandle].loopIdleTime();\n\n  // Using performance.now() here is fine since it's always the time from\n  // the beginning of the process\x2C and is why it needs to be offset by the\n  // loopStart time (which is also calculated from the beginning of the\n  // process).\n  const active = now() - this[kLoopStartTime] - idle;\n\n  if (!util1) {\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  const idle_delta = idle - util1.idle;\n  const active_delta = active - util1.active;\n  const utilization = active_delta / (idle_delta + active_delta);\n  return { idle: idle_delta\x2C active: active_delta\x2C utilization };\n}\n\nmodule.exports = {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits:\n    !isMainThread ? makeResourceLimits(resourceLimitsRaw) : {}\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  assignEnvironmentData\x2C\n  threadId\x2C\n  Worker\x2C\n};\n
code-source-info,0x315766fa37be,134,0,15348,C0O0C4O15348,,
code-creation,Function,10,154196,0x315766fa4b0e,1185, node:internal/worker:1:1,0x315766fa3738,~
code-source-info,0x315766fa4b0e,134,0,15348,C0O0C244O25C250O50C256O71C262O93C267O109C273O134C279O151C285O162C291O178C297O195C303O206C309O224C315O240C321O263C327O284C332O295C338O305C343O315C348O328C354O355C365O384C371O393C376O453C384O453C389O487C397O487C401O487C403O528C411O528C415O528C417O561C425O561C431O553C437O613C445O613C451O639C455O613C457O820C461O657C467O683C473O702C479O737C485O769C491O793C497O859C505O859C511O840C517O906C525O906C529O906C531O1153C535O947C541O967C547O985C553O1001C559O1010C565O1032C571O1051C577O1082C583O1106C589O1129C595O1192C603O1192C609O1171C615O1282C623O1282C629O1234C635O1249C641O1264C647O1333C655O1333C661O1315C667O1604C671O1604C677O1376C682O1396C687O1428C692O1449C698O1469C704O1483C710O1512C716O1539C722O1559C728O1575C733O1648C737O1648C741O1648C743O1687C747O1687C751O1687C753O1727C757O1727C761O1727C763O1763C767O1763C771O1763C773O1801C777O1801C781O1801C783O1855C787O1855C791O1855C793O1914C797O1914C801O1914C803O1966C807O1966C811O1966C813O2017C817O2017C821O2017C823O2061C827O2061C831O2061C833O2101C837O2101C841O2101C843O2159C851O2159C857O2192C873O2193C879O2159C881O2245C882O2245C884O2282C886O2282C891O2282C893O2298C904O2320C910O2349C919O2333C924O2331C928O2400C934O2408C938O2400C940O2417C950O2431C956O2913C966O7967C976O8603C986O8703C996O8876C1006O9773C1092O12655C1094O12655C1099O12655C1101O15104C1109O15125C1115O15145C1121O15161C1130O15195C1136O15210C1149O15256C1155O15278C1161O15300C1167O15325C1173O15337C1179O15119C1184O15347,,
tick,0x1070463d0,154331,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x315766fa2839,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x315766f9e016,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803e80c86,154355,1,0x10712a580,3,0x1072c15f0,0x10f8c4b1b,0x10f8c4865,0x315766fa2839,0x10f8c4be3,0x3157a91ebe0a,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x315766f9e016,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,154674,0x315766fa6a56,5, node:internal/error_serdes:1:1,0x315766fa6790,~
script-source,135,node:internal/error_serdes,'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst {\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  EvalError\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeToString\x2C\n  RangeError\x2C\n  ReferenceError\x2C\n  SafeSet\x2C\n  SymbolToStringTag\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kSerializedError = 0;\nconst kSerializedObject = 1;\nconst kInspectedError = 2;\n\nconst errors = {\n  Error\x2C TypeError\x2C RangeError\x2C URIError\x2C SyntaxError\x2C ReferenceError\x2C EvalError\n};\nconst errorConstructorNames = new SafeSet(ObjectKeys(errors));\n\nfunction TryGetAllProperties(object\x2C target = object) {\n  const all = ObjectCreate(null);\n  if (object === null)\n    return all;\n  ObjectAssign(all\x2C\n               TryGetAllProperties(ObjectGetPrototypeOf(object)\x2C target));\n  const keys = ObjectGetOwnPropertyNames(object);\n  ArrayPrototypeForEach(keys\x2C (key) => {\n    let descriptor;\n    try {\n      descriptor = ObjectGetOwnPropertyDescriptor(object\x2C key);\n    } catch { return; }\n    const getter = descriptor.get;\n    if (getter && key !== '__proto__') {\n      try {\n        descriptor.value = FunctionPrototypeCall(getter\x2C target);\n      } catch {}\n    }\n    if ('value' in descriptor && typeof descriptor.value !== 'function') {\n      delete descriptor.get;\n      delete descriptor.set;\n      all[key] = descriptor;\n    }\n  });\n  return all;\n}\n\nfunction GetConstructors(object) {\n  const constructors = [];\n\n  for (let current = object;\n    current !== null;\n    current = ObjectGetPrototypeOf(current)) {\n    const desc = ObjectGetOwnPropertyDescriptor(current\x2C 'constructor');\n    if (desc && desc.value) {\n      ObjectDefineProperty(constructors\x2C constructors.length\x2C {\n        value: desc.value\x2C enumerable: true\n      });\n    }\n  }\n\n  return constructors;\n}\n\nfunction GetName(object) {\n  const desc = ObjectGetOwnPropertyDescriptor(object\x2C 'name');\n  return desc && desc.value;\n}\n\nlet internalUtilInspect;\nfunction inspect(...args) {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect.inspect(...args);\n}\n\nlet serialize;\nfunction serializeError(error) {\n  if (!serialize) serialize = require('v8').serialize;\n  try {\n    if (typeof error === 'object' &&\n        ObjectPrototypeToString(error) === '[object Error]') {\n      const constructors = GetConstructors(error);\n      for (let i = 0; i < constructors.length; i++) {\n        const name = GetName(constructors[i]);\n        if (errorConstructorNames.has(name)) {\n          const serialized = serialize({\n            constructor: name\x2C\n            properties: TryGetAllProperties(error)\n          });\n          return Buffer.concat([Buffer.from([kSerializedError])\x2C serialized]);\n        }\n      }\n    }\n  } catch {}\n  try {\n    const serialized = serialize(error);\n    return Buffer.concat([Buffer.from([kSerializedObject])\x2C serialized]);\n  } catch {}\n  return Buffer.concat([Buffer.from([kInspectedError])\x2C\n                        Buffer.from(inspect(error)\x2C 'utf8')]);\n}\n\nlet deserialize;\nfunction deserializeError(error) {\n  if (!deserialize) deserialize = require('v8').deserialize;\n  switch (error[0]) {\n    case kSerializedError:\n      const { constructor\x2C properties } = deserialize(error.subarray(1));\n      const ctor = errors[constructor];\n      ObjectDefineProperty(properties\x2C SymbolToStringTag\x2C {\n        value: { value: 'Error'\x2C configurable: true }\x2C\n        enumerable: true\n      });\n      return ObjectCreate(ctor.prototype\x2C properties);\n    case kSerializedObject:\n      return deserialize(error.subarray(1));\n    case kInspectedError:\n      const buf = Buffer.from(error.buffer\x2C\n                              error.byteOffset + 1\x2C\n                              error.byteLength - 1);\n      return buf.toString('utf8');\n  }\n  require('assert').fail('This should not happen');\n}\n\nmodule.exports = { serializeError\x2C deserializeError };\n
code-source-info,0x315766fa6a56,135,0,4030,C0O0C4O4030,,
code-creation,Function,10,155003,0x315766fa6e76,335, node:internal/error_serdes:1:1,0x315766fa69d0,~
code-source-info,0x315766fa6e76,135,0,4030,C0O0C100O30C106O30C111O47C115O30C117O66C123O91C128O100C133O113C139O138C145O154C151O170C157O194C163O228C169O257C175O281C180O295C186O322C191O336C196O354C201O365C207O386C212O401C217O414C222O467C223O467C225O496C227O496C229O523C231O523C233O542C240O546C246O553C252O564C258O576C264O586C270O599C276O615C282O542C284O658C287O670C294O658C299O658C301O2038C302O2038C304O2235C305O2235C307O3156C308O3156C310O3975C317O3994C323O4010C329O3990C334O4029,,
tick,0x107b13b40,155345,0,0x0,0,0x315766f9d168,0x10709caa0,0x315766f9ce02,0x3157a91ebe4d,0x3157a91e1443,0x3157a91d0ae6,0x3157a91d071a,0x3157a91ebb1e,0x315766f9e016,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,155502,0x315766fa7f6e,793,Socket node:net:283:16,0x3157a91fb780,~
code-source-info,0x315766fa7f6e,120,7049,11100,C0O7063C2O7074C7O7094C12O7101C17O7121C18O7124C25O7135C34O7155C42O7230C52O7161C57O7155C58O7283C65O7294C81O7325C90O7353C98O7420C115O7509C121O7539C131O7359C136O7353C137O7598C138O7614C142O7818C144O7823C149O7840C153O7848C154O7863C158O7874C160O7879C164O7888C168O7898C169O7911C173O7921C174O7932C178O7942C180O7947C184O7960C188O7971C190O7976C194O7997C198O8004C200O8009C204O8019C208O8029C210O8034C214O8043C218O8053C220O8058C224O8069C228O8079C230O8084C234O8096C238O8107C244O8144C251O8160C262O8203C268O8282C270O8306C273O8322C278O8306C282O8304C286O8396C287O8414C291O8425C292O8445C296O8485C297O8507C301O8518C306O8525C311O8532C316O8532C322O8568C328O8605C332O8595C336O8628C338O8633C344O8671C349O8652C353O8650C359O8702C365O8734C370O8758C372O8876C377O8891C382O8889C386O8932C391O8940C396O8940C402O9197C404O9212C412O9218C417O9212C418O9252C420O9257C423O9281C428O9289C433O9289C437O9274C441O9308C443O9316C450O9328C455O9352C462O9371C464O9360C471O9380C475O9462C480O9470C487O9470C493O9495C495O9512C503O9518C508O9512C509O9561C510O9574C514O9588C516O9602C519O9602C523O9600C527O9793C532O9819C545O9793C550O9925C555O9935C565O9995C568O10015C573O9995C579O10040C587O10086C595O10135C603O10166C605O10171C609O10180C613O10194C615O10199C618O10220C622O10211C628O10247C630O10252C633O10270C637O10261C641O10288C643O10293C646O10313C650O10304C654O10390C665O10390C671O10425C674O10425C678O10452C679O10470C683O10480C685O10502C689O10643C695O10662C701O10671C706O10700C712O10787C718O10803C722O10823C727O10831C732O10831C736O10849C737O10870C743O10903C749O10929C756O10929C761O10975C762O10987C766O10997C767O11010C771O11050C773O11055C777O11067C781O11074C783O11079C787O11094C792O11099,,
code-creation,LazyCompile,10,155671,0x315766fa857e,109,Duplex node:internal/streams/duplex:52:16,0x3157dbeca3c0,~
script-source,48,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance\x2C this class\n// prototypically inherits from Readable\x2C and then parasitically from\n// Writable.\n\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = Duplex;\n\nconst Readable = require('internal/streams/readable');\nconst Writable = require('internal/streams/writable');\n\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(Duplex\x2C Readable);\n\n{\n  // Allow the keys array to be GC'ed.\n  for (const method of ObjectKeys(Writable.prototype)) {\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this\x2C options);\n  Writable.call(this\x2C options);\n  this.allowHalfOpen = true;\n\n  if (options) {\n    if (options.readable === false)\n      this.readable = false;\n\n    if (options.writable === false)\n      this.writable = false;\n\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n    }\n  }\n}\n\nObjectDefineProperties(Duplex.prototype\x2C {\n  writable:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable')\x2C\n  writableHighWaterMark:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark')\x2C\n  writableObjectMode:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode')\x2C\n  writableBuffer:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer')\x2C\n  writableLength:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength')\x2C\n  writableFinished:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished')\x2C\n  writableCorked:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked')\x2C\n  writableEnded:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded')\x2C\n  writableNeedDrain:\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain')\x2C\n\n  destroyed: {\n    get() {\n      if (this._readableState === undefined ||\n        this._writableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\n  }\n});\n\nlet duplexify;\n\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require('internal/streams/duplexify');\n  }\n  return duplexify(body\x2C 'body');\n};\n
code-source-info,0x315766fa857e,48,1951,2360,C0O1965C2O1976C7O2000C12O2007C17O2027C18O2031C23O2040C28O2040C34O2063C39O2072C44O2072C50O2095C51O2114C55O2125C59O2156C65O2165C70O2182C71O2196C75O2222C81O2231C86O2248C87O2262C91O2288C97O2302C102O2321C103O2340C108O2359,,
code-creation,LazyCompile,10,156165,0x315766fa8c26,220,Readable node:internal/streams/readable:181:18,0x3157dbed5208,~
script-source,49,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  SafeSet\x2C\n  SymbolAsyncIterator\x2C\n  Symbol\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignalNoValidate\x2C\n} = require('internal/streams/add-abort-signal');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst BufferList = require('internal/streams/buffer_list');\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\n\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_STREAM_PUSH_AFTER_EOF\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT\n} = require('internal/errors').codes;\nconst { validateObject } = require('internal/validators');\n\nconst kPaused = Symbol('kPaused');\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Readable\x2C Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.readableObjectMode);\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\n  // any actions that shouldn't happen until "later" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // Whenever we return null\x2C then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this[kPaused] = null;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Has it been destroyed.\n  this.destroyed = false;\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n  this.multiAwaitDrain = false;\n\n  // If true\x2C a maybeReadMore has been scheduled.\n  this.readingMore = false;\n\n  this.dataEmitted = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor\x2C at least with V8 6.5.\n  const isDuplex = this instanceof Stream.Duplex;\n\n  this._readableState = new ReadableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n    if (options.signal && !isDuplex)\n      addAbortSignalNoValidate(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this\x2C this._readableState);\n    }\n  });\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet\x2C\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C true);\n};\n\nfunction readableAddChunk(stream\x2C chunk\x2C encoding\x2C addToFront) {\n  debug('readableAddChunk'\x2C chunk);\n  const state = stream._readableState;\n\n  let err;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting\x2C if state.encoding is set\x2C we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk\x2C encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  if (err) {\n    errorOrDestroy(stream\x2C err);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream\x2C state);\n  } else if (state.objectMode || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if (state.endEmitted)\n        errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n      else\n        addChunk(stream\x2C state\x2C chunk\x2C true);\n    } else if (state.ended) {\n      errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.reading = false;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0)\n          addChunk(stream\x2C state\x2C chunk\x2C false);\n        else\n          maybeReadMore(stream\x2C state);\n      } else {\n        addChunk(stream\x2C state\x2C chunk\x2C false);\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n    maybeReadMore(stream\x2C state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\n  // This is to work around cases where hwm=0\x2C such as the repl.\n  return !state.ended &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync &&\n      stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n    state.dataEmitted = true;\n    stream.emit('data'\x2C chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream\x2C state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '')\n    buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n\x2C state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length)\n      return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method\x2C or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read'\x2C n);\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\n  // in this scenario\x2C so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n\x2C 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state.emittedReadable = false;\n\n  // If we're doing read(0) to trigger a readable event\x2C but we\n  // already have a bunch of data in the buffer\x2C then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       state.ended)) {\n    debug('read: emitReadable'\x2C state.length\x2C state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n\x2C state);\n\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer\x2C providing enough data when\n  // before there was *not* enough.\n  //\n  // So\x2C the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\n  // that the Readable class should behave improperly\x2C as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie\x2C if the read call\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event\x2C then we need to do some reading.\n  let doRead = state.needReadable;\n  debug('need readable'\x2C doRead);\n\n  // If we currently have less than the highWaterMark\x2C then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark'\x2C doRead);\n  }\n\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\n  if (state.ended || state.reading || state.destroyed || state.errored ||\n      !state.constructed) {\n    doRead = false;\n    debug('reading\x2C ended or constructing'\x2C doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // If the length is currently zero\x2C then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n\n    // Call internal read method\n    this._read(state.highWaterMark);\n\n    state.sync = false;\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig\x2C state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n\x2C state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer\x2C then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null) {\n    state.dataEmitted = true;\n    this.emit('data'\x2C ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream\x2C state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  if (state.sync) {\n    // If we are sync\x2C wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode\x2C because this can trigger\n// another read() call => stack overflow.  This way\x2C it might trigger\n// a nextTick recursion warning\x2C but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable'\x2C state.needReadable\x2C state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable'\x2C state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_\x2C stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_'\x2C state.destroyed\x2C state.length\x2C state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing\x2C as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark\x2C so we can schedule\n  //    another readable later.\n  state.needReadable =\n    !state.flowing &&\n    !state.ended &&\n    state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call\x2C in which case reading = true if\n// it's in progress.\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream\x2C state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\n  }\n}\n\nfunction maybeReadMore_(stream\x2C state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data\x2C the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method\x2C but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended &&\n         (state.length < state.highWaterMark ||\n          (state.flowing && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data\x2C stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er\x2C data) where data is <= n in length.\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\n// arbitrary\x2C and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end'\x2C endFn);\n\n  dest.on('unpipe'\x2C onunpipe);\n  function onunpipe(readable\x2C unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close'\x2C onclose);\n    dest.removeListener('finish'\x2C onfinish);\n    if (ondrain) {\n      dest.removeListener('drain'\x2C ondrain);\n    }\n    dest.removeListener('error'\x2C onerror);\n    dest.removeListener('unpipe'\x2C onunpipe);\n    src.removeListener('end'\x2C onend);\n    src.removeListener('end'\x2C unpipe);\n    src.removeListener('data'\x2C ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer\x2C then it would cause it to never start\n    // flowing again.\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\n    // If we don't know\x2C then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`\x2C it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response\x2C pause'\x2C 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains\x2C it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow()\x2C but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src\x2C dest);\n      dest.on('drain'\x2C ondrain);\n    }\n  }\n\n  src.on('data'\x2C ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write'\x2C ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error\x2C then stop piping into it.\n  // However\x2C don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror'\x2C er);\n    unpipe();\n    dest.removeListener('error'\x2C onerror);\n    if (EE.listenerCount(dest\x2C 'error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest\x2C er);\n      } else {\n        dest.emit('error'\x2C er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Both close and finish should trigger unpipe\x2C but only once.\n  function onclose() {\n    dest.removeListener('finish'\x2C onfinish);\n    unpipe();\n  }\n  dest.once('close'\x2C onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close'\x2C onclose);\n    unpipe();\n  }\n  dest.once('finish'\x2C onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe'\x2C src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause();\n    }\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src\x2C dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly\x2C\n    // `this` maybe not a reference to dest\x2C\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain'\x2C 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      EE.listenerCount(src\x2C 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere\x2C then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index\x2C 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev\x2C fn) {\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable'\x2C state.length\x2C state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick\x2C this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev\x2C fn) {\n  const res = Stream.prototype.removeListener.call(this\x2C\n                                                   ev\x2C fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now\x2C otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them\x2C then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable\x2C but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this\x2C state);\n  }\n  state[kPaused] = false;\n  return this;\n};\n\nfunction resume(stream\x2C state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_\x2C stream\x2C state);\n  }\n}\n\nfunction resume_(stream\x2C state) {\n  debug('resume'\x2C state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j'\x2C this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow'\x2C state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method\x2C e.g. Readable.wrap(stream).\n\n  stream.on('data'\x2C (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end'\x2C () => {\n    this.push(null);\n  });\n\n  stream.on('error'\x2C (err) => {\n    errorOrDestroy(this\x2C err);\n  });\n\n  stream.on('close'\x2C () => {\n    this.destroy();\n  });\n\n  stream.on('destroy'\x2C () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n  }\n  return streamToAsyncIterator(this\x2C options);\n};\n\nfunction streamToAsyncIterator(stream\x2C options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream\x2C { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream\x2C options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream\x2C options) {\n  let callback = nop;\n\n  const opts = {\n    destroyOnReturn: true\x2C\n    destroyOnError: true\x2C\n    ...options\x2C\n  };\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  const state = stream._readableState;\n\n  let error = state.errored;\n  let errorEmitted = state.errorEmitted;\n  let endEmitted = state.endEmitted;\n  let closeEmitted = state.closeEmitted;\n\n  stream\n    .on('readable'\x2C next)\n    .on('error'\x2C function(err) {\n      error = err;\n      errorEmitted = true;\n      next.call(this);\n    })\n    .on('end'\x2C function() {\n      endEmitted = true;\n      next.call(this);\n    })\n    .on('close'\x2C function() {\n      closeEmitted = true;\n      next.call(this);\n    });\n\n  let errorThrown = false;\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (errorEmitted) {\n        throw error;\n      } else if (endEmitted) {\n        break;\n      } else if (closeEmitted) {\n        break;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    if (opts.destroyOnError) {\n      destroyImpl.destroyer(stream\x2C err);\n    }\n    errorThrown = true;\n    throw err;\n  } finally {\n    if (!errorThrown && opts.destroyOnReturn) {\n      if (state.autoDestroy || !endEmitted) {\n        // TODO(ronag): ERR_PREMATURE_CLOSE?\n        destroyImpl.destroyer(stream\x2C null);\n      }\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype\x2C {\n  readable: {\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    }\x2C\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  }\x2C\n\n  readableDidRead: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\n  }\x2C\n\n  readableAborted: {\n    enumerable: false\x2C\n    get: function() {\n      return !!(this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted;\n    }\n  }\x2C\n\n  readableHighWaterMark: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\n  }\x2C\n\n  readableBuffer: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\n  }\x2C\n\n  readableFlowing: {\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.flowing;\n    }\x2C\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  }\x2C\n\n  readableLength: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState.length;\n    }\n  }\x2C\n\n  readableObjectMode: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  }\x2C\n\n  readableEncoding: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  }\x2C\n\n  destroyed: {\n    enumerable: false\x2C\n    get() {\n      if (this._readableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed;\n    }\x2C\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\n  }\x2C\n\n  readableEnded: {\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\x2C\n\n});\n\nObjectDefineProperties(ReadableState.prototype\x2C {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    get() {\n      return this.pipes.length;\n    }\n  }\x2C\n\n  // Legacy property for `paused`.\n  paused: {\n    get() {\n      return this[kPaused] !== false;\n    }\x2C\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction fromList(n\x2C state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // Read it all\x2C truncate the list.\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.first();\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n\x2C state.decoder);\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable'\x2C state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT\x2C state\x2C stream);\n  }\n}\n\nfunction endReadableNT(state\x2C stream) {\n  debug('endReadableNT'\x2C state.endEmitted\x2C state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errorEmitted && !state.closeEmitted &&\n      !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT\x2C stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable\x2C opts) {\n  return from(Readable\x2C iterable\x2C opts);\n};\n\nReadable.wrap = function(src\x2C options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\n    ...options\x2C\n    destroy(err\x2C callback) {\n      destroyImpl.destroyer(src\x2C err);\n      callback(err);\n    }\n  }).wrap(src);\n};\n
code-source-info,0x315766fa8c26,49,6246,7126,C0O6246C9O6260C16O6271C21O6297C28O6304C33O6326C34O6481C41O6497C44O6504C48O6486C52O6515C71O6537C76O6535C80O6584C84O6622C92O6649C95O6670C99O6660C103O6700C111O6730C114O6754C118O6744C122O6787C130O6819C133O6845C137O6835C141O6872C149O6883C151O6899C158O6932C166O6899C171O6954C178O6961C186O6961C192O6985C199O6997C212O6997C219O7125,,
tick,0x7ff803e80c81,159167,0,0x0,3,0x107791470,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x10728b10d,159188,0,0x0,3,0x107791470,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
tick,0x7ff803d551e7,159198,0,0x0,3,0x107791470,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,159222,0x315766fab9e6,18,Stream node:internal/streams/legacy:10:16,0x3157dbed79f8,~
script-source,50,node:internal/streams/legacy,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst EE = require('events');\n\nfunction Stream(opts) {\n  EE.call(this\x2C opts);\n}\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\nObjectSetPrototypeOf(Stream\x2C EE);\n\nStream.prototype.pipe = function(dest\x2C options) {\n  const source = this;\n\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n\n  source.on('data'\x2C ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain'\x2C ondrain);\n\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end'\x2C onend);\n    source.on('close'\x2C onclose);\n  }\n\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this\x2C 'error') === 0) {\n      this.emit('error'\x2C er);\n    }\n  }\n\n  prependListener(source\x2C 'error'\x2C onerror);\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data'\x2C ondata);\n    dest.removeListener('drain'\x2C ondrain);\n\n    source.removeListener('end'\x2C onend);\n    source.removeListener('close'\x2C onclose);\n\n    source.removeListener('error'\x2C onerror);\n    dest.removeListener('error'\x2C onerror);\n\n    source.removeListener('end'\x2C cleanup);\n    source.removeListener('close'\x2C cleanup);\n\n    dest.removeListener('close'\x2C cleanup);\n  }\n\n  source.on('end'\x2C cleanup);\n  source.on('close'\x2C cleanup);\n\n  dest.on('close'\x2C cleanup);\n  dest.emit('pipe'\x2C source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nfunction prependListener(emitter\x2C event\x2C fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function')\n    return emitter.prependListener(event\x2C fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event\x2C fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn\x2C emitter._events[event]];\n}\n\nmodule.exports = { Stream\x2C prependListener };\n
code-source-info,0x315766fab9e6,50,127,160,C0O138C5O141C10O141C17O159,,
code-creation,LazyCompile,10,159720,0x315766fac2ae,354,ReadableState node:internal/streams/readable:78:23,0x3157dbed51b8,~
code-source-info,0x315766fac2ae,49,2519,6226,C0O2857C6O2896C8O2925C11O2932C15O2914C20O3065C25O3086C27O3105C33O3081C37O3121C41O3162C52O3185C54O3204C60O3155C64O3370C69O3391C73O3405C88O3405C97O3478C102O3478C106O3389C110O3681C112O3699C115O3695C120O3693C124O3715C125O3727C129O3734C131O3745C135O3753C136O3766C140O3776C141O3787C145O3798C146O3814C150O3825C151O3838C155O4032C156O4049C160O4329C161O4339C165O4460C166O4478C170O4489C171O4510C175O4521C176O4544C180O4555C181O4576C185O4587C187O4592C191O4601C195O4687C196O4705C200O4776C202O4794C208O4813C214O4823C218O4791C222O4910C224O4930C230O4949C236O4961C240O4927C244O5003C245O5018C249O5271C250O5284C254O5354C255O5366C259O5470C260O5488C264O5695C269O5719C271O5738C279O5716C283O5871C284O5894C288O5904C289O5925C293O5987C294O6004C298O6016C299O6033C303O6045C304O6058C308O6068C309O6082C313O6092C317O6115C323O6131C325O6150C328O6172C335O6146C340O6144C344O6211C348O6201C353O6225,,
tick,0x7ff803d76d01,159833,0,0x0,3,0x107791470,0x315766fa8c6d,0x315766fa859a,0x315766fa80aa,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,159876,0x315766fac6be,98,getHighWaterMark node:internal/streams/state:19:26,0x3157dbeda3b8,~
script-source,53,node:internal/streams/state,'use strict';\n\nconst {\n  MathFloor\x2C\n  NumberIsInteger\x2C\n} = primordials;\n\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\n\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark :\n    isDuplex ? options[duplexKey] : null;\n}\n\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? 16 : 16 * 1024;\n}\n\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\n    }\n    return MathFloor(hwm);\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode);\n}\n\nmodule.exports = {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n};\n
code-source-info,0x315766fac6be,53,424,832,C0O478C12O478C18O529C21O552C26O557C33O585C38O611C47O633C56O678C69O684C74O678C75O732C80O739C84O754C85O781C88O818C93O788C97O830,,
code-creation,LazyCompile,10,160029,0x315766fac956,26,highWaterMarkFrom node:internal/streams/state:10:27,0x3157dbeda258,~
code-source-info,0x315766fac956,53,168,309,C0O218C7O250C15O270C19O288C25O307,,
code-creation,LazyCompile,10,160079,0x315766faca2e,13,getDefaultHighWaterMark node:internal/streams/state:15:33,0x3157dbeda368,~
code-source-info,0x315766faca2e,53,343,397,C0O360C12O395,,
code-creation,LazyCompile,10,160126,0x315766facb0e,17,BufferList node:internal/streams/buffer_list:14:14,0x3157dbed9738,~
script-source,52,node:internal/streams/buffer_list,'use strict';\n\nconst {\n  StringPrototypeSlice\x2C\n  SymbolIterator\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { inspect } = require('internal/util/inspect');\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v\x2C next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v\x2C next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    let p = this.head;\n    let ret = '' + p.data;\n    while (p = p.next)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret\x2C p.data\x2C i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n\x2C hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0\x2C n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift();\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n\n  first() {\n    return this.head.data;\n  }\n\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = '';\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str\x2C 0\x2C n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str\x2C n);\n        }\n        break;\n      }\n      ++c;\n    } while (p = p.next);\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret\x2C\n                                 new Uint8Array(buf.buffer\x2C buf.byteOffset\x2C n)\x2C\n                                 retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while (p = p.next);\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n};\n
code-source-info,0x315766facb0e,52,265,338,C0O274C1O284C5O296C6O306C10O318C11O330C16O337,,
code-creation,LazyCompile,10,160526,0x315766fad25e,98,construct node:internal/streams/destroy:225:19,0x3157dbec90f8,~
script-source,47,node:internal/streams/destroy,'use strict';\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_MULTIPLE_CALLBACK\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  Symbol\x2C\n} = primordials;\n\nconst kDestroy = Symbol('kDestroy');\nconst kConstruct = Symbol('kConstruct');\n\nfunction checkError(err\x2C w\x2C r) {\n  if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err\x2C cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  // With duplex streams we use the writable side for state.\n  const s = w || r;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb();\n    }\n\n    return this;\n  }\n\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err\x2C w\x2C r);\n\n  if (w) {\n    w.destroyed = true;\n  }\n  if (r) {\n    r.destroyed = true;\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy\x2C function(er) {\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\n    });\n  } else {\n    _destroy(this\x2C err\x2C cb);\n  }\n\n  return this;\n}\n\nfunction _destroy(self\x2C err\x2C cb) {\n  let called = false;\n\n  function onDestroy(err) {\n    if (called) {\n      return;\n    }\n    called = true;\n\n    const r = self._readableState;\n    const w = self._writableState;\n\n    checkError(err\x2C w\x2C r);\n\n    if (w) {\n      w.closed = true;\n    }\n    if (r) {\n      r.closed = true;\n    }\n\n    if (typeof cb === 'function') {\n      cb(err);\n    }\n\n    if (err) {\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\n    } else {\n      process.nextTick(emitCloseNT\x2C self);\n    }\n  }\n  try {\n    const result = self._destroy(err || null\x2C onDestroy);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            process.nextTick(onDestroy\x2C null);\n          }\x2C\n          function(err) {\n            process.nextTick(onDestroy\x2C err);\n          });\n      }\n    }\n  } catch (err) {\n    onDestroy(err);\n  }\n}\n\nfunction emitErrorCloseNT(self\x2C err) {\n  emitErrorNT(self\x2C err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w) {\n    w.closeEmitted = true;\n  }\n  if (r) {\n    r.closeEmitted = true;\n  }\n\n  if ((w && w.emitClose) || (r && r.emitClose)) {\n    self.emit('close');\n  }\n}\n\nfunction emitErrorNT(self\x2C err) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if ((w && w.errorEmitted) || (r && r.errorEmitted)) {\n    return;\n  }\n\n  if (w) {\n    w.errorEmitted = true;\n  }\n  if (r) {\n    r.errorEmitted = true;\n  }\n\n  self.emit('error'\x2C err);\n}\n\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = false;\n    r.endEmitted = false;\n  }\n\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.ended = false;\n    w.ending = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.finished = false;\n  }\n}\n\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick\x2C so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    return this;\n  }\n\n  if ((r && r.autoDestroy) || (w && w.autoDestroy))\n    stream.destroy(err);\n  else if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\n    } else {\n      emitErrorNT(stream\x2C err);\n    }\n  }\n}\n\nfunction construct(stream\x2C cb) {\n  if (typeof stream._construct !== 'function') {\n    return;\n  }\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (r) {\n    r.constructed = false;\n  }\n  if (w) {\n    w.constructed = false;\n  }\n\n  stream.once(kConstruct\x2C cb);\n\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return;\n  }\n\n  process.nextTick(constructNT\x2C stream);\n}\n\nfunction constructNT(stream) {\n  let called = false;\n\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n\n    if (r) {\n      r.constructed = true;\n    }\n    if (w) {\n      w.constructed = true;\n    }\n\n    if (s.destroyed) {\n      stream.emit(kDestroy\x2C err);\n    } else if (err) {\n      errorOrDestroy(stream\x2C err\x2C true);\n    } else {\n      process.nextTick(emitConstructNT\x2C stream);\n    }\n  }\n\n  try {\n    const result = stream._construct(onConstruct);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            process.nextTick(onConstruct\x2C null);\n          }\x2C\n          function(err) {\n            process.nextTick(onConstruct\x2C err);\n          });\n      }\n    }\n  } catch (err) {\n    onConstruct(err);\n  }\n}\n\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct);\n}\n\nfunction isRequest(stream) {\n  return stream && stream.setHeader && typeof stream.abort === 'function';\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream\x2C err) {\n  if (!stream) return;\n  if (isRequest(stream)) return stream.abort();\n  if (isRequest(stream.req)) return stream.req.abort();\n  if (typeof stream.destroy === 'function') return stream.destroy(err);\n  if (typeof stream.close === 'function') return stream.close();\n}\n\nmodule.exports = {\n  construct\x2C\n  destroyer\x2C\n  destroy\x2C\n  undestroy\x2C\n  errorOrDestroy\n};\n
code-source-info,0x315766fad25e,47,4626,5014,C0O4661C8O4694C9O4701C10O4726C15O4761C20O4780C24O4793C25O4807C29O4822C33O4835C34O4849C38O4872C45O4877C48O4872C54O4908C61O4922C64O4908C72O4934C77O4959C78O4966C79O4974C82O4982C90O4982C97O5013,,
tick,0x7ff803e80cfd,161069,0,0x0,3,0x1077801f0,0x315766fa8cfa,0x315766fa859a,0x315766fa80aa,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,161155,0x315766fadf0e,266,Writable node:internal/streams/writable:219:18,0x3157dbee3428,~
script-source,56,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  FunctionPrototypeSymbolHasInstance\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignalNoValidate\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_STREAM_CANNOT_PIPE\x2C\n  ERR_STREAM_DESTROYED\x2C\n  ERR_STREAM_ALREADY_FINISHED\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n  ERR_STREAM_WRITE_AFTER_END\x2C\n  ERR_UNKNOWN_ENCODING\n} = require('internal/errors').codes;\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Writable\x2C Stream);\n\nfunction nop() {}\n\nconst kOnFinished = Symbol('kOnFinished');\n\nfunction WritableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream\x2C\n  // e.g. options.readableObjectMode vs. options.writableObjectMode\x2C etc.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.writableObjectMode);\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value\x2C means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // if _final has been called.\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // At the start of calling end()\n  this.ending = false;\n  // When end() has been called\x2C and returned.\n  this.ended = false;\n  // When 'finish' is emitted.\n  this.finished = false;\n\n  // Has it been destroyed\n  this.destroyed = false;\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false);\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Not an actual buffer we keep track of\x2C but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\n  // or on a later tick.  We set this to true at first\x2C because any\n  // actions that shouldn't happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // A flag to know if we're processing previously buffered items\x2C which\n  // may call the _write() callback in the same tick\x2C so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // The callback that's passed to _write(chunk\x2C cb).\n  this.onwrite = onwrite.bind(undefined\x2C stream);\n\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\n  this.writecb = null;\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  this[kOnFinished] = [];\n}\n\nfunction resetBuffer(state) {\n  state.buffered = [];\n  state.bufferedIndex = 0;\n  state.allBuffers = true;\n  state.allNoop = true;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\n  get() {\n    return this.buffered.length - this.bufferedIndex;\n  }\n});\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes\x2C too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false\x2C as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation\x2C which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor\x2C at least with V8 6.5.\n  const isDuplex = (this instanceof Stream.Duplex);\n\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable\x2C this))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n    if (options.signal)\n      addAbortSignalNoValidate(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    const state = this._writableState;\n\n    if (!state.writing) {\n      clearBuffer(this\x2C state);\n    }\n\n    finishMaybe(this\x2C state);\n  });\n}\n\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  }\x2C\n});\n\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\n  const state = stream._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = state.defaultEncoding;\n  } else {\n    if (!encoding)\n      encoding = state.defaultEncoding;\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (typeof cb !== 'function')\n      cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  let err;\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb\x2C err);\n    errorOrDestroy(stream\x2C err\x2C true);\n    return err;\n  }\n  state.pendingcb++;\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\n}\n\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing)\n      clearBuffer(this\x2C state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something\x2C then just put this\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\n// If we return false\x2C then we need a drain event\x2C so set that flag.\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\n  const len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark;\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({ chunk\x2C encoding\x2C callback });\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false;\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false;\n    }\n  } else {\n    state.writelen = len;\n    state.writecb = callback;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n    state.sync = false;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed;\n}\n\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk\x2C state.onwrite);\n  else\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write\x2C not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error\x2C but error must always follow cb.\n  errorOrDestroy(stream\x2C er);\n}\n\nfunction onwrite(stream\x2C er) {\n  const state = stream._writableState;\n  const sync = state.sync;\n  const cb = state.writecb;\n\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\n    } else {\n      onwriteError(stream\x2C state\x2C er\x2C cb);\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream\x2C state);\n    }\n\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\n      // rather just increase a counter\x2C to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null &&\n          state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++;\n      } else {\n        state.afterWriteTickInfo = { count: 1\x2C cb\x2C stream\x2C state };\n        process.nextTick(afterWriteTick\x2C state.afterWriteTickInfo);\n      }\n    } else {\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\n  state.afterWriteTickInfo = null;\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\n}\n\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&\n    state.needDrain;\n  if (needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb();\n  }\n\n  if (state.destroyed) {\n    errorBuffer(state);\n  }\n\n  finishMaybe(stream\x2C state);\n}\n\n// If there's something in the buffer waiting\x2C then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return;\n  }\n\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    const { chunk\x2C callback } = state.buffered[n];\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length -= len;\n    callback(new ERR_STREAM_DESTROYED('write'));\n  }\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](new ERR_STREAM_DESTROYED('end'));\n  }\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting\x2C then process it.\nfunction clearBuffer(stream\x2C state) {\n  if (state.corked ||\n      state.bufferProcessing ||\n      state.destroyed ||\n      !state.constructed) {\n    return;\n  }\n\n  const { buffered\x2C bufferedIndex\x2C objectMode } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state.bufferProcessing = true;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = state.allNoop ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\n    chunks.allBuffers = state.allBuffers;\n\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\n    } while (i < buffered.length && !state.writing);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0\x2C i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\n  if (this._writev) {\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this\x2C chunk\x2C encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However\x2C usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true;\n    finishMaybe(this\x2C state\x2C true);\n    state.ended = true;\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb\x2C err);\n    } else {\n      state[kOnFinished].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (state.ending &&\n          state.constructed &&\n          state.length === 0 &&\n          !state.errored &&\n          state.buffered.length === 0 &&\n          !state.finished &&\n          !state.writing &&\n          !state.errorEmitted &&\n          !state.closeEmitted);\n}\n\nfunction callFinal(stream\x2C state) {\n  let called = false;\n\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    state.pendingcb--;\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err);\n      }\n      errorOrDestroy(stream\x2C err\x2C state.sync);\n    } else if (needFinish(state)) {\n      state.prefinished = true;\n      stream.emit('prefinish');\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++;\n      process.nextTick(finish\x2C stream\x2C state);\n    }\n  }\n\n  state.sync = true;\n  state.pendingcb++;\n\n  try {\n    const result = stream._final(onFinish);\n    if (result != null) {\n      const then = result.then;\n      if (typeof then === 'function') {\n        then.call(\n          result\x2C\n          function() {\n            process.nextTick(onFinish\x2C null);\n          }\x2C\n          function(err) {\n            process.nextTick(onFinish\x2C err);\n          });\n      }\n    }\n  } catch (err) {\n    onFinish(stream\x2C state\x2C err);\n  }\n\n  state.sync = false;\n}\n\nfunction prefinish(stream\x2C state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true;\n      callFinal(stream\x2C state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream\x2C state\x2C sync) {\n  if (needFinish(state)) {\n    prefinish(stream\x2C state);\n    if (state.pendingcb === 0 && needFinish(state)) {\n      state.pendingcb++;\n      if (sync) {\n        process.nextTick(finish\x2C stream\x2C state);\n      } else {\n        finish(stream\x2C state);\n      }\n    }\n  }\n}\n\nfunction finish(stream\x2C state) {\n  state.pendingcb--;\n  state.finished = true;\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]();\n  }\n\n  stream.emit('finish');\n\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nObjectDefineProperties(Writable.prototype\x2C {\n\n  destroyed: {\n    get() {\n      return this._writableState ? this._writableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value;\n      }\n    }\n  }\x2C\n\n  writable: {\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored &&\n        !w.ending && !w.ended;\n    }\x2C\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\n  }\x2C\n\n  writableFinished: {\n    get() {\n      return this._writableState ? this._writableState.finished : false;\n    }\n  }\x2C\n\n  writableObjectMode: {\n    get() {\n      return this._writableState ? this._writableState.objectMode : false;\n    }\n  }\x2C\n\n  writableBuffer: {\n    get() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  }\x2C\n\n  writableEnded: {\n    get() {\n      return this._writableState ? this._writableState.ending : false;\n    }\n  }\x2C\n\n  writableNeedDrain: {\n    get() {\n      const wState = this._writableState;\n      if (!wState) return false;\n      return !wState.destroyed && !wState.ending && wState.needDrain;\n    }\n  }\x2C\n\n  writableHighWaterMark: {\n    get() {\n      return this._writableState && this._writableState.highWaterMark;\n    }\n  }\x2C\n\n  writableCorked: {\n    get() {\n      return this._writableState ? this._writableState.corked : 0;\n    }\n  }\x2C\n\n  writableLength: {\n    get() {\n      return this._writableState && this._writableState.length;\n    }\n  }\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err\x2C cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if (!state.destroyed &&\n    (state.bufferedIndex < state.buffered.length ||\n      state[kOnFinished].length)) {\n    process.nextTick(errorBuffer\x2C state);\n  }\n\n  destroy.call(this\x2C err\x2C cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n
code-source-info,0x315766fadf0e,56,7409,8929,C0O7409C9O7983C16O8000C19O8007C23O7989C27O8019C33O8037C44O8037C51O8093C58O8100C63O8122C64O8126C83O8148C88O8146C92O8195C96O8233C104O8261C107O8283C111O8273C115O8314C123O8343C126O8366C130O8356C134O8398C142O8428C145O8452C149O8442C153O8485C161O8513C164O8535C168O8525C172O8566C180O8598C183O8624C187O8614C191O8651C197O8665C204O8698C212O8665C217O8720C224O8727C232O8727C238O8751C245O8763C258O8763C265O8928,,
tick,0x1070463be,162957,0,0x0,3,0x1077801f0,0x315766fa85aa,0x315766fa80aa,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,163044,0x315766faff5e,341,WritableState node:internal/streams/writable:77:23,0x3157dbee32c8,~
code-source-info,0x315766faff5e,56,2482,6983,C0O2816C6O2855C8O2884C11O2891C15O2873C20O2999C25O3020C27O3039C33O3015C37O3055C41O3096C52O3119C54O3138C60O3089C64O3347C69O3368C73O3382C88O3382C97O3455C102O3455C106O3366C110O3522C111O3539C115O3574C116O3589C120O3635C121O3647C125O3705C126O3716C130O3758C131O3772C135O3811C136O3826C140O4025C144O4047C150O4061C156O4075C158O4097C159O4094C163O4305C168O4329C170O4348C178O4326C182O4526C183O4538C187O4602C188O4615C192O4692C193O4704C197O4968C198O4978C202O5181C203O5203C207O5269C210O5292C217O5292C223O5282C227O5392C228O5405C232O5477C233O5491C237O5606C238O5630C242O5641C245O5641C249O5768C250O5783C254O5973C255O5990C259O6128C260O6145C264O6232C265O6250C269O6321C271O6339C277O6358C283O6368C287O6336C291O6455C293O6475C299O6494C305O6506C309O6472C313O6729C314O6742C318O6812C319O6824C323O6928C324O6946C328O6958C330O6963C335O6976C340O6982,,
code-creation,LazyCompile,10,163174,0x315766fb036e,23,resetBuffer node:internal/streams/writable:202:21,0x3157dbee3318,~
code-source-info,0x315766fb036e,56,7005,7117,C0O7017C2O7032C6O7040C7O7060C11O7067C12O7084C16O7094C17O7108C22O7116,,
code-creation,LazyCompile,10,163260,0x315766fb0476,21,set node:internal/streams/readable:1175:8,0x3157dbed61b0,~
code-source-info,0x315766fb0476,49,35837,35964,C0O35887C6O35918C13O35946C15O35942C20O35963,,
code-creation,LazyCompile,10,163331,0x315766fb05ce,131,createHandle node:net:137:22,0x3157a91fb550,~
code-source-info,0x315766fb05ce,120,3597,3957,C0O3617C13O3617C18O3660C23O3660C28O3683C30O3692C35O3710C42O3733C46O3745C49O3759C57O3768C60O3782C67O3717C72O3795C73O3803C75O3812C80O3829C87O3851C91O3863C94O3876C102O3885C105O3898C112O3836C117O3911C118O3919C125O3925C130O3919,,
code-creation,LazyCompile,10,163480,0x315766fb076e,14,set node:net:1707:6,0x3157a91fd590,~
code-source-info,0x315766fb076e,120,45570,45603,C0O45576C2O45588C7O45597C13O45601,,
tick,0x10767c40b,163522,0,0x0,3,0x1077801f0,0x107b32519,0x315766fa80ec,0x315766f9e047,0x3157a91e6d79,0x3157a91e2c1b,0x3157a91e1dee,0x3157a91d0b4f,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,LazyCompile,10,163546,0x315766fb085e,8,get node:net:1706:6,0x3157a91fd540,~
code-source-info,0x315766fb085e,120,45535,45563,C0O45540C2O45552C4O45551C7O45561,,
code-creation,LazyCompile,10,163686,0x315766fb0a0e,196,Readable.on node:internal/streams/readable:875:33,0x3157dbed5ae8,~
code-source-info,0x315766fb0a0e,49,27773,28672,C0O27798C5O27805C10O27815C15O27818C29O27818C35O27859C40O27878C42O27885C47O28067C55O28067C62O28093C65O28060C69O28186C75O28194C80O28216C85O28216C91O28235C93O28242C98O28275C104O28296C110O28323C112O28368C118O28347C122O28382C123O28396C127O28411C128O28433C132O28448C140O28475C145O28489C150O28448C155O28515C161O28533C164O28533C170O28577C176O28596C179O28604C187O28604C193O28659C195O28670,,
code-creation,LazyCompile,10,163786,0x315766fb0c86,135,initSocketHandle node:net:254:26,0x3157a91fb730,~
code-source-info,0x315766fb0c86,120,6321,6899,C0O6337C5O6337C9O6353C10O6368C14O6454C20O6474C27O6482C32O6496C36O6513C43O6530C45O6528C49O6548C51O6553C57O6591C62O6572C66O6570C70O6620C72O6625C74O6624C78O6639C80O6675C82O6680C84O6679C88O6699C90O6740C94O6758C99O6763C105O6796C106O6803C107O6812C109O6817C114O6826C118O6856C123O6864C128O6864C134O6898,,
code-creation,LazyCompile,10,163859,0x315766fb0eb6,120,undestroy node:internal/streams/destroy:160:19,0x3157dbec9038,~
code-source-info,0x315766fb0eb6,47,3064,3661,C0O3086C5O3119C10O3138C14O3151C15O3165C19O3177C20O3186C24O3199C25O3214C29O3227C30O3239C34O3252C35O3262C39O3274C40O3289C44O3302C45O3312C49O3325C50O3333C54O3346C55O3359C59O3375C63O3388C64O3402C68O3414C69O3426C73O3439C74O3448C78O3461C79O3476C83O3489C84O3499C88O3511C89O3526C93O3539C94O3547C98O3560C99O3569C103O3582C104O3596C108O3609C109O3623C113O3636C114O3647C119O3660,,
code-creation,LazyCompile,10,163947,0x315766fb112e,32,getNewAsyncId node:net:156:23,0x3157a91fb5a0,~
code-source-info,0x315766fb112e,120,3982,4098,C0O3995C4O4028C14O4061C17O4061C22O4083C27O4083C31O4096,,
code-creation,LazyCompile,10,164006,0x315766fb122e,5,get node:internal/bootstrap/pre_execution:314:8,0x31576e51ced0,~
code-source-info,0x315766fb122e,92,10085,10118,C0O10096C4O10112,,
code-creation,LazyCompile,10,164051,0x315766fb1306,5,get /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/redir-stdout.js:19:10,0x315766f9dd90,~
code-source-info,0x315766fb1306,130,392,404,C0O398C4O404,,
code-creation,Function,11,164343,0x10f8c7660,7676,realpathSync node:fs:2408:22,0x31572ee62988,^
code-source-info,0x10f8c7660,77,63994,67905,,,
code-creation,Function,11,164376,0x10f8c94c0,216, node:vm:313:27,0x3157a91e8740,^
code-source-info,0x10f8c94c0,85,9752,9803,,,
code-creation,Function,11,164396,0x10f8c9600,40,noop node:internal/util/debuglog:47:14,0x31571587aa60,^
code-source-info,0x10f8c9600,40,1419,1427,,,
code-creation,Function,11,164423,0x10f8c96a0,1020,debuglog node:internal/util/debuglog:71:18,0x31571587ab00,^
code-source-info,0x10f8c96a0,40,2232,3279,,,
code-creation,Function,11,164446,0x10f8c9b00,252,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x31575b54f658,^
code-source-info,0x10f8c9b00,9,7353,7449,,,
tick,0x107bb11ab,164514,0,0x0,0,0x3157a91d0a40,0x3157a91d071a,0x3157a91cfbcb,0x3157a91cf97d,0x31576e502490,0x3157b57fbe0d
code-creation,Eval,10,164736,0x315766fb2156,5, /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/soft-exit.js:1:1,0x315766fb2010,~
script-source,136,/Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/soft-exit.js,'use strict'\n\nprocess.on('SIGINT'\x2C process.exit)\nprocess.on('SIGTERM'\x2C process.exit)\n
code-source-info,0x315766fb2156,136,0,85,C0O0C4O85,,
code-creation,Function,10,164786,0x315766fb21f6,56, /Users/iramgutierrez/.nvm/versions/node/v16.13.2/lib/node_modules/0x/lib/preload/soft-exit.js:1:1,0x315766fb20d0,~
code-source-info,0x315766fb21f6,136,0,85,C0O14C4O22C12O35C16O43C21O22C27O49C31O57C39O71C43O79C48O57C55O84,,
code-creation,LazyCompile,10,164943,0x315766fb2856,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:466:36,0x3157b57fe3c0,~
code-source-info,0x315766fb2856,92,15016,15238,C0O15023C8O15027C14O15072C17O15080C28O15080C34O15192C40O15192C45O15229C49O15237,,
code-creation,LazyCompile,10,165014,0x315766fb297e,80,executeUserEntryPoint node:internal/modules/run_main:74:31,0x3157a91ceb78,~
code-source-info,0x315766fb297e,114,2320,2625,C7O2336C14O2340C22O2370C25O2370C30O2416C33O2416C38O2452C40O2476C45O2487C50O2476C56O2588C61O2595C73O2595C79O2624,,
code-creation,LazyCompile,10,165068,0x315766fb2dce,68,resolveMainPath node:internal/modules/run_main:11:25,0x3157a91cea10,~
code-source-info,0x315766fb2dce,114,296,710,C0O468C5O475C12O485C15O490C20O490C30O475C36O520C38O539C39O546C40O579C48O579C53O625C55O656C60O667C65O692C67O708,,
code-creation,LazyCompile,10,165280,0x315766fb324e,109,shouldUseESMLoader node:internal/modules/run_main:26:28,0x3157a91cea60,~
code-source-info,0x315766fb324e,114,739,1299,C0O773C8O773C13O816C15O836C16O848C17O891C25O891C30O948C32O980C37O996C38O1008C39O1056C45O1072C51O1072C58O1119C59O1131C60O1134C66O1151C72O1151C79O1198C80O1211C81O1226C86O1226C91O1256C93O1274C98O1279C105O1284C108O1297,,
code-creation,LazyCompile,10,165370,0x315766fb34c6,70,runMainESM node:internal/modules/run_main:43:20,0x3157a91ceab0,~
code-source-info,0x315766fb34c6,114,1320,1635,C0O1320C12O1355C20O1355C25O1343C30O1423C38O1423C43O1405C49O1451C54O1469C59O1469C64O1451C69O1634,,
code-creation,LazyCompile,10,165448,0x315766fb3706,222,loadESM node:internal/process/esm_loader:85:41,0x31576e5263f0,~
code-source-info,0x315766fb3706,101,2568,2881,C10O2568C21O2593C24O2599C35O2593C58O2623C60O2638C63O2629C75O2623C113O2672C120O2676C125O2723C130O2731C138O2731C143O2759C154O2766C155O2777C163O2777C168O2802C178O2803C197O2880,,
code-creation,LazyCompile,10,165603,0x315766fb3d26,284,initializeLoader node:internal/process/esm_loader:50:32,0x31576e5262c0,~
code-source-info,0x315766fb3d26,101,1441,2526,C10O1441C18O1475C24O1475C29O1456C34O1637C37O1637C42O1700C48O1708C59O1715C60O1755C66O1755C71O1727C76O1783C79O1783C83O1840C88O1857C91O1871C96O1871C103O1877C110O1861C111O1900C114O2159C119O2159C125O2298C132O2329C135O2329C140O2347C147O2358C152O2358C163O2304C176O2274C202O2482C207O2498C212O2498C225O2482C259O2525,,
tick,0x107501050,165653,0,0x0,3,0x1077801f0,0x315766fb371e,0x315766fb3501,0x315766fb29b0,0x3157b57fbe31
code-creation,LazyCompile,10,165693,0x315766fb4066,170,handleMainPromise node:internal/modules/run_main:55:33,0x3157a91ceb00,~
code-source-info,0x315766fb4066,114,1669,2104,C10O1669C23O1988C26O1996C34O1996C43O2029C53O2036C90O2069C93O2077C101O2077C145O2103,,
code-creation,LazyCompile,10,165754,0x315766fb4246,55, node:internal/modules/run_main:47:29,0x315766fb3400,~
code-source-info,0x315766fb4246,114,1477,1630,C0O1511C7O1516C15O1516C24O1545C30O1545C35O1568C44O1613C49O1619C54O1626,,
code-creation,LazyCompile,10,165925,0x315766fb449e,283,pathToFileURL node:internal/url:1455:23,0x31571585b0a0,~
code-source-info,0x315766fb449e,33,40085,41314,C0O40115C10O40115C16O40137C24O40154C30O40154C37O40267C45O40267C51O40319C58O40326C63O40340C79O40346C84O40340C85O40483C87O40488C91O40510C97O40517C102O40532C118O40538C123O40532C124O40653C127O40671C131O40669C135O40700C140O40741C145O40760C151O40760C160O40741C166O40718C170O40716C176O40828C181O40833C186O40833C192O40946C197O41042C201O41049C205O40946C211O41059C213O41081C215O41077C222O41113C228O41143C230O41139C235O41194C239O41201C242O41184C248O41210C251O41215C255O41206C260O41226C269O41247C272O41265C276O41263C280O41298C282O41312,,
code-creation,LazyCompile,10,166113,0x315766fb476e,117,URL node:internal/url:620:14,0x315715859eb8,~
code-source-info,0x315766fb476e,33,16989,17336,C13O17055C17O17083C19O17101C23O17133C30O17148C40O17162C42O17161C46O17182C50O17187C57O17202C60O17198C65O17196C69O17220C85O17272C93O17272C110O17220C116O17335,,
code-creation,LazyCompile,10,166180,0x315766fb493e,51,URLContext node:internal/url:160:14,0x315715859640,~
code-source-info,0x315766fb493e,33,3700,3912,C0O3709C1O3720C5O3729C7O3741C11O3752C13O3766C17O3776C19O3790C23O3800C24O3810C28O3822C29O3832C33O3844C35O3854C39O3864C40O3875C44O3887C45O3901C50O3911,,
code-creation,LazyCompile,10,166332,0x315766fb4b86,190,onParseComplete node:internal/url:532:25,0x315715859be8,~
code-source-info,0x315766fb4b86,33,14195,14864,C0O14309C2O14314C4O14313C8O14326C10O14336C14O14347C16O14358C20O14372C22O14396C24O14394C29O14420C43O14385C47O14445C49O14469C51O14467C56O14493C70O14458C74O14518C76O14527C80O14537C82O14557C84O14555C89O14577C101O14585C103O14546C107O14598C109O14608C113O14619C115O14632C119O14646C121O14655C125O14665C127O14675C129O14674C134O14728C136O14733C141O14753C144O14749C149O14747C153O14776C155O14781C157O14780C163O14795C168O14804C172O14818C177O14840C179O14839C183O14818C189O14863,,
code-creation,LazyCompile,10,166533,0x315766fb4ff6,889,URLSearchParams node:internal/url:182:14,0x3157158596e0,~
code-source-info,0x315766fb4ff6,33,4325,6722,C10O4350C16O4399C18O4404C24O4418C30O4435C42O4518C44O4523C46O4522C50O4546C52O4566C54O4565C57O4557C62O4764C64O4769C66O4768C71O4792C73O4797C77O4825C83O4825C87O4811C93O4847C101O4902C107O4948C119O4954C124O4948C125O5148C128O5179C156O5171C187O5171C190O5197C208O5318C210O5317C217O5364C233O5370C238O5364C239O5473C243O5509C271O5498C302O5498C305O5527C313O5561C317O5561C323O5527C331O5487C407O5594C413O5594C418O5160C492O5655C494O5660C500O5674C504O5707C532O5699C563O5699C566O5735C574O5742C579O5763C595O5769C600O5763C601O5850C609O5874C611O5873C617O5893C624O5902C629O5850C634O5688C707O6046C709O6051C715O6065C719O6092C725O6092C730O6135C732O6147C736O6140C741O6184C743O6188C747O6216C753O6216C759O6270C761O6301C767O6344C773O6344C778O6393C786O6409C791O6393C796O6429C798O6434C800O6433C805O6448C811O6448C817O6156C822O6122C827O6544C833O6551C838O6576C839O6584C846O6588C851O6609C861O6609C867O6625C871O6625C876O6697C878O6702C883O6711C888O6721,,
code-creation,LazyCompile,10,166631,0x315766fb55ce,35,initSearchParams node:internal/url:1016:26,0x31571585ac00,~
code-source-info,0x315766fb55ce,33,27049,27164,C0O27065C4O27082C6O27086C11O27100C15O27110C16O27117C17O27124C19O27128C25O27144C29O27142C34O27163,,
code-creation,LazyCompile,10,166706,0x315766fb577e,199,encodePathChars node:internal/url:1440:25,0x31571585b050,~
code-source-info,0x315766fb577e,33,39369,40061,C0O39384C8O39388C15O39432C22O39476C31O39443C38O39556C46O39574C52O39574C59O39619C66O39663C75O39630C82O39689C90O39693C97O39738C104O39782C113O39749C120O39806C128O39810C135O39855C142O39899C151O39866C158O39930C166O39934C173O39979C180O40023C189O39990C196O40043C198O40059,,
code-creation,LazyCompile,10,166768,0x315766fb59ae,70,set pathname node:internal/url:884:15,0x31571585a7f0,~
code-source-info,0x315766fb59ae,33,23625,23827,C0O23672C5O23694C9O23703C11O23702C16O23724C17O23731C18O23736C29O23748C38O23771C40O23770C49O23811C54O23811C63O23736C69O23826,,
code-creation,LazyCompile,10,166828,0x315766fb5afe,31, node:internal/url:636:21,0x315715859f90,~
code-source-info,0x315766fb5afe,33,17443,17518,C0O17452C4O17465C6O17464C10O17474C19O17482C21O17480C26O17508C30O17514,,
tick,0x1072a3c40,166855,0,0x0,2,0x1077801f0,0x315766fb59b9,0x107b32519,0x315766fb45b2,0x315766fb4264,0x315766fb3745,0x107af48ff
code-creation,LazyCompile,10,166935,0x315766fb5c2e,108,onParsePathComplete node:internal/url:591:29,0x315715859dc8,~
code-source-info,0x315766fb5c2e,33,16154,16620,C0O16272C2O16277C4O16276C8O16289C10O16302C12O16300C17O16322C22O16335C24O16344C28O16356C35O16369C40O16366C46O16404C48O16413C52O16423C59O16437C61O16436C66O16433C70O16515C72O16528C74O16526C79O16548C84O16561C86O16570C90O16582C97O16595C102O16592C107O16619,,
code-creation,LazyCompile,10,166996,0x315766fb5dce,18,get href node:internal/url:734:11,0x31571585a120,~
code-source-info,0x315766fb5dce,33,20108,20146,C0O20117C4O20129C6O20128C12O20137C17O20142,,
code-creation,LazyCompile,10,167085,0x315766fb606e,393, node:internal/url:682:12,0x31571585a080,~
code-source-info,0x315766fb606e,33,18743,19993,C0O18759C4O18778C14O18778C19O18819C30O18922C37O18953C41O18958C43O18957C47O19038C52O19058C58O19081C67O19125C74O19134C79O19173C86O19182C91O19208C99O19217C103O19233C105O19258C109O19297C120O19315C124O19343C127O19358C142O19378C151O19419C165O19457C170O19437C176O19469C184O19489C190O19512C193O19527C208O19545C212O19554C214O19553C219O19588C225O19592C237O19624C243O19645C248O19650C255O19657C260O19668C266O19672C272O19676C277O19694C286O19729C291O19734C297O19752C304O19765C307O19788C315O19765C320O19763C330O19830C336O19844C342O19866C345O19881C360O19906C366O19922C372O19947C375O19962C390O19978C392O19989,,
code-creation,LazyCompile,10,167165,0x315766fb6406,99, node:internal/validators:153:3,0x31573525a0a8,~
code-source-info,0x315766fb6406,17,4365,4924,C0O4423C4O4463C9O4499C14O4537C21O4573C26O4609C33O4645C38O4659C46O4706C50O4720C53O4720C67O4795C75O4860C91O4866C96O4860C98O4923,,
code-creation,LazyCompile,10,167261,0x315766fb66ee,300,import node:internal/modules/esm/loader:268:15,0x31576e527758,~
code-source-info,0x315766fb66ee,102,7099,7615,C10O7099C18O7144C25O7144C30O7174C32O7187C41O7201C50O7244C55O7269C64O7269C70O7305C81O7478C90O7320C98O7310C100O7310C116O7347C123O7370C128O7347C135O7394C146O7395C152O7428C162O7429C167O7340C178O7292C193O7504C204O7525C209O7521C215O7510C227O7504C253O7556C262O7607C275O7611,,
code-creation,LazyCompile,10,167358,0x315766fb6ac6,261,getModuleJob node:internal/modules/esm/loader:221:21,0x31576e527708,~
code-source-info,0x315766fb6ac6,102,5668,6606,C4O5668C30O5721C33O5732C38O5732C52O5721C75O5705C81O5713C86O5777C89O5782C94O5792C99O5792C105O5866C109O5897C112O5902C117O5912C122O5927C126O5912C132O5940C136O5963C148O5974C149O6003C154O6345C163O6386C169O6386C174O6430C199O6436C205O6556C208O6561C213O6571C218O6571C224O6591C236O6602,,
code-creation,LazyCompile,10,167453,0x315766fb6ed6,348,resolve node:internal/modules/esm/loader:402:16,0x31576e527848,~
code-source-info,0x315766fb6ed6,102,10560,11833,C10O10560C18O10612C22O10642C34O10710C37O10710C43O10741C63O10747C68O10741C69O10865C76O10914C78O10919C83O10929C87O10956C89O10961C93O10972C100O10979C111O11022C117O11032C121O11082C128O11117C134O11137C144O11066C157O11060C183O11192C189O11236C207O11242C212O11236C213O11364C218O11372C223O11397C234O11473C255O11479C260O11473C261O11615C267O11652C288O11658C293O11652C294O11789C301O11804C307O11818C323O11829,,
code-creation,LazyCompile,10,167680,0x315766fb74ae,885,defaultResolve node:internal/modules/esm/resolve:981:24,0x31576e52def0,~
code-source-info,0x315766fb74ae,105,32927,36210,C7O32927C16O32985C21O32996C26O33022C32O33039C38O33045C47O33081C53O33088C59O33097C65O33097C71O33133C73O33164C78O33173C84O33223C86O33246C92O33242C99O33223C106O33288C109O33300C110O33316C115O33336C120O33366C124O33418C130O33432C138O33446C144O33453C145O33468C149O33491C151O33504C157O33589C163O33612C170O33589C185O33500C192O33491C196O33667C201O33687C209O33696C215O33731C223O33740C228O33761C236O33783C242O33801C249O33823C253O33844C261O33853C266O33870C274O33884C280O33896C281O33899C285O33920C293O33929C298O33951C306O33960C311O33977C319O33983C324O33977C325O34029C331O34046C337O34046C344O34085C356O34113C365O34131C366O34138C372O34155C380O34155C387O34256C401O34256C406O34309C410O34336C412O34354C422O34391C428O34391C442O34366C448O34400C453O34812C459O34832C465O34838C470O34832C471O34879C475O34892C480O34928C485O34945C498O34951C508O34949C519O35119C523O35129C531O35134C540O35178C548O35183C553O35225C565O35229C572O35288C580O35300C585O35354C591O35354C597O35401C599O35503C611O35530C621O35503C627O35565C633O35591C645O35609C653O35633C657O35633C665O35660C672O35667C679O35684C688O35703C696O35703C701O35691C704O35621C708O35744C724O35766C731O35758C735O35792C737O35792C738O35812C744O35826C751O35850C756O35890C762O35890C767O35927C773O35940C781O35958C785O35969C793O35988C800O35927C806O36026C809O36035C817O36070C823O36103C827O36070C843O36067C848O36041C853O36143C857O36137C861O36170C865O36164C869O36183C877O36200C884O36208,,
code-creation,LazyCompile,10,167813,0x315766fb9d0e,15,get protocol node:internal/url:769:15,0x31571585a260,~
code-source-info,0x315766fb9d0e,33,20946,20987,C0O20955C4O20967C6O20966C10O20976C14O20983,,
tick,0x107ac9ced,167871,0,0x0,0,0x315766fb4c1b,0x107168bc0,0x315766fb47dc,0x315766fb44a8,0x315766fb7668,0x315766fb6f66,0x315766fb6aec,0x315766fb676e,0x315766fb4277,0x315766fb3745,0x107af48ff
code-creation,LazyCompile,10,167919,0x315766fb9e6e,64,getConditionsSet node:internal/modules/esm/resolve:164:26,0x31576e52d630,~
code-source-info,0x315766fb9e6e,105,5169,5496,C0O5186C6O5233C8O5229C13O5259C18O5264C24O5298C40O5304C45O5298C46O5426C53O5433C58O5457C59O5464C63O5494,,
code-creation,LazyCompile,10,167983,0x315766fb9fce,116,moduleResolve node:internal/modules/esm/resolve:917:23,0x31576e52de50,~
code-source-info,0x315766fb9fce,105,30750,31299,C0O30888C2O30900C5O30904C11O30962C24O30973C32O31008C33O31021C39O31025C44O31040C56O31056C62O31043C72O31136C79O31147C88O31145C89O31187C101O31198C107O31255C110O31262C115O31297,,
code-creation,LazyCompile,10,168029,0x315766fba156,31,shouldBeTreatedAsRelativeOrAbsolutePath node:internal/modules/esm/resolve:905:49,0x31576e52de00,~
code-source-info,0x315766fba156,105,30459,30594,C0O30475C2O30489C7O30497C8O30510C9O30513C10O30526C16O30530C21O30539C22O30551C23O30554C26O30561C30O30592,,
code-creation,LazyCompile,10,168072,0x315766fba26e,81,isRelativeSpecifier node:internal/modules/esm/resolve:895:29,0x31576e52ddb0,~
code-source-info,0x315766fba26e,105,30166,30409,C0O30182C1O30195C7O30199C12O30228C19O30235C26O30253C32O30257C37O30266C38O30278C39O30283C41O30296C47O30300C52O30331C59O30338C66O30356C72O30360C77O30369C78O30381C79O30394C80O30407,,
code-creation,LazyCompile,10,168167,0x315766fba49e,341,finalizeResolution node:internal/modules/esm/resolve:389:28,0x31576e52d8b0,~
code-source-info,0x315766fba49e,105,12129,13327,C0O12150C7O12174C10O12200C15O12154C22O12215C27O12270C37O12337C40O12337C47O12221C52O12215C53O12375C58O12375C63O12402C71O12406C78O12460C83O12489C86O12489C91O12538C93O12562C95O12574C96O12579C104O12584C111O12628C116O12661C121O12668C131O12657C137O12635C142O12689C144O12713C146O12725C149O12745C152O12752C160O12796C161O12807C166O12854C173O12864C176O12864C186O12813C191O12807C192O12917C199O12929C205O12929C214O12970C220O12970C230O12917C235O13022C240O13022C246O13055C253O13092C256O13092C266O13055C272O13118C274O13128C277O13128C281O13126C285O13150C287O13150C288O13181C293O13181C299O13197C306O13235C308O13252C315O13262C319O13270C322O13270C332O13203C337O13197C338O13309C340O13325,,
code-creation,LazyCompile,10,168244,0x315766fba7de,78,get pathname node:internal/url:875:15,0x31571585a780,~
code-source-info,0x315766fba7de,33,23416,23609,C0O23437C4O23442C6O23441C10O23456C14O23465C16O23464C21O23497C27O23501C30O23505C31O23518C36O23523C42O23530C47O23543C49O23553C50O23558C57O23569C60O23592C68O23569C77O23605,,
code-creation,LazyCompile,10,168367,0x315766fbaa36,106,fileURLToPath node:internal/url:1413:23,0x31571585b000,~
code-source-info,0x315766fbaa36,33,38260,38585,C0O38271C6O38305C13O38312C22O38334C25O38339C31O38364C49O38370C54O38364C55O38440C62O38449C67O38466C77O38472C82O38466C83O38510C92O38529C101O38557C105O38583,,
code-creation,LazyCompile,10,168434,0x315766fbac6e,150,get origin node:internal/url:746:13,0x31571585a1f0,~
code-source-info,0x315766fbac6e,33,20371,20930,C0O20453C4O20458C6O20457C10O20484C59O20530C64O20535C70O20542C78O20577C83O20597C89O20601C95O20585C101O20607C105O20614C110O20707C116O20728C117O20834C122O20866C127O20878C132O20888C137O20841C142O20894C143O20905C149O20926,,
code-creation,LazyCompile,10,168500,0x315766fbaebe,136,getPathFromURLPosix node:internal/url:1395:29,0x31571585afb0,~
code-source-info,0x315766fbaebe,33,37760,38236,C0O37778C7O37787C12O37801C19O37837C24O37807C29O37801C30O37875C35O37900C37O37916C41O37905C46O37935C48O37947C54O37951C59O37991C66O38005C70O37991C75O38010C79O38024C81O38039C84O38036C90O38044C97O38061C102O38080C112O38086C117O38080C118O37925C123O37887C126O38198C131O38205C135O38234,,
code-creation,LazyCompile,10,168561,0x315766fbb09e,19,get hostname node:internal/url:841:15,0x31571585a5d0,~
code-source-info,0x315766fbb09e,33,22626,22671,C0O22635C4O22647C6O22646C10O22656C18O22667,,
code-creation,LazyCompile,10,168629,0x315766fbb2de,30,tryStatSync node:internal/modules/esm/resolve:183:3,0x31576e52df40,~
code-source-info,0x315766fbb2de,105,5700,5766,C0O5755C5O5719C10O5710C21O5759C24O5755C29O5766,,
code-creation,LazyCompile,10,168690,0x315766fbb496,123,statSync node:fs:1528:18,0x31572ee61a00,~
code-source-info,0x315766fbb496,77,38875,39279,C7O38875C16O38937C21O38944C26O38982C33O38984C40O39008C45O39016C52O39021C55O39032C60O39032C66O39093C76O39016C82O39132C88O39147C96O39160C102O39188C103O39205C104O39212C109O39212C113O39243C118O39250C122O39277,,
code-creation,LazyCompile,10,168763,0x315766fbb6a6,64,hasNoEntryError node:fs:1465:25,0x31572ee618d0,~
code-source-info,0x315766fbb6a6,77,37312,37503,C0O37330C6O37357C11O37373C16O37357C21O37385C27O37399C36O37403C39O37416C40O37432C46O37456C51O37462C58O37467C61O37480C62O37488C63O37501,,
code-creation,LazyCompile,10,168836,0x315766fbb7de,576,getStatsFromBinding node:internal/fs/utils:530:29,0x31572ee6b578,~
code-source-info,0x315766fbb7de,78,13973,15023,C13O13997C18O14001C24O14032C31O14070C34O14067C43O14089C46O14086C55O14108C58O14105C67O14133C70O14130C79O14152C82O14149C91O14171C94O14168C103O14196C106O14193C115O14215C118O14212C127O14234C130O14231C139O14259C142O14256C154O14306C157O14302C167O14326C170O14322C174O14276C189O14374C192O14370C202O14394C205O14390C210O14344C225O14442C228O14438C239O14462C242O14458C247O14412C263O14510C266O14506C277O14530C280O14526C285O14480C294O14039C299O14547C300O14554C307O14584C310O14581C319O14603C322O14600C331O14622C334O14619C343O14645C346O14642C355O14664C358O14661C367O14683C370O14680C379O14706C382O14703C391O14725C394O14722C403O14744C406O14741C415O14767C418O14764C430O14806C433O14802C443O14826C446O14822C450O14782C465O14866C468O14862C478O14886C481O14882C486O14842C501O14926C504O14922C515O14946C518O14942C523O14902C539O14986C542O14982C553O15006C556O15002C561O14962C570O14561C575O15021,,
tick,0x7ff803de5521,168920,0,0x0,3,0x1077801f0,0x315766fbb50c,0x315766fbb2e8,0x315766fba584,0x315766fba03c,0x315766fb76a0,0x315766fb6f66,0x315766fb6aec,0x315766fb676e,0x315766fb4277,0x315766fb3745,0x107af48ff
code-creation,LazyCompile,10,168943,0x315766fbbc0e,16,isBigUint64Array node:internal/util/types:53:26,0x3157352571f8,~
code-source-info,0x315766fbbc0e,15,1371,1460,C0O1383C5O1390C12O1437C15O1458,,
code-creation,LazyCompile,10,168994,0x315766fbbcfe,19,msFromTimeSpec node:internal/fs/utils:446:24,0x31572ee6b2a0,~
code-source-info,0x315766fbbcfe,78,11006,11065,C0O11022C2O11035C4O11033C10O11054C12O11052C15O11045C18O11063,,
code-creation,LazyCompile,10,169057,0x315766fbbf3e,116,Stats node:internal/fs/utils:495:15,0x31572ee6b498,~
code-source-info,0x315766fbbf3e,78,12749,13277,C0O12886C41O12886C46O13014C48O13027C52O13040C54O13053C58O13066C60O13079C64O13092C66O13109C70O13126C73O13139C77O13137C81O13162C84O13175C88O13173C92O13198C95O13211C99O13209C103O13234C106O13251C110O13249C115O13276,,
code-creation,LazyCompile,10,169107,0x315766fbc116,62,StatsBase node:internal/fs/utils:400:19,0x31572ee6ae70,~
code-source-info,0x315766fbc116,78,9913,10202,C0O9999C2O10008C6O10017C8O10027C12O10037C14O10048C18O10059C20O10068C24O10077C26O10086C30O10095C32O10105C36O10115C38O10128C42O10141C44O10150C48O10159C50O10169C54O10179C56O10191C61O10201,,
code-creation,LazyCompile,10,169171,0x315766fbc30e,29,dateFromMs node:internal/fs/utils:460:20,0x31572ee6b340,~
code-source-info,0x315766fbc30e,78,11518,11563,C0O11527C7O11543C10O11543C17O11554C23O11534C28O11561,,
code-creation,LazyCompile,10,169220,0x315766fbc416,16,StatsBase.isDirectory node:internal/fs/utils:414:43,0x31572ee6aec0,~
code-source-info,0x315766fbc416,78,10246,10295,C0O10265C7O10284C10O10265C15O10293,,
code-creation,LazyCompile,10,169275,0x315766fbc52e,54,Stats._checkModeProperty node:internal/fs/utils:517:46,0x31572ee6b4e8,~
code-source-info,0x315766fbc52e,78,13626,13848,C0O13641C8O13672C10O13668C17O13696C19O13692C26O13724C28O13720C33O13741C34O13754C35O13818C42O13825C44O13823C50O13833C53O13846,,
code-creation,LazyCompile,10,169312,0x315766fbc666,16,StatsBase.isFile node:internal/fs/utils:418:38,0x31572ee6af50,~
code-source-info,0x315766fbc666,78,10335,10384,C0O10354C7O10373C10O10354C15O10382,,
code-creation,Function,11,169374,0x10f8c9c60,280, node:internal/url:636:21,0x315715859f90,^
code-source-info,0x10f8c9c60,33,17443,17518,,,
code-creation,Function,11,169399,0x10f8c9de0,72,isInt32 node:internal/validators:35:17,0x315735259990,^
code-source-info,0x10f8c9de0,17,715,758,,,
code-creation,Function,11,169435,0x10f8c9ea0,1148,readPackageScope node:internal/modules/cjs/loader:321:26,0x31576e51fd70,^
code-source-info,0x10f8c9ea0,99,8919,9437,,,
code-creation,Function,11,169456,0x10f8ca380,72,isUint32 node:internal/validators:39:18,0x315735259d48,^
code-source-info,0x10f8ca380,17,777,822,,,
code-creation,Function,11,169484,0x10f8ca440,1104,getPathFromURLPosix node:internal/url:1395:29,0x31571585afb0,^
code-source-info,0x10f8ca440,33,37760,38236,,,
code-creation,Function,11,169504,0x10f8ca900,164,isUint8Array node:internal/util/types:13:22,0x315735256d90,^
code-source-info,0x10f8ca900,15,257,342,,,
code-creation,Function,11,169523,0x10f8caa20,188,isURLInstance node:internal/url:1492:23,0x31571585b110,^
code-source-info,0x10f8caa20,33,41338,41435,,,
code-creation,LazyCompile,10,169674,0x315766fbccbe,37,get search node:internal/url:893:13,0x31571585a860,~
code-source-info,0x315766fbccbe,33,23841,23967,C0O23868C4O23873C6O23872C10O23858C15O23887C19O23915C24O23929C26O23939C27O23944C32O23955C36O23963,,
code-creation,LazyCompile,10,169740,0x315766fbce4e,181,set search node:internal/url:900:13,0x31571585a8d0,~
code-source-info,0x315766fbce4e,33,23981,24488,C0O24008C4O24013C6O24012C10O24027C17O24036C23O24061C25O24072C30O24088C31O24098C35O24112C44O24126C46O24125C51O24122C57O24166C58O24176C64O24180C69O24189C79O24198C86O24237C88O24247C92O24259C101O24272C106O24269C110O24299C114O24321C125O24335C134O24368C142O24368C154O24321C159O24439C168O24461C170O24460C174O24439C180O24487,,
code-creation,LazyCompile,10,169800,0x315766fbd046,41,toUSVString node:internal/util:59:21,0x31575b569298,~
code-source-info,0x315766fbd046,12,1351,1643,C0O1373C4O1524C11O1544C14O1524C20O1573C22O1589C24O1600C25O1603C30O1634C35O1610C40O1641,,
code-creation,LazyCompile,10,169871,0x315766fbd18e,37,get hash node:internal/url:923:11,0x31571585a9b0,~
code-source-info,0x315766fbd18e,33,24573,24711,C0O24603C4O24608C6O24607C10O24590C15O24622C19O24656C24O24670C26O24680C27O24685C32O24696C36O24707,,
code-creation,LazyCompile,10,169928,0x315766fbd306,144,set hash node:internal/url:930:11,0x31571585aa18,~
code-source-info,0x315766fbd306,33,24723,25156,C0O24748C4O24753C6O24752C10O24801C15O24823C17O24842C18O24855C22O24869C31O24883C33O24882C38O24879C42O24913C43O24920C44O24931C45O24939C51O24943C56O24952C66O24959C73O24994C75O25007C79O25017C88O25030C93O25027C97O25058C108O25070C117O25102C125O25102C137O25058C143O25155,,
code-creation,LazyCompile,10,169976,0x315766fbd4b6,18,toString node:internal/url:730:11,0x31571585a0d0,~
code-source-info,0x315766fbd4b6,33,20058,20096,C0O20067C4O20079C6O20078C12O20087C17O20092,,
code-creation,LazyCompile,10,170040,0x315766fbd5b6,34,get node:internal/modules/esm/module_map:16:6,0x31576e529570,~
code-source-info,0x315766fbd5b6,103,499,569,C0O511C10O511C15O543C17O556C28O556C33O565,,
code-creation,LazyCompile,10,170129,0x315766fbd836,150,ModuleJob node:internal/modules/esm/module_job:55:14,0x31576e52a368,~
code-source-info,0x315766fbd836,104,1296,2977,C0O1296C13O1352C18O1364C22O1378C27O1390C31O1404C36O1420C40O1439C44O1451C48O1586C55O1607C58O1636C67O1645C76O1650C89O1607C94O1605C98O1754C103O2661C106O2675C109O2673C113O2782C123O2809C132O2817C135O2782C140O2943C144O2961C149O2976,,
tick,0x7ff803e80ead,170199,0,0x0,3,0x107791470,0x315766fb6b8d,0x107af48ff
code-creation,LazyCompile,10,170279,0x315766fbe1f6,183,moduleProvider node:internal/modules/esm/loader:229:28,0x315766fb69a8,~
code-source-info,0x315766fbe1f6,102,6003,6319,C10O6003C18O6074C21O6085C26O6090C33O6097C39O6085C53O6074C76O6050C81O6063C86O6134C93O6146C98O6146C104O6171C106O6188C115O6194C120O6188C121O6245C143O6252C158O6313,,
code-creation,LazyCompile,10,170451,0x315766fbe5fe,410,load node:internal/modules/esm/loader:297:13,0x31576e5277a8,~
code-source-info,0x315766fbe5fe,102,7982,9232,C10O7982C60O8030C62O8035C67O8043C71O8068C73O8073C77O8082C84O8089C95O8130C101O8138C105O8162C114O8168C127O8162C153O8210C159O8250C177O8256C182O8250C183O8377C188O8391C193O8420C198O8464C210O8464C216O8568C228O8629C235O8679C255O8574C260O8568C261O8711C267O8751C288O8757C293O8751C294O8894C309O8966C312O8966C322O9001C325O9001C331O9033C350O9039C355O9033C356O9185C363O9200C369O9214C385O9228,,
code-creation,LazyCompile,10,170543,0x315766fbe9f6,189,defaultLoad node:internal/modules/esm/load:7:27,0x31576e532488,~
code-source-info,0x315766fbe9f6,107,257,604,C10O257C18O286C23O298C28O324C33O341C38O341C45O354C50O363C55O389C57O405C64O433C69O458C73O482C78O508C83O540C90O547C94O523C107O517C135O565C142O578C148O590C164O602,,
code-creation,LazyCompile,10,170601,0x315766fbecee,58,defaultGetFormat node:internal/modules/esm/get_format:81:26,0x31576e5316c8,~
code-source-info,0x315766fbecee,106,2347,2536,C0O2381C7O2381C13O2398C20O2435C23O2460C28O2405C37O2476C40O2500C44O2492C48O2509C57O2534,,
code-creation,LazyCompile,10,170674,0x315766fbf1ce,147,file: node:internal/modules/esm/get_format:56:10,0x31576e531768,~
code-source-info,0x315766fbf1ce,106,1653,2280,C0O1685C5O1700C10O1685C15O1719C17O1732C19O1740C24O1759C29O1790C34O1768C41O1796C55O1853C62O1880C66O1897C70O1918C77O1954C82O1976C85O1984C96O1984C102O2109C109O2142C115O2172C122O2214C125O2214C135O2178C140O2172C141O2254C146O2276,,
code-creation,LazyCompile,10,170761,0x315766fbf40e,211,extname node:path:1385:10,0x315715868708,~
code-source-info,0x315766fbf40e,35,41977,43660,C0O41990C8O41990C13O42039C16O42063C18O42080C21O42107C23O42253C25O42278C29O42285C33O42292C34O42292C39O42324C44O42324C50O42366C52O42379C54O42375C59O42543C63O42574C65O42588C69O42603C71O42628C73O42652C75O42660C80O42775C82O42805C84O42813C88O42832C90O42845C92O42841C97O42940C99O42953C104O42971C111O42998C113O43014C118O43031C123O43061C125O43074C130O43234C133O42300C138O42260C141O43271C143O43284C150O43306C156O43401C163O43498C170O43533C173O43525C180O43572C183O43558C188O43586C190O43596C191O43607C205O43614C210O43656,,
code-creation,LazyCompile,10,170836,0x315766fbf63e,13,getPackageType node:internal/modules/esm/resolve:785:24,0x31576e52dc70,~
code-source-info,0x315766fbf63e,105,26557,26647,C0O26589C3O26589C8O26640C12O26645,,
code-creation,LazyCompile,10,170899,0x315766fbf896,173,getPackageScopeConfig node:internal/modules/esm/resolve:247:31,0x31576e52d6d0,~
code-source-info,0x315766fbf896,105,7340,8410,C0O7376C13O7376C19O7473C24O7487C32O7491C39O7568C41O7601C46O7618C49O7618C54O7601C60O7725C66O7733C68O7754C69O7787C72O7807C85O7824C91O8029C96O8061C100O8038C105O8071C107O7415C110O8108C115O8108C120O8163C127O8180C132O8226C137O8247C142O8289C147O8313C154O8331C159O8348C164O8348C170O8387C172O8408,,
code-creation,LazyCompile,10,171040,0x315766fbfcf6,331,getPackageConfig node:internal/modules/esm/resolve:191:26,0x31576e52d680,~
code-source-info,0x315766fbfcf6,105,5925,7238,C0O5970C5O5987C10O5987C16O6000C18O6034C20O6050C21O6072C26O6090C31O6090C37O6100C42O6111C44O6165C51O6184C56O6223C61O6246C66O6292C71O6318C78O6340C83O6357C88O6357C94O6387C96O6408C97O6420C102O6445C107O6459C115O6457C125O6502C137O6559C144O6570C163O6597C168O6611C174O6597C178O6595C185O6643C192O6508C197O6502C198O6671C203O6680C208O6686C213O6692C218O6724C223O6751C233O6804C235O6827C241O6857C243O6877C249O6907C251O6980C253O6989C260O7010C265O7026C268O7066C275O7083C281O7111C287O7121C293O7131C299O7141C305O7154C312O7170C317O7187C322O7187C328O7215C330O7236,,
code-creation,LazyCompile,10,171177,0x3157a91ff2f6,338,defaultGetSource node:internal/modules/esm/get_source:25:32,0x31576e532b38,~
code-source-info,0x3157a91ff2f6,108,662,1303,C10O662C31O670C70O722C77O722C83O742C85O763C92O772C97O791C102O806C114O800C144O849C151O858C156O891C163O911C166O936C171O891C177O951C179O971C186O977C191O971C192O1024C199O1035C206O1055C211O1071C218O1076C221O1076C228O1102C237O1071C246O1146C258O1152C263O1146C264O1204C271O1214C280O1232C285O1239C290O1248C295O1248C301O1287C313O1301,,
tick,0x7ff803e4b9ce,171252,0,0x0,3,0x1077801f0,0x315766fbea54,0x315766fbe670,0x315766fbe21d,0x315766fbd88f,0x315766fb6b8d,0x107af48ff
new,MemoryChunk,0x3157152c0000,262144
code-creation,LazyCompile,10,171369,0x3157a91ffa56,196,readFile node:internal/fs/promises:786:24,0x31576e534de0,~
code-source-info,0x3157a91ffa56,109,22099,22434,C10O22099C18O22119C23O22140C28O22129C35O22188C44O22204C46O22224C48O22213C53O22240C56O22247C71O22277C72O22281C75O22302C80O22281C84O22325C98O22331C111O22325C137O22358C145O22393C151O22425C156O22365C171O22432,,
code-creation,LazyCompile,10,171417,0x3157152c2bee,29,checkAborted node:internal/fs/promises:319:22,0x31576e534110,~
code-source-info,0x3157152c2bee,109,7147,7210,C0O7160C7O7170C16O7185C21O7191C26O7185C28O7209,,
code-creation,LazyCompile,10,171467,0x3157152c2d96,182,open node:internal/fs/promises:449:20,0x31576e5342f0,~
code-source-info,0x3157152c2d96,109,11300,11606,C10O11300C18O11324C23O11331C29O11377C34O11377C39O11401C55O11408C62O11446C69O11479C72O11487C79O11502C82O11513C87O11513C95O11589C104O11487C117O11473C142O11453C157O11604,,
code-creation,LazyCompile,10,171670,0x3157152c311e,263,link node:internal/modules/esm/module_job:66:18,0x315766fbd6c8,~
code-source-info,0x3157152c311e,104,1754,2604,C4O1754C26O1774C36O1799C48O1788C73O1786C77O1820C89O1832C98O1850C100O1839C104O1820C108O2166C110O2166C112O2193C117O2198C122O2205C132O2205C138O2447C140O2483C151O2504C156O2500C162O2489C174O2483C199O2541C210O2563C218O2559C224O2548C238O2598,,
code-creation,LazyCompile,10,171725,0x3157152c33a6,19,primordials.PromisePrototypeCatch node:internal/per_context/primordials:397:37,0x31575b54a280,~
code-source-info,0x3157152c33a6,6,11446,11533,C0O11477C13O11477C18O11533,,
code-creation,LazyCompile,10,171777,0x3157152c3516,110,set node:internal/modules/esm/module_map:20:6,0x31576e5295c0,~
code-source-info,0x3157152c3516,103,575,848,C0O592C10O592C15O624C19O643C21O632C26O653C37O708C55O714C60O708C61O775C73O792C84O775C88O817C90O830C104O830C109O844,,
code-creation,LazyCompile,10,171823,0x3157152c3696,10, node:internal/modules/esm/module_map:7:63,0x31576e5294d0,~
code-source-info,0x3157152c3696,103,175,200,C0O187C2O193C9O199,,
code-creation,LazyCompile,10,171856,0x3157152c375e,10, node:internal/modules/esm/loader:277:15,0x315766fb6558,~
code-source-info,0x3157152c375e,102,7400,7418,C0O7413C5O7413C9O7418,,
code-creation,LazyCompile,10,171932,0x3157152c3bb6,433,run node:internal/modules/esm/module_job:180:12,0x31576e52a458,~
code-source-info,0x3157152c3bb6,104,6439,7612,C10O6439C18O6459C23O6459C35O6448C58O6494C61O6524C66O6558C71O6565C76O6565C90O6547C128O6623C133O6628C143O6635C152O6669C158O6707C163O6669C169O6727C182O6737C186O6772C196O6804C204O6776C211O6838C224O6848C228O6934C235O6965C240O6972C248O6934C259O7003C267O7053C272O7060C277O7003C292O7080C297O7134C302O7162C307O7169C312O7135C318O7201C325O7206C330O7232C344O7379C358O7322C364O7402C370O7481C376O7242C380O7558C382O7558C383O7577C388O7599C408O7608,,
code-creation,LazyCompile,10,171992,0x3157152c3ee6,24,instantiate node:internal/modules/esm/module_job:98:14,0x31576e52a3b8,~
code-source-info,0x3157152c3ee6,104,2992,3126,C0O3010C6O3071C11O3071C15O3064C19O3109C23O3122,,
code-creation,LazyCompile,10,172128,0x3157152c45de,924,_instantiate node:internal/modules/esm/module_job:105:21,0x31576e52a408,~
code-source-info,0x3157152c45de,104,3148,6426,C4O3148C29O3177C37O3177C42O3177C44O3229C48O3229C50O3532C54O3538C67O3532C97O3587C105O3615C111O3637C118O3652C126O3688C136O3688C142O3716C147O3763C153O3770C159O3788C165O3746C172O3825C178O3832C184O3832C203O3879C215O3879C219O4219C227O4224C236O4260C244O4286C254O4260C261O4396C273O4419C283O4396C289O4463C298O4507C313O4463C319O4602C331O4636C343O4602C350O4574C358O4593C366O4762C372O4769C378O4769C393O4751C418O4734C423O4868C429O4875C435O4875C449O4857C474O4846C479O4904C481O4915C486O4967C488O4977C492O5297C500O5318C506O5297C512O5386C518O5421C522O5444C535O5421C541O5495C551O5524C570O5583C581O5564C588O5645C595O5722C606O5838C621O5874C629O5925C648O5800C651O5505C655O5995C667O6018C677O5995C683O6042C695O6074C703O6054C707O6095C715O6105C723O6105C728O6103C732O6165C734O6165C735O6213C767O6196C798O6196C801O6371C805O6400C807O6398C811O6185C895O6425,,
code-creation,LazyCompile,10,172235,0x3157152c4c46,179,addJobsToDependencyGraph node:internal/modules/esm/module_job:107:38,0x3157152c4330,~
code-source-info,0x3157152c4c46,104,3229,3526,C10O3229C18O3258C23O3274C28O3274C35O3300C46O3307C47O3322C52O3334C57O3334C62O3395C74O3379C100O3409C111O3431C118O3458C123O3492C126O3458C134O3427C140O3416C154O3520,,
code-creation,LazyCompile,10,172328,0x3157152c4e2e,112,FileHandle node:internal/fs/promises:116:14,0x31576e534e30,~
code-source-info,0x3157152c4e2e,109,2847,3013,C3O2866C11O2866C40O2879C45O2884C50O2893C54O2911C59O2916C67O2923C69O2947C77O2921C81O2961C86O2966C91O2973C95O2982C100O2987C104O3002C111O3012,,
code-creation,LazyCompile,10,172378,0x3157152c4fae,63,MixedEventEmitter node:internal/event_target:829:16,0x31576e53f658,~
code-source-info,0x3157152c4fae,38,23503,23633,C0O23503C8O23521C15O23528C21O23563C25O23572C29O23563C41O23585C48O23607C54O23585C62O23632,,
tick,0x1076e2fab,172468,0,0x0,2,0x1077801f0,0x3157a91ffae7,0x107af48ff
code-creation,LazyCompile,10,172540,0x3157152c5296,601,readFileHandle node:internal/fs/promises:359:30,0x31576e5341b0,~
code-source-info,0x3157152c5296,109,8384,10156,C10O8384C18O8425C25O8432C33O8445C37O8445C41O8489C47O8503C53O8520C64O8531C68O8503C82O8489C110O8549C114O8549C118O8578C120O8586C122O8601C129O8617C131O8615C138O8629C140O8625C145O8644C147O8661C153O8691C155O8708C157O8719C159O8717C164O8737C172O8743C177O8737C178O8795C180O8820C182O8840C183O8845C187O8870C190O8895C199O8916C203O8923C209O8923C215O8957C219O8957C223O8987C225O9003C227O9019C229O9031C233O9051C239O9067C247O9083C251O9067C257O9120C259O9138C266O9196C269O9223C272O9249C280O9271C287O9284C291O9258C297O9337C303O9352C309O9368C321O9442C334O9352C348O9338C379O9467C381O9480C388O9495C389O9517C396O9536C400O9550C405O9574C410O9608C412O9622C414O9618C418O9678C424O9709C433O9709C440O9736C446O9736C451O9795C455O8948C458O9815C460O9825C461O9834C466O9845C468O9864C477O9899C486O9899C495O9952C503O9959C509O9974C516O9980C520O9987C526O9987C533O10100C539O10118C545O10135C551O10118C568O10147C572O10154,,
code-creation,LazyCompile,10,172623,0x3157152c56de,8,get fd node:internal/fs/promises:129:9,0x31576e534ee8,~
code-source-info,0x3157152c56de,109,3084,3114,C0O3093C2O3105C4O3104C7O3110,,
code-creation,LazyCompile,10,172678,0x3157152c585e,33,primordials.SafePromisePrototypeFinally node:internal/per_context/primordials:409:43,0x31575b54a338,~
code-source-info,0x3157152c585e,6,12020,12293,C0O12020C13O12153C27O12153C32O12293,,
code-creation,LazyCompile,10,172724,0x3157152c59ee,46, node:internal/per_context/primordials:412:15,0x3157152c57b0,~
code-source-info,0x3157152c59ee,6,12165,12289,C0O12279C14O12179C20O12253C28O12260C34O12278C39O12279C45O12289,,
code-creation,LazyCompile,10,172759,0x3157152c5b36,27,SafePromise node:internal/per_context/primordials:393:16,0x31575b54a230,~
code-source-info,0x3157152c5b36,6,11370,11401,C3O11383C7O11389C11O11383C26O11400,,
code-creation,LazyCompile,10,172794,0x3157152c5c2e,22, node:internal/per_context/primordials:413:21,0x3157152c5938,~
code-source-info,0x3157152c5c2e,6,12195,12244,C0O12205C16O12205C21O12244,,
code-creation,LazyCompile,10,172851,0x3157152c5d26,19,allocUnsafeSlow node:buffer:382:50,0x315735264d20,~
code-source-info,0x3157152c5d26,18,11191,11256,C0O11202C5O11202C9O11222C14O11229C18O11254,,
code-creation,LazyCompile,10,172892,0x3157152c5e4e,71,createUnsafeBuffer node:internal/buffer:1059:28,0x315735271c30,~
code-source-info,0x3157152c5e4e,19,30321,30430,C0O30332C8O30344C15O30361C22O30368C39O30408C48O30420C70O30429,,
code-creation,LazyCompile,10,173014,0x3157152c613e,248,close node:internal/fs/promises:189:11,0x31576e537020,~
code-source-info,0x3157152c613e,109,4210,5000,C0O4222C7O4231C9O4230C15O4236C20O4252C27O4259C30O4276C31O4288C38O4297C40O4296C45O4321C52O4333C54O4332C57O4348C58O4360C65O4365C73O4371C77O4379C84O4388C86O4387C91O4395C96O4410C103O4415C108O4420C112O4432C119O4437C126O4454C136O4496C138O4495C142O4505C147O4505C157O4454C162O4452C168O4593C175O4598C182O4615C189O4656C199O4652C210O4615C215O4613C219O4945C222O4950C230O4950C235O4969C242O4981C244O4980C247O4996,,
code-creation,LazyCompile,10,173140,0x3157152c64a6,17, node:internal/fs/promises:203:9,0x3157152c5f28,~
code-source-info,0x3157152c64a6,109,4522,4564,C0O4530C7O4535C11O4550C16O4563,,
code-creation,LazyCompile,10,173240,0x3157152c66e6,168,moduleStrategy node:internal/modules/esm/translators:134:56,0x3157a91c3b70,~
code-source-info,0x3157152c66e6,111,3755,4116,C6O3755C14O3781C25O3781C30O3825C33O3834C39O3855C44O3855C49O3891C59O3927C64O3891C68O3952C87O3952C93O4000C98O4011C103O4023C108O4027C115O4041C121O4067C125O4023C131O4100C143O4114,,
code-creation,LazyCompile,10,173303,0x3157152c7496,83,assertBufferSource node:internal/modules/esm/translators:79:28,0x3157a91c3878,~
code-source-info,0x3157152c7496,111,2223,2616,C0O2257C10O2308C11O2315C12O2370C15O2370C19O2330C24O2349C29O2389C35O2416C41O2446C42O2453C43O2460C50O2512C77O2466C82O2460,,
code-creation,LazyCompile,10,173346,0x3157152c75ee,31,lazyTypes node:internal/modules/esm/translators:24:19,0x3157a91c37d8,~
code-source-info,0x3157152c75ee,111,437,531,C0O444C6O465C10O479C11O482C17O498C24O496C30O529,,
code-creation,LazyCompile,10,173391,0x3157152c7706,72,stringify node:internal/modules/esm/translators:95:19,0x3157a91c38c8,~
code-source-info,0x3157152c7706,111,2636,2836,C0O2647C6O2677C8O2689C9O2692C20O2692C25O2746C33O2779C36O2775C45O2795C50O2754C56O2806C61O2821C66O2821C71O2834,,
code-creation,LazyCompile,10,173483,0x3157152c78f6,206,TextDecoder node:internal/encoding:379:16,0x315735279be0,~
script-source,21,node:internal/encoding,'use strict';\n\n// An implementation of the WHATWG Encoding Standard\n// https://encoding.spec.whatwg.org\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  SafeMap\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  Uint32Array\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_ENCODING_INVALID_ENCODED_DATA\x2C\n  ERR_ENCODING_NOT_SUPPORTED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_NO_ICU\n} = require('internal/errors').codes;\nconst kHandle = Symbol('handle');\nconst kFlags = Symbol('flags');\nconst kEncoding = Symbol('encoding');\nconst kDecoder = Symbol('decoder');\nconst kEncoder = Symbol('encoder');\n\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol: inspect\n} = require('internal/util');\n\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\n\nconst {\n  validateString\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  encodeInto\x2C\n  encodeUtf8String\n} = internalBinding('buffer');\n\nlet Buffer;\nfunction lazyBuffer() {\n  if (Buffer === undefined)\n    Buffer = require('buffer').Buffer;\n  return Buffer;\n}\n\nfunction validateEncoder(obj) {\n  if (obj == null || obj[kEncoder] !== true)\n    throw new ERR_INVALID_THIS('TextEncoder');\n}\n\nfunction validateDecoder(obj) {\n  if (obj == null || obj[kDecoder] !== true)\n    throw new ERR_INVALID_THIS('TextDecoder');\n}\n\nconst CONVERTER_FLAGS_FLUSH = 0x1;\nconst CONVERTER_FLAGS_FATAL = 0x2;\nconst CONVERTER_FLAGS_IGNORE_BOM = 0x4;\n\nconst empty = new Uint8Array(0);\n\nconst encodings = new SafeMap([\n  ['unicode-1-1-utf-8'\x2C 'utf-8']\x2C\n  ['utf8'\x2C 'utf-8']\x2C\n  ['utf-8'\x2C 'utf-8']\x2C\n  ['866'\x2C 'ibm866']\x2C\n  ['cp866'\x2C 'ibm866']\x2C\n  ['csibm866'\x2C 'ibm866']\x2C\n  ['ibm866'\x2C 'ibm866']\x2C\n  ['csisolatin2'\x2C 'iso-8859-2']\x2C\n  ['iso-8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso-ir-101'\x2C 'iso-8859-2']\x2C\n  ['iso8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso88592'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2:1987'\x2C 'iso-8859-2']\x2C\n  ['l2'\x2C 'iso-8859-2']\x2C\n  ['latin2'\x2C 'iso-8859-2']\x2C\n  ['csisolatin3'\x2C 'iso-8859-3']\x2C\n  ['iso-8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso-ir-109'\x2C 'iso-8859-3']\x2C\n  ['iso8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso88593'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3:1988'\x2C 'iso-8859-3']\x2C\n  ['l3'\x2C 'iso-8859-3']\x2C\n  ['latin3'\x2C 'iso-8859-3']\x2C\n  ['csisolatin4'\x2C 'iso-8859-4']\x2C\n  ['iso-8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso-ir-110'\x2C 'iso-8859-4']\x2C\n  ['iso8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso88594'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4:1988'\x2C 'iso-8859-4']\x2C\n  ['l4'\x2C 'iso-8859-4']\x2C\n  ['latin4'\x2C 'iso-8859-4']\x2C\n  ['csisolatincyrillic'\x2C 'iso-8859-5']\x2C\n  ['cyrillic'\x2C 'iso-8859-5']\x2C\n  ['iso-8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso-ir-144'\x2C 'iso-8859-5']\x2C\n  ['iso8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso88595'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5:1988'\x2C 'iso-8859-5']\x2C\n  ['arabic'\x2C 'iso-8859-6']\x2C\n  ['asmo-708'\x2C 'iso-8859-6']\x2C\n  ['csiso88596e'\x2C 'iso-8859-6']\x2C\n  ['csiso88596i'\x2C 'iso-8859-6']\x2C\n  ['csisolatinarabic'\x2C 'iso-8859-6']\x2C\n  ['ecma-114'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-e'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-i'\x2C 'iso-8859-6']\x2C\n  ['iso-ir-127'\x2C 'iso-8859-6']\x2C\n  ['iso8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso88596'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6:1987'\x2C 'iso-8859-6']\x2C\n  ['csisolatingreek'\x2C 'iso-8859-7']\x2C\n  ['ecma-118'\x2C 'iso-8859-7']\x2C\n  ['elot_928'\x2C 'iso-8859-7']\x2C\n  ['greek'\x2C 'iso-8859-7']\x2C\n  ['greek8'\x2C 'iso-8859-7']\x2C\n  ['iso-8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso-ir-126'\x2C 'iso-8859-7']\x2C\n  ['iso8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso88597'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7:1987'\x2C 'iso-8859-7']\x2C\n  ['sun_eu_greek'\x2C 'iso-8859-7']\x2C\n  ['csiso88598e'\x2C 'iso-8859-8']\x2C\n  ['csisolatinhebrew'\x2C 'iso-8859-8']\x2C\n  ['hebrew'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8-e'\x2C 'iso-8859-8']\x2C\n  ['iso-ir-138'\x2C 'iso-8859-8']\x2C\n  ['iso8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso88598'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8:1988'\x2C 'iso-8859-8']\x2C\n  ['visual'\x2C 'iso-8859-8']\x2C\n  ['csiso88598i'\x2C 'iso-8859-8-i']\x2C\n  ['iso-8859-8-i'\x2C 'iso-8859-8-i']\x2C\n  ['logical'\x2C 'iso-8859-8-i']\x2C\n  ['csisolatin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso-ir-157'\x2C 'iso-8859-10']\x2C\n  ['iso8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso885910'\x2C 'iso-8859-10']\x2C\n  ['l6'\x2C 'iso-8859-10']\x2C\n  ['latin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso885913'\x2C 'iso-8859-13']\x2C\n  ['iso-8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso885914'\x2C 'iso-8859-14']\x2C\n  ['csisolatin9'\x2C 'iso-8859-15']\x2C\n  ['iso-8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso885915'\x2C 'iso-8859-15']\x2C\n  ['iso_8859-15'\x2C 'iso-8859-15']\x2C\n  ['l9'\x2C 'iso-8859-15']\x2C\n  ['cskoi8r'\x2C 'koi8-r']\x2C\n  ['koi'\x2C 'koi8-r']\x2C\n  ['koi8'\x2C 'koi8-r']\x2C\n  ['koi8-r'\x2C 'koi8-r']\x2C\n  ['koi8_r'\x2C 'koi8-r']\x2C\n  ['koi8-ru'\x2C 'koi8-u']\x2C\n  ['koi8-u'\x2C 'koi8-u']\x2C\n  ['csmacintosh'\x2C 'macintosh']\x2C\n  ['mac'\x2C 'macintosh']\x2C\n  ['macintosh'\x2C 'macintosh']\x2C\n  ['x-mac-roman'\x2C 'macintosh']\x2C\n  ['dos-874'\x2C 'windows-874']\x2C\n  ['iso-8859-11'\x2C 'windows-874']\x2C\n  ['iso8859-11'\x2C 'windows-874']\x2C\n  ['iso885911'\x2C 'windows-874']\x2C\n  ['tis-620'\x2C 'windows-874']\x2C\n  ['windows-874'\x2C 'windows-874']\x2C\n  ['cp1250'\x2C 'windows-1250']\x2C\n  ['windows-1250'\x2C 'windows-1250']\x2C\n  ['x-cp1250'\x2C 'windows-1250']\x2C\n  ['cp1251'\x2C 'windows-1251']\x2C\n  ['windows-1251'\x2C 'windows-1251']\x2C\n  ['x-cp1251'\x2C 'windows-1251']\x2C\n  ['ansi_x3.4-1968'\x2C 'windows-1252']\x2C\n  ['ascii'\x2C 'windows-1252']\x2C\n  ['cp1252'\x2C 'windows-1252']\x2C\n  ['cp819'\x2C 'windows-1252']\x2C\n  ['csisolatin1'\x2C 'windows-1252']\x2C\n  ['ibm819'\x2C 'windows-1252']\x2C\n  ['iso-8859-1'\x2C 'windows-1252']\x2C\n  ['iso-ir-100'\x2C 'windows-1252']\x2C\n  ['iso8859-1'\x2C 'windows-1252']\x2C\n  ['iso88591'\x2C 'windows-1252']\x2C\n  ['iso_8859-1'\x2C 'windows-1252']\x2C\n  ['iso_8859-1:1987'\x2C 'windows-1252']\x2C\n  ['l1'\x2C 'windows-1252']\x2C\n  ['latin1'\x2C 'windows-1252']\x2C\n  ['us-ascii'\x2C 'windows-1252']\x2C\n  ['windows-1252'\x2C 'windows-1252']\x2C\n  ['x-cp1252'\x2C 'windows-1252']\x2C\n  ['cp1253'\x2C 'windows-1253']\x2C\n  ['windows-1253'\x2C 'windows-1253']\x2C\n  ['x-cp1253'\x2C 'windows-1253']\x2C\n  ['cp1254'\x2C 'windows-1254']\x2C\n  ['csisolatin5'\x2C 'windows-1254']\x2C\n  ['iso-8859-9'\x2C 'windows-1254']\x2C\n  ['iso-ir-148'\x2C 'windows-1254']\x2C\n  ['iso8859-9'\x2C 'windows-1254']\x2C\n  ['iso88599'\x2C 'windows-1254']\x2C\n  ['iso_8859-9'\x2C 'windows-1254']\x2C\n  ['iso_8859-9:1989'\x2C 'windows-1254']\x2C\n  ['l5'\x2C 'windows-1254']\x2C\n  ['latin5'\x2C 'windows-1254']\x2C\n  ['windows-1254'\x2C 'windows-1254']\x2C\n  ['x-cp1254'\x2C 'windows-1254']\x2C\n  ['cp1255'\x2C 'windows-1255']\x2C\n  ['windows-1255'\x2C 'windows-1255']\x2C\n  ['x-cp1255'\x2C 'windows-1255']\x2C\n  ['cp1256'\x2C 'windows-1256']\x2C\n  ['windows-1256'\x2C 'windows-1256']\x2C\n  ['x-cp1256'\x2C 'windows-1256']\x2C\n  ['cp1257'\x2C 'windows-1257']\x2C\n  ['windows-1257'\x2C 'windows-1257']\x2C\n  ['x-cp1257'\x2C 'windows-1257']\x2C\n  ['cp1258'\x2C 'windows-1258']\x2C\n  ['windows-1258'\x2C 'windows-1258']\x2C\n  ['x-cp1258'\x2C 'windows-1258']\x2C\n  ['x-mac-cyrillic'\x2C 'x-mac-cyrillic']\x2C\n  ['x-mac-ukrainian'\x2C 'x-mac-cyrillic']\x2C\n  ['chinese'\x2C 'gbk']\x2C\n  ['csgb2312'\x2C 'gbk']\x2C\n  ['csiso58gb231280'\x2C 'gbk']\x2C\n  ['gb2312'\x2C 'gbk']\x2C\n  ['gb_2312'\x2C 'gbk']\x2C\n  ['gb_2312-80'\x2C 'gbk']\x2C\n  ['gbk'\x2C 'gbk']\x2C\n  ['iso-ir-58'\x2C 'gbk']\x2C\n  ['x-gbk'\x2C 'gbk']\x2C\n  ['gb18030'\x2C 'gb18030']\x2C\n  ['big5'\x2C 'big5']\x2C\n  ['big5-hkscs'\x2C 'big5']\x2C\n  ['cn-big5'\x2C 'big5']\x2C\n  ['csbig5'\x2C 'big5']\x2C\n  ['x-x-big5'\x2C 'big5']\x2C\n  ['cseucpkdfmtjapanese'\x2C 'euc-jp']\x2C\n  ['euc-jp'\x2C 'euc-jp']\x2C\n  ['x-euc-jp'\x2C 'euc-jp']\x2C\n  ['csiso2022jp'\x2C 'iso-2022-jp']\x2C\n  ['iso-2022-jp'\x2C 'iso-2022-jp']\x2C\n  ['csshiftjis'\x2C 'shift_jis']\x2C\n  ['ms932'\x2C 'shift_jis']\x2C\n  ['ms_kanji'\x2C 'shift_jis']\x2C\n  ['shift-jis'\x2C 'shift_jis']\x2C\n  ['shift_jis'\x2C 'shift_jis']\x2C\n  ['sjis'\x2C 'shift_jis']\x2C\n  ['windows-31j'\x2C 'shift_jis']\x2C\n  ['x-sjis'\x2C 'shift_jis']\x2C\n  ['cseuckr'\x2C 'euc-kr']\x2C\n  ['csksc56011987'\x2C 'euc-kr']\x2C\n  ['euc-kr'\x2C 'euc-kr']\x2C\n  ['iso-ir-149'\x2C 'euc-kr']\x2C\n  ['korean'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1987'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1989'\x2C 'euc-kr']\x2C\n  ['ksc5601'\x2C 'euc-kr']\x2C\n  ['ksc_5601'\x2C 'euc-kr']\x2C\n  ['windows-949'\x2C 'euc-kr']\x2C\n  ['utf-16be'\x2C 'utf-16be']\x2C\n  ['utf-16le'\x2C 'utf-16le']\x2C\n  ['utf-16'\x2C 'utf-16le']\x2C\n]);\n\n// Unfortunately\x2C String.prototype.trim also removes non-ascii whitespace\x2C\n// so we have to do this manually\nfunction trimAsciiWhitespace(label) {\n  let s = 0;\n  let e = label.length;\n  while (s < e && (\n    label[s] === '\\u0009' ||\n    label[s] === '\\u000a' ||\n    label[s] === '\\u000c' ||\n    label[s] === '\\u000d' ||\n    label[s] === '\\u0020')) {\n    s++;\n  }\n  while (e > s && (\n    label[e - 1] === '\\u0009' ||\n    label[e - 1] === '\\u000a' ||\n    label[e - 1] === '\\u000c' ||\n    label[e - 1] === '\\u000d' ||\n    label[e - 1] === '\\u0020')) {\n    e--;\n  }\n  return StringPrototypeSlice(label\x2C s\x2C e);\n}\n\nfunction getEncodingFromLabel(label) {\n  const enc = encodings.get(label);\n  if (enc !== undefined) return enc;\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\n}\n\nconst encodeIntoResults = new Uint32Array(2);\n\nclass TextEncoder {\n  constructor() {\n    this[kEncoder] = true;\n  }\n\n  get encoding() {\n    validateEncoder(this);\n    return 'utf-8';\n  }\n\n  encode(input = '') {\n    validateEncoder(this);\n    return encodeUtf8String(`${input}`);\n  }\n\n  encodeInto(src\x2C dest) {\n    validateEncoder(this);\n    validateString(src\x2C 'src');\n    if (!dest || !isUint8Array(dest))\n      throw new ERR_INVALID_ARG_TYPE('dest'\x2C 'Uint8Array'\x2C dest);\n    encodeInto(src\x2C dest\x2C encodeIntoResults);\n    return { read: encodeIntoResults[0]\x2C written: encodeIntoResults[1] };\n  }\n\n  [inspect](depth\x2C opts) {\n    validateEncoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const ctor = getConstructorOf(this);\n    const obj = ObjectCreate({\n      constructor: ctor === null ? TextEncoder : ctor\n    });\n    obj.encoding = this.encoding;\n    // Lazy to avoid circular dependency\n    return require('internal/util/inspect').inspect(obj\x2C opts);\n  }\n}\n\nObjectDefineProperties(\n  TextEncoder.prototype\x2C {\n    'encode': { enumerable: true }\x2C\n    'encodeInto': { enumerable: true }\x2C\n    'encoding': { enumerable: true }\x2C\n    [SymbolToStringTag]: { configurable: true\x2C value: 'TextEncoder' }\x2C\n  });\n\nconst TextDecoder =\n  internalBinding('config').hasIntl ?\n    makeTextDecoderICU() :\n    makeTextDecoderJS();\n\nfunction makeTextDecoderICU() {\n  const {\n    decode: _decode\x2C\n    getConverter\x2C\n  } = internalBinding('icu');\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = {}) {\n      encoding = `${encoding}`;\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      const handle = getConverter(enc\x2C flags);\n      if (handle === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      this[kDecoder] = true;\n      this[kHandle] = handle;\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n    }\n\n\n    decode(input = empty\x2C options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (!isArrayBufferView(input)) {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      let flags = 0;\n      if (options !== null)\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\n\n      const ret = _decode(this[kHandle]\x2C input\x2C flags);\n      if (typeof ret === 'number') {\n        throw new ERR_ENCODING_INVALID_ENCODED_DATA(this.encoding\x2C ret);\n      }\n      return ret.toString('ucs2');\n    }\n  }\n\n  return TextDecoder;\n}\n\nfunction makeTextDecoderJS() {\n  let StringDecoder;\n  function lazyStringDecoder() {\n    if (StringDecoder === undefined)\n      ({ StringDecoder } = require('string_decoder'));\n    return StringDecoder;\n  }\n\n  const kBOMSeen = Symbol('BOM seen');\n\n  function hasConverter(encoding) {\n    return encoding === 'utf-8' || encoding === 'utf-16le';\n  }\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = {}) {\n      encoding = `${encoding}`;\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined || !hasConverter(enc))\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        if (options.fatal) {\n          throw new ERR_NO_ICU('"fatal" option');\n        }\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      this[kDecoder] = true;\n      // StringDecoder will normalize WHATWG encoding to Node.js encoding.\n      this[kHandle] = new (lazyStringDecoder())(enc);\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kBOMSeen] = false;\n    }\n\n    decode(input = empty\x2C options = {}) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (isArrayBufferView(input)) {\n        input = lazyBuffer().from(input.buffer\x2C input.byteOffset\x2C\n                                  input.byteLength);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\n        this[kBOMSeen] = false;\n      }\n\n      if (options !== null && options.stream) {\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\n      } else {\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\n      }\n\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ?\n        this[kHandle].end(input) :\n        this[kHandle].write(input);\n\n      if (result.length > 0 &&\n          !this[kBOMSeen] &&\n          !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\n        // If the very first result in the stream is a BOM\x2C and we are not\n        // explicitly told to ignore it\x2C then we discard it.\n        if (result[0] === '\\ufeff') {\n          result = StringPrototypeSlice(result\x2C 1);\n        }\n        this[kBOMSeen] = true;\n      }\n\n      return result;\n    }\n  }\n\n  return TextDecoder;\n}\n\n// Mix in some shared properties.\nObjectDefineProperties(\n  TextDecoder.prototype\x2C\n  ObjectGetOwnPropertyDescriptors({\n    get encoding() {\n      validateDecoder(this);\n      return this[kEncoding];\n    }\x2C\n\n    get fatal() {\n      validateDecoder(this);\n      return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\n    }\x2C\n\n    get ignoreBOM() {\n      validateDecoder(this);\n      return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) ===\n              CONVERTER_FLAGS_IGNORE_BOM;\n    }\x2C\n\n    [inspect](depth\x2C opts) {\n      validateDecoder(this);\n      if (typeof depth === 'number' && depth < 0)\n        return this;\n      const constructor = getConstructorOf(this) || TextDecoder;\n      const obj = ObjectCreate({ constructor });\n      obj.encoding = this.encoding;\n      obj.fatal = this.fatal;\n      obj.ignoreBOM = this.ignoreBOM;\n      if (opts.showHidden) {\n        obj[kFlags] = this[kFlags];\n        obj[kHandle] = this[kHandle];\n      }\n      // Lazy to avoid circular dependency\n      const { inspect } = require('internal/util/inspect');\n      return `${constructor.name} ${inspect(obj)}`;\n    }\n  })\n);\n\nObjectDefineProperties(TextDecoder.prototype\x2C {\n  decode: { enumerable: true }\x2C\n  [inspect]: { enumerable: false }\x2C\n  [SymbolToStringTag]: {\n    configurable: true\x2C\n    value: 'TextDecoder'\n  }\n});\n\nmodule.exports = {\n  getEncodingFromLabel\x2C\n  TextDecoder\x2C\n  TextEncoder\n};\n
code-source-info,0x3157152c78f6,21,10299,11083,C15O10299C21O10342C25O10374C35O10389C43O10374C48O10519C53O10519C58O10557C60O10588C69O10594C74O10588C75O10655C77O10664C81O10713C94O10721C103O10773C116O10785C125O10847C130O10847C136O10879C138O10913C147O10919C152O10913C153O10968C157O10973C161O10983C165O10997C169O11002C174O11011C178O11027C182O11032C187O11040C191O11055C195O11060C200O11071C205O11082,,
tick,0x7ff803e80c86,174709,0,0x0,3,0x107791470,0x3157152c772a,0x3157152c6707,0x315766fbe285,0x107af48ff
code-creation,LazyCompile,10,174736,0x3157152c8f66,55,getEncodingFromLabel node:internal/encoding:313:30,0x315735279918,~
code-source-info,0x3157152c8f66,21,8645,8795,C0O8669C5O8679C10O8679C16O8693C18O8716C20O8727C21O8730C26O8747C34O8777C39O8777C44O8751C49O8747C54O8793,,
tick,0x108084860,174908,1,0x107116250,6,0x1072c15f0,0x3157152c7978,0x3157152c772a,0x3157152c6707,0x315766fbe285,0x107af48ff
code-creation,LazyCompile,10,175455,0x3157152c9276,227,decode node:internal/encoding:408:11,0x315735279d00,~
code-source-info,0x3157152c9276,21,11096,11918,C8O11105C25O11134C30O11134C34O11163C41O11167C47O11202C52O11210C56O11222C61O11223C69O11249C76O11254C82O11290C102O11296C107O11290C108O11466C118O11481C126O11466C131O11611C133O11620C137O11667C153O11680C159O11722C168O11735C170O11734C180O11722C186O11766C190O11805C197O11854C207O11811C212O11805C213O11895C221O11895C226O11912,,
code-creation,LazyCompile,10,175533,0x3157152c949e,37,validateDecoder node:internal/encoding:64:25,0x315735279878,~
code-source-info,0x3157152c949e,21,1269,1370,C0O1279C7O1302C9O1301C14O1312C19O1326C29O1332C34O1326C36O1369,,
tick,0x1080695f0,175951,1,0x107116430,6,0x1072c15f0,0x3157152c932a,0x3157152c7748,0x3157152c6707,0x315766fbe285,0x107af48ff
code-creation,LazyCompile,10,175995,0x3157152c95ee,12,slice node:buffer:602:12,0x315735265640,~
code-source-info,0x3157152c95ee,18,16971,17017,C0O16996C5O16996C11O17017,,
code-creation,LazyCompile,10,176050,0x3157152c96d6,10, node:internal/modules/esm/translators:44:63,0x3157a91c3b20,~
code-source-info,0x3157152c96d6,111,1058,1083,C0O1070C2O1076C9O1082,,
code-creation,Script,10,176180,0x3157152c9e06,254, file:///Users/iramgutierrez/iram/coderhouse/30965/clases/clase32/profiler.js:1:1,0x3157152c9a20,~
script-source,137,file:///Users/iramgutierrez/iram/coderhouse/30965/clases/clase32/profiler.js,const express = require("express");\nconst crypto = require("crypto");\n\nconst app = express();\n\nconst users = {}\n\napp.use(express.static('public'))\n\napp.get("/getUsers"\x2C (req\x2C res) => {\n  res.json({ users })\n})\n\napp.get("/newUser"\x2C (req\x2C res) => {\n  let username = req.query.username || "";\n  const password = req.query.password || "";\n\n  username = username.replace(/[!@#$%^&*]/g\x2C "");\n\n  if (!username || !password || users[username]) {\n    return res.sendStatus(400);\n  }\n\n  const salt = crypto.randomBytes(128).toString("base64");\n  const hash = crypto.pbkdf2Sync(password\x2C salt\x2C 10000\x2C 512\x2C "sha512");\n\n  users[username] = { salt\x2C hash };\n\n  res.sendStatus(200);\n});\n\napp.get("/auth-bloq"\x2C (req\x2C res) => {\n  let username = req.query.username || "";\n  const password = req.query.password || "";\n\n  username = username.replace(/[!@#$%^&*]/g\x2C "");\n\n  if (!username || !password || !users[username]) {\n    process.exit(1)\n    // return res.sendStatus(400);\n  }\n\n  const { salt\x2C hash } = users[username];\n  const encryptHash = crypto.pbkdf2Sync(password\x2C salt\x2C 10000\x2C 512\x2C "sha512");\n\n  if (crypto.timingSafeEqual(hash\x2C encryptHash)) {\n    res.sendStatus(200);\n  } else {\n    process.exit(1)\n    // res.sendStatus(401);\n  }\n});\n\napp.get("/auth-nobloq"\x2C (req\x2C res) => {\n  let username = req.query.username || "";\n  const password = req.query.password || "";\n  username = username.replace(/[!@#$%^&*]/g\x2C "");\n\n  if (!username || !password || !users[username]) {\n    process.exit(1)\n    // return res.sendStatus(400);\n  }\n  crypto.pbkdf2(password\x2C users[username].salt\x2C 10000\x2C 512\x2C 'sha512'\x2C (err\x2C hash) => {\n    if (users[username].hash.toString() === hash.toString()) {\n      res.sendStatus(200);\n    } else {\n      process.exit(1)\n      //res.sendStatus(401);\n    }\n  });\n});\n\n\nconst PORT = parseInt(process.argv[2]) || 8080;\nconst server = app.listen(PORT\x2C () => {\n  console.log(`Servidor escuchando en el puerto ${PORT}`);\n});\nserver.on("error"\x2C (error) => console.log(`Error en servidor: ${error}`));\n\n
code-source-info,0x3157152c9e06,137,0,2004,C10O0C26O0C46O0C50O16C57O16C62O51C69O51C73O51C75O83C79O109C80O109C82O117C87O129C95O129C101O117C106O152C119O152C125O215C138O215C144O676C157O676C163O1232C176O1232C182O1790C186O1799C190O1807C197O1811C201O1790C211O1790C213O1844C221O1851C226O1844C233O1935C246O1935C253O2004,,
code-creation,Function,11,176455,0x10f8cab40,108,SafeIterator node:internal/per_context/primordials:270:16,0x31575b5497e0,^
code-source-info,0x10f8cab40,6,7785,7845,,,
code-creation,Function,11,176491,0x10f8cac20,568,handleErrorFromBinding node:internal/fs/utils:340:32,0x31572ee6ad80,^
code-source-info,0x10f8cac20,78,7930,8428,,,
code-creation,Function,11,176515,0x10f8caec0,340,URLContext node:internal/url:160:14,0x315715859640,^
code-source-info,0x10f8caec0,33,3700,3912,,,
code-creation,Function,11,176545,0x10f8cb080,1468,onParseComplete node:internal/url:532:25,0x315715859be8,^
code-source-info,0x10f8cb080,33,14195,14864,,,
code-creation,Function,11,176565,0x10f8cb6a0,156,get protocol node:internal/url:769:15,0x31571585a260,^
code-source-info,0x10f8cb6a0,33,20946,20987,,,
code-creation,Function,11,176586,0x10f8cb7a0,252,SafePromise node:internal/per_context/primordials:393:16,0x31575b54a230,^
code-source-info,0x10f8cb7a0,6,11370,11401,,,
code-creation,LazyCompile,10,176717,0x3157152cab56,121,promiseRejectHandler node:internal/process/promises:97:30,0x31575b57ed28,~
script-source,26,node:internal/process/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  Error\x2C\n  ObjectDefineProperty\x2C\n  SafeWeakMap\x2C\n} = primordials;\n\nconst {\n  tickInfo\x2C\n  promiseRejectEvents: {\n    kPromiseRejectWithNoHandler\x2C\n    kPromiseHandlerAddedAfterReject\x2C\n    kPromiseResolveAfterResolved\x2C\n    kPromiseRejectAfterResolved\n  }\x2C\n  setPromiseRejectCallback\n} = internalBinding('task_queue');\n\nconst {\n  noSideEffectsToString\x2C\n  triggerUncaughtException\n} = internalBinding('errors');\n\nconst {\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n} = require('internal/async_hooks');\nconst async_hooks = require('async_hooks');\nconst { isErrorStackTraceLimitWritable } = require('internal/errors');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasRejectionToWarn = 1;\n\nconst maybeUnhandledPromises = new SafeWeakMap();\nconst pendingUnhandledRejections = [];\nconst asyncHandledRejections = [];\nlet lastPromiseId = 0;\n\n// --unhandled-rejections=none:\n// Emit 'unhandledRejection'\x2C but do not emit any warning.\nconst kIgnoreUnhandledRejections = 0;\n\n// --unhandled-rejections=warn:\n// Emit 'unhandledRejection'\x2C then emit 'UnhandledPromiseRejectionWarning'.\nconst kAlwaysWarnUnhandledRejections = 1;\n\n// --unhandled-rejections=strict:\n// Emit 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\n// Otherwise\x2C emit 'unhandledRejection'. If 'unhandledRejection' is not\n// handled\x2C emit 'UnhandledPromiseRejectionWarning'.\nconst kStrictUnhandledRejections = 2;\n\n// --unhandled-rejections=throw:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'uncaughtException'. If it's not handled\x2C print the error to stderr\n// and exit the process.\nconst kThrowUnhandledRejections = 3;\n\n// --unhandled-rejections=warn-with-error-code:\n// Emit 'unhandledRejection'\x2C if it's unhandled\x2C emit\n// 'UnhandledPromiseRejectionWarning'\x2C then set process exit code to 1.\n\nconst kWarnWithErrorCodeUnhandledRejections = 4;\n\nlet unhandledRejectionsMode;\n\nfunction setHasRejectionToWarn(value) {\n  tickInfo[kHasRejectionToWarn] = value ? 1 : 0;\n}\n\nfunction hasRejectionToWarn() {\n  return tickInfo[kHasRejectionToWarn] === 1;\n}\n\nfunction getUnhandledRejectionsMode() {\n  const { getOptionValue } = require('internal/options');\n  switch (getOptionValue('--unhandled-rejections')) {\n    case 'none':\n      return kIgnoreUnhandledRejections;\n    case 'warn':\n      return kAlwaysWarnUnhandledRejections;\n    case 'strict':\n      return kStrictUnhandledRejections;\n    case 'throw':\n      return kThrowUnhandledRejections;\n    case 'warn-with-error-code':\n      return kWarnWithErrorCodeUnhandledRejections;\n    default:\n      return kThrowUnhandledRejections;\n  }\n}\n\nfunction promiseRejectHandler(type\x2C promise\x2C reason) {\n  if (unhandledRejectionsMode === undefined) {\n    unhandledRejectionsMode = getUnhandledRejectionsMode();\n  }\n  switch (type) {\n    case kPromiseRejectWithNoHandler:\n      unhandledRejection(promise\x2C reason);\n      break;\n    case kPromiseHandlerAddedAfterReject:\n      handledRejection(promise);\n      break;\n    case kPromiseResolveAfterResolved:\n      resolveError('resolve'\x2C promise\x2C reason);\n      break;\n    case kPromiseRejectAfterResolved:\n      resolveError('reject'\x2C promise\x2C reason);\n      break;\n  }\n}\n\nfunction resolveError(type\x2C promise\x2C reason) {\n  // We have to wrap this in a next tick. Otherwise the error could be caught by\n  // the executed promise.\n  process.nextTick(() => {\n    process.emit('multipleResolves'\x2C type\x2C promise\x2C reason);\n  });\n}\n\nfunction unhandledRejection(promise\x2C reason) {\n  const asyncId = async_hooks.executionAsyncId();\n  const triggerAsyncId = async_hooks.triggerAsyncId();\n  const resource = promise;\n\n  const emit = (reason\x2C promise\x2C promiseInfo) => {\n    try {\n      pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n      if (promiseInfo.domain) {\n        return promiseInfo.domain.emit('error'\x2C reason);\n      }\n      return process.emit('unhandledRejection'\x2C reason\x2C promise);\n    } finally {\n      popAsyncContext(asyncId);\n    }\n  };\n\n  maybeUnhandledPromises.set(promise\x2C {\n    reason\x2C\n    uid: ++lastPromiseId\x2C\n    warned: false\x2C\n    domain: process.domain\x2C\n    emit\n  });\n  // This causes the promise to be referenced at least for one tick.\n  ArrayPrototypePush(pendingUnhandledRejections\x2C promise);\n  setHasRejectionToWarn(true);\n}\n\nfunction handledRejection(promise) {\n  const promiseInfo = maybeUnhandledPromises.get(promise);\n  if (promiseInfo !== undefined) {\n    maybeUnhandledPromises.delete(promise);\n    if (promiseInfo.warned) {\n      const { uid } = promiseInfo;\n      // Generate the warning object early to get a good stack trace.\n      // eslint-disable-next-line no-restricted-syntax\n      const warning = new Error('Promise rejection was handled ' +\n                                `asynchronously (rejection id: ${uid})`);\n      warning.name = 'PromiseRejectionHandledWarning';\n      warning.id = uid;\n      ArrayPrototypePush(asyncHandledRejections\x2C { promise\x2C warning });\n      setHasRejectionToWarn(true);\n      return;\n    }\n  }\n  if (maybeUnhandledPromises.size === 0 && asyncHandledRejections.length === 0)\n    setHasRejectionToWarn(false);\n}\n\nconst unhandledRejectionErrName = 'UnhandledPromiseRejectionWarning';\nfunction emitUnhandledRejectionWarning(uid\x2C reason) {\n  const warning = getErrorWithoutStack(\n    unhandledRejectionErrName\x2C\n    'Unhandled promise rejection. This error originated either by ' +\n      'throwing inside of an async function without a catch block\x2C ' +\n      'or by rejecting a promise which was not handled with .catch(). ' +\n      'To terminate the node process on unhandled promise ' +\n      'rejection\x2C use the CLI flag `--unhandled-rejections=strict` (see ' +\n      'https://nodejs.org/api/cli.html#cli_unhandled_rejections_mode). ' +\n      `(rejection id: ${uid})`\n  );\n  try {\n    if (reason instanceof Error) {\n      warning.stack = reason.stack;\n      process.emitWarning(reason.stack\x2C unhandledRejectionErrName);\n    } else {\n      process.emitWarning(\n        noSideEffectsToString(reason)\x2C unhandledRejectionErrName);\n    }\n  } catch {}\n\n  process.emitWarning(warning);\n}\n\n// If this method returns true\x2C we've executed user code or triggered\n// a warning to be emitted which requires the microtask and next tick\n// queues to be drained again.\nfunction processPromiseRejections() {\n  let maybeScheduledTicksOrMicrotasks = asyncHandledRejections.length > 0;\n\n  while (asyncHandledRejections.length > 0) {\n    const { promise\x2C warning } = ArrayPrototypeShift(asyncHandledRejections);\n    if (!process.emit('rejectionHandled'\x2C promise)) {\n      process.emitWarning(warning);\n    }\n  }\n\n  let len = pendingUnhandledRejections.length;\n  while (len--) {\n    const promise = ArrayPrototypeShift(pendingUnhandledRejections);\n    const promiseInfo = maybeUnhandledPromises.get(promise);\n    if (promiseInfo === undefined) {\n      continue;\n    }\n    promiseInfo.warned = true;\n    const { reason\x2C uid\x2C emit } = promiseInfo;\n\n    switch (unhandledRejectionsMode) {\n      case kStrictUnhandledRejections: {\n        const err = reason instanceof Error ?\n          reason : generateUnhandledRejectionError(reason);\n        triggerUncaughtException(err\x2C true /* fromPromise */);\n        const handled = emit(reason\x2C promise\x2C promiseInfo);\n        if (!handled) emitUnhandledRejectionWarning(uid\x2C reason);\n        break;\n      }\n      case kIgnoreUnhandledRejections: {\n        emit(reason\x2C promise\x2C promiseInfo);\n        break;\n      }\n      case kAlwaysWarnUnhandledRejections: {\n        emit(reason\x2C promise\x2C promiseInfo);\n        emitUnhandledRejectionWarning(uid\x2C reason);\n        break;\n      }\n      case kThrowUnhandledRejections: {\n        const handled = emit(reason\x2C promise\x2C promiseInfo);\n        if (!handled) {\n          const err = reason instanceof Error ?\n            reason : generateUnhandledRejectionError(reason);\n          triggerUncaughtException(err\x2C true /* fromPromise */);\n        }\n        break;\n      }\n      case kWarnWithErrorCodeUnhandledRejections: {\n        const handled = emit(reason\x2C promise\x2C promiseInfo);\n        if (!handled) {\n          emitUnhandledRejectionWarning(uid\x2C reason);\n          process.exitCode = 1;\n        }\n        break;\n      }\n    }\n    maybeScheduledTicksOrMicrotasks = true;\n  }\n  return maybeScheduledTicksOrMicrotasks ||\n         pendingUnhandledRejections.length !== 0;\n}\n\nfunction getErrorWithoutStack(name\x2C message) {\n  // Reset the stack to prevent any overhead.\n  const tmp = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmp;\n  ObjectDefineProperty(err\x2C 'name'\x2C {\n    value: name\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: true\x2C\n  });\n  return err;\n}\n\nfunction generateUnhandledRejectionError(reason) {\n  const message =\n    'This error originated either by ' +\n    'throwing inside of an async function without a catch block\x2C ' +\n    'or by rejecting a promise which was not handled with .catch().' +\n    ' The promise rejected with the reason ' +\n    `"${noSideEffectsToString(reason)}".`;\n\n  const err = getErrorWithoutStack('UnhandledPromiseRejection'\x2C message);\n  err.code = 'ERR_UNHANDLED_REJECTION';\n  return err;\n}\n\nfunction listenForRejections() {\n  setPromiseRejectCallback(promiseRejectHandler);\n}\nmodule.exports = {\n  hasRejectionToWarn\x2C\n  setHasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\x2C\n};\n
code-source-info,0x3157152cab56,26,2708,3248,C0O2736C6O2785C9O2811C15O2809C21O2847C23O2872C35O2966C44O3054C53O3154C62O2907C65O2907C70O2950C72O3005C75O3005C79O3038C81O3090C93O3090C98O3138C100O3189C112O3189C117O3236C120O3247,,
tick,0x7ff803e80ea8,177426,0,0x0,3,0x1077801f0,0x10709caa0,0x3157152c3c02,0x107af48ff
code-creation,LazyCompile,10,177448,0x3157152cb70e,91,getUnhandledRejectionsMode node:internal/process/promises:79:36,0x31575b57ecd8,~
code-source-info,0x3157152cb70e,26,2179,2677,C0O2213C6O2213C11O2194C16O2244C19O2252C61O2319C65O2353C66O2377C70O2415C71O2441C75O2475C76O2500C80O2533C81O2573C85O2618C86O2638C90O2671,,
code-creation,LazyCompile,10,177524,0x3157152cb9de,164,unhandledRejection node:internal/process/promises:125:28,0x31575b57edc8,~
code-source-info,0x3157152cb9de,26,3529,4326,C0O3529C14O3567C21O3579C26O3579C30O3567C32O3624C39O3636C44O3636C48O3624C50O3673C52O3673C54O3698C59O4028C66O4051C71O4055C78O4070C86O4089C95O4089C112O4143C122O4155C126O4051C132O4237C143O4256C146O4237C151O4296C158O4296C163O4325,,
code-creation,LazyCompile,10,177605,0x3157152cbbde,13,executionAsyncId node:internal/async_hooks:561:26,0x31575b57a160,~
script-source,24,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// For performance reasons\x2C only track Promises when a hook is enabled.\nconst { setPromiseHooks } = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nsetCallbackTrampoline(callbackTrampoline);\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n\n  const publicResource = resource[owner_symbol];\n\n  if (publicResource != null) {\n    return publicResource;\n  }\n\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    value: name\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nconst destroyedSymbol = Symbol('destroyed');\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const destroyed = { destroyed: false };\n  promise[destroyedSymbol] = destroyed;\n  registerDestroyHook(promise\x2C asyncId\x2C destroyed);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n}\n\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  setPromiseHooks(\n    initHook\x2C\n    promiseBeforeHook\x2C\n    promiseAfterHook\x2C\n    promiseResolveHooksExist() ? promiseResolveHook : undefined\x2C\n  );\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook) {\n    setPromiseHooks(undefined\x2C undefined\x2C undefined\x2C undefined);\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\n  }\n};\n
code-source-info,0x3157152cbbde,24,18344,18395,C0O18351C7O18374C9O18373C12O18393,,
tick,0x7ff803df1f01,178946,0,0x0,3,0x1077801f0,0x3157152cb9f8,0x3157152cab97,0x10709caa0,0x3157152c3c02,0x107af48ff
code-creation,LazyCompile,10,178961,0x3157152cd016,13,triggerAsyncId node:internal/async_hooks:565:24,0x31575b57a1b0,~
code-source-info,0x3157152cd016,24,18420,18469,C0O18427C7O18450C9O18449C12O18467,,
code-creation,LazyCompile,10,179012,0x3157152cd246,25,setHasRejectionToWarn node:internal/process/promises:71:31,0x31575b57e4c8,~
code-source-info,0x3157152cd246,26,2001,2061,C0O2013C7O2022C12O2045C19O2043C24O2060,,
code-creation,LazyCompile,10,179089,0x3157152cd4a6,177,handledRejection node:internal/process/promises:154:26,0x31575b57ee18,~
code-source-info,0x3157152cd4a6,26,4353,5159,C0O4387C5O4410C10O4410C16O4426C18O4463C23O4486C28O4492C33O4523C39O4547C44O4715C57O4825C67O4758C73O4715C79O4840C81O4853C85O4895C87O4906C91O4919C98O4938C108O4964C114O4973C118O4919C123O4991C128O4991C132O5026C133O5033C134O5046C139O5073C145O5078C152O5087C155O5110C161O5117C166O5128C171O5128C176O5158,,
code-creation,LazyCompile,10,179152,0x3157152cd706,34,isCommonJSGlobalLikeNotDefinedError node:internal/modules/esm/module_job:44:45,0x31576e52a318,~
code-source-info,0x3157152cd706,104,917,1047,C0O917C9O937C20O961C28O937C33O1047,,
code-creation,LazyCompile,10,179191,0x3157152cd82e,16, node:internal/modules/esm/module_job:47:5,0x3157152cd650,~
code-source-info,0x3157152cd82e,104,980,1043,C0O1009C5O1016C12O1009C15O1043,,
code-creation,LazyCompile,10,179361,0x3157152cdaf6,12,hasUncaughtExceptionCaptureCallback node:internal/process/execution:118:45,0x31572ee495a0,~
script-source,75,node:internal/process/execution,'use strict';\n\nconst {\n  globalThis\x2C\n} = primordials;\n\nconst path = require('path');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET\x2C\n    ERR_EVAL_ESM_CANNOT_PRINT\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  executionAsyncId\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  afterHooksExist\x2C\n  emitAfter\n} = require('internal/async_hooks');\n\n// shouldAbortOnUncaughtToggle is a typed array for faster\n// communication with JS.\nconst { shouldAbortOnUncaughtToggle } = internalBinding('util');\n\nfunction tryGetCwd() {\n  try {\n    return process.cwd();\n  } catch {\n    // getcwd(3) can fail if the current working directory has been deleted.\n    // Fall back to the directory name of the (absolute) executable path.\n    // It's not really correct but what are the alternatives?\n    return path.dirname(process.execPath);\n  }\n}\n\nfunction evalModule(source\x2C print) {\n  if (print) {\n    throw new ERR_EVAL_ESM_CANNOT_PRINT();\n  }\n  const { loadESM } = require('internal/process/esm_loader');\n  const { handleMainPromise } = require('internal/modules/run_main');\n  return handleMainPromise(loadESM((loader) => loader.eval(source)));\n}\n\nfunction evalScript(name\x2C body\x2C breakFirstLine\x2C print) {\n  const CJSModule = require('internal/modules/cjs/loader').Module;\n  const { kVmBreakFirstLineSymbol } = require('internal/util');\n  const { pathToFileURL } = require('url');\n\n  const cwd = tryGetCwd();\n  const origModule = globalThis.module;  // Set e.g. when called from the REPL.\n\n  const module = new CJSModule(name);\n  module.filename = path.join(cwd\x2C name);\n  module.paths = CJSModule._nodeModulePaths(cwd);\n\n  const asyncESM = require('internal/process/esm_loader');\n  const baseUrl = pathToFileURL(module.filename).href;\n\n  // Create wrapper for cache entry\n  const script = `\n    globalThis.module = module;\n    globalThis.exports = exports;\n    globalThis.__dirname = __dirname;\n    globalThis.require = require;\n    return (main) => main();\n  `;\n  globalThis.__filename = name;\n  const result = module._compile(script\x2C `${name}-wrapper`)(() =>\n    require('vm').runInThisContext(body\x2C {\n      filename: name\x2C\n      displayErrors: true\x2C\n      [kVmBreakFirstLineSymbol]: !!breakFirstLine\x2C\n      async importModuleDynamically(specifier) {\n        const loader = await asyncESM.esmLoader;\n        return loader.import(specifier\x2C baseUrl);\n      }\n    }));\n  if (print) {\n    const { log } = require('internal/console/global');\n    log(result);\n  }\n\n  if (origModule !== undefined)\n    globalThis.module = origModule;\n}\n\nconst exceptionHandlerState = {\n  captureFn: null\x2C\n  reportFlag: false\n};\n\nfunction setUncaughtExceptionCaptureCallback(fn) {\n  if (fn === null) {\n    exceptionHandlerState.captureFn = fn;\n    shouldAbortOnUncaughtToggle[0] = 1;\n    process.report.reportOnUncaughtException = exceptionHandlerState.reportFlag;\n    return;\n  }\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn'\x2C ['Function'\x2C 'null']\x2C fn);\n  }\n  if (exceptionHandlerState.captureFn !== null) {\n    throw new ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET();\n  }\n  exceptionHandlerState.captureFn = fn;\n  shouldAbortOnUncaughtToggle[0] = 0;\n  exceptionHandlerState.reportFlag =\n    process.report.reportOnUncaughtException === true;\n  process.report.reportOnUncaughtException = false;\n}\n\nfunction hasUncaughtExceptionCaptureCallback() {\n  return exceptionHandlerState.captureFn !== null;\n}\n\nfunction noop() {}\n\n// XXX(joyeecheung): for some reason this cannot be defined at the top-level\n// and exported to be written to process._fatalException\x2C it has to be\n// returned as an *anonymous function* wrapped inside a factory function\x2C\n// otherwise it breaks the test-timers.setInterval async hooks test -\n// this may indicate that node::errors::TriggerUncaughtException() should\n// fix up the callback scope before calling into process._fatalException\x2C\n// or this function should take extra care of the async hooks before it\n// schedules a setImmediate.\nfunction createOnGlobalUncaughtException() {\n  // The C++ land node::errors::TriggerUncaughtException() will\n  // exit the process if it returns false\x2C and continue execution if it\n  // returns true (which indicates that the exception is handled by the user).\n  return (er\x2C fromPromise) => {\n    // It's possible that defaultTriggerAsyncId was set for a constructor\n    // call that threw and was never cleared. So clear it now.\n    clearDefaultTriggerAsyncId();\n\n    // If diagnostic reporting is enabled\x2C call into its handler to see\n    // whether it is interested in handling the situation.\n    // Ignore if the error is scoped inside a domain.\n    // use == in the checks as we want to allow for null and undefined\n    if (er == null || er.domain == null) {\n      try {\n        const report = internalBinding('report');\n        if (report != null && report.shouldReportOnUncaughtException()) {\n          report.writeReport(\n            typeof er?.message === 'string' ?\n              er.message :\n              'Exception'\x2C\n            'Exception'\x2C\n            null\x2C\n            er ?? {});\n        }\n      } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.\n    }\n\n    const type = fromPromise ? 'unhandledRejection' : 'uncaughtException';\n    process.emit('uncaughtExceptionMonitor'\x2C er\x2C type);\n    if (exceptionHandlerState.captureFn !== null) {\n      exceptionHandlerState.captureFn(er);\n    } else if (!process.emit('uncaughtException'\x2C er\x2C type)) {\n      // If someone handled it\x2C then great. Otherwise\x2C die in C++ land\n      // since that means that we'll exit the process\x2C emit the 'exit' event.\n      try {\n        if (!process._exiting) {\n          process._exiting = true;\n          process.exitCode = 1;\n          process.emit('exit'\x2C 1);\n        }\n      } catch {\n        // Nothing to be done about it at this point.\n      }\n      return false;\n    }\n\n    // If we handled an error\x2C then make sure any ticks get processed\n    // by ensuring that the next Immediate cycle isn't empty.\n    require('timers').setImmediate(noop);\n\n    // Emit the after() hooks now that the exception has been handled.\n    if (afterHooksExist()) {\n      do {\n        emitAfter(executionAsyncId());\n      } while (hasAsyncIdStack());\n    }\n    // And completely empty the id stack\x2C including anything that may be\n    // cached on the native side.\n    clearAsyncIdStack();\n\n    return true;\n  };\n}\n\nfunction readStdin(callback) {\n  process.stdin.setEncoding('utf8');\n\n  let code = '';\n  process.stdin.on('data'\x2C (d) => {\n    code += d;\n  });\n\n  process.stdin.on('end'\x2C () => {\n    callback(code);\n  });\n}\n\nmodule.exports = {\n  readStdin\x2C\n  tryGetCwd\x2C\n  evalModule\x2C\n  evalScript\x2C\n  onGlobalUncaughtException: createOnGlobalUncaughtException()\x2C\n  setUncaughtExceptionCaptureCallback\x2C\n  hasUncaughtExceptionCaptureCallback\n};\n
code-source-info,0x3157152cdaf6,75,3401,3458,C0O3408C5O3437C10O3447C11O3456,,
tick,0x7ff803d552bb,179923,0,0x0,3,0x1077801f0,0x315766fb377e,0x107af4847
code-creation,LazyCompile,10,179990,0x3157152ce436,324, node:internal/process/execution:136:10,0x31572ee49678,~
code-source-info,0x3157152ce436,75,4290,6432,C0O4454C5O4454C8O4745C13O4766C23O4819C29O4819C34O4854C37O4883C42O4883C48O4937C63O4971C74O5013C94O5105C96O4937C107O5230C118O5292C121O5300C135O5300C140O5348C145O5374C151O5402C156O5424C161O5424C168O5450C171O5463C185O5463C195O5671C198O5684C204O5706C208O5723C212O5741C217O5758C221O5773C224O5781C235O5781C247O5892C248O5905C249O6049C255O6049C260O6066C268O6067C273O6163C278O6167C283O6207C290O6217C293O6217C297O6207C301O6253C306O6253C311O6194C314O6390C319O6390C322O6416C323O6428,,
code-creation,LazyCompile,10,180052,0x3157152ce6f6,18,clearDefaultTriggerAsyncId node:internal/async_hooks:440:36,0x31575b579bc8,~
code-source-info,0x3157152ce6f6,24,15080,15134,C0O15087C7O15103C12O15127C17O15133,,
code-creation,LazyCompile,10,180096,0x3157152ce7de,20,handler node:internal/modules/run_main:59:19,0x315766fb3f60,~
code-source-info,0x3157152ce7de,114,1908,1985,C0O1917C3O1929C9O1959C14O1976C19O1984,,
code-creation,LazyCompile,10,180221,0x3157152ce8f6,46,beforeInspector node:internal/errors:738:18,0x31575b564b20,~
script-source,11,node:internal/errors,/* eslint node-core/documented-errors: "error" */\n/* eslint node-core/alphabetize-errors: "error" */\n/* eslint node-core/prefer-util-format-errors: "error" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change\x2C the code should not.\n\nconst {\n  AggregateError\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  ErrorPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGet\x2C\n  MathAbs\x2C\n  MathMax\x2C\n  Number\x2C\n  NumberIsInteger\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectIsExtensible\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RangeError\x2C\n  ReflectApply\x2C\n  RegExpPrototypeTest\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeMatch\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kIsNodeError = Symbol('kIsNodeError');\n\nconst isWindows = process.platform === 'win32';\n\nconst messages = new SafeMap();\nconst codes = {};\n\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string'\x2C\n  'function'\x2C\n  'number'\x2C\n  'object'\x2C\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function'\x2C\n  'Object'\x2C\n  'boolean'\x2C\n  'bigint'\x2C\n  'symbol'\x2C\n];\n\nconst MainContextError = Error;\nconst overrideStackTrace = new SafeWeakMap();\nconst kNoOverride = Symbol('kNoOverride');\nlet userStackTraceLimit;\nconst nodeInternalPrefix = '__node_internal_';\nconst prepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // API for node internals to override error stack formatting\n  // without interfering with userland code.\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error\x2C trace);\n  }\n\n  const firstFrame = trace[0]?.getFunctionName();\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\x2C nodeInternalPrefix)) {\n    for (let l = trace.length - 1; l >= 0; l--) {\n      const fn = trace[l]?.getFunctionName();\n      if (fn && StringPrototypeStartsWith(fn\x2C nodeInternalPrefix)) {\n        ArrayPrototypeSplice(trace\x2C 0\x2C l + 1);\n        break;\n      }\n    }\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\x2C\n    // it is updated at every new exception in `captureLargerStackTrace`.\n    if (trace.length > userStackTraceLimit)\n      ArrayPrototypeSplice(trace\x2C userStackTraceLimit);\n  }\n\n  const globalOverride =\n    maybeOverridePrepareStackTrace(globalThis\x2C error\x2C trace);\n  if (globalOverride !== kNoOverride) return globalOverride;\n\n  // Normal error formatting:\n  //\n  // Error: Message\n  //     at function (file)\n  //     at file\n  let errorString;\n  if (kIsNodeError in error) {\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\n  } else {\n    errorString = ErrorPrototypeToString(error);\n  }\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\\n    at ${ArrayPrototypeJoin(trace\x2C '\\n    at ')}`;\n};\n\nconst maybeOverridePrepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // Polyfill of V8's Error.prepareStackTrace API.\n  // https://crbug.com/v8/7848\n  // `globalThis` is the global that contains the constructor which\n  // created `error`.\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\n    return globalThis.Error.prepareStackTrace(error\x2C trace);\n  }\n  // We still have legacy usage that depends on the main context's `Error`\n  // being used\x2C even when the error is from a different context.\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\n  if (typeof MainContextError.prepareStackTrace === 'function') {\n    return MainContextError.prepareStackTrace(error\x2C trace);\n  }\n\n  return kNoOverride;\n};\n\nconst aggregateTwoErrors = hideStackFrames((innerError\x2C outerError) => {\n  if (innerError && outerError) {\n    if (ArrayIsArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      ArrayPrototypePush(outerError.errors\x2C innerError);\n      return outerError;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new AggregateError(new SafeArrayIterator([\n      outerError\x2C\n      innerError\x2C\n    ])\x2C outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n});\n\n// Lazily loaded\nlet util;\nlet assert;\n\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  if (!internalUtil) {\n    internalUtil = require('internal/util');\n  }\n  return internalUtil;\n}\n\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect;\n}\n\nlet buffer;\nfunction lazyBuffer() {\n  if (buffer === undefined)\n    buffer = require('buffer').Buffer;\n  return buffer;\n}\n\nfunction isErrorStackTraceLimitWritable() {\n  const desc = ObjectGetOwnPropertyDescriptor(Error\x2C 'stackTraceLimit');\n  if (desc === undefined) {\n    return ObjectIsExtensible(Error);\n  }\n\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'writable') ?\n    desc.writable :\n    desc.set !== undefined;\n}\n\n// A specialized Error that includes an additional info property with\n// additional information about the error condition.\n// It has the properties present in a UVException but with a custom error\n// message followed by the uv error code and uv error message.\n// It also has its own error code with the original uv error context put into\n// `err.info`.\n// The context passed into this error must have .code\x2C .syscall and .message\x2C\n// and may have .path and .dest.\nclass SystemError extends Error {\n  constructor(key\x2C context) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    super();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const prefix = getMessage(key\x2C []\x2C this);\n    let message = `${prefix}: ${context.syscall} returned ` +\n                  `${context.code} (${context.message})`;\n\n    if (context.path !== undefined)\n      message += ` ${context.path}`;\n    if (context.dest !== undefined)\n      message += ` => ${context.dest}`;\n\n    captureLargerStackTrace(this);\n\n    this.code = key;\n\n    ObjectDefineProperties(this\x2C {\n      [kIsNodeError]: {\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      name: {\n        value: 'SystemError'\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      info: {\n        value: context\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n        writable: false\x2C\n      }\x2C\n      errno: {\n        get() {\n          return context.errno;\n        }\x2C\n        set: (value) => {\n          context.errno = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      syscall: {\n        get() {\n          return context.syscall;\n        }\x2C\n        set: (value) => {\n          context.syscall = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n\n    if (context.path !== undefined) {\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\n      // introduced. The `path` and `dest` properties in the context seem to\n      // always be of type string. We should probably just remove the\n      // `.toString()` and `Buffer.from()` operations and set the value on the\n      // context as the user did.\n      ObjectDefineProperty(this\x2C 'path'\x2C {\n        get() {\n          return context.path != null ?\n            context.path.toString() : context.path;\n        }\x2C\n        set: (value) => {\n          context.path = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n\n    if (context.dest !== undefined) {\n      ObjectDefineProperty(this\x2C 'dest'\x2C {\n        get() {\n          return context.dest != null ?\n            context.dest.toString() : context.dest;\n        }\x2C\n        set: (value) => {\n          context.dest = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\x2C ctx) {\n    return lazyInternalUtilInspect().inspect(this\x2C {\n      ...ctx\x2C\n      getters: true\x2C\n      customInspect: false\n    });\n  }\n}\n\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key\x2C ctx);\n    }\n  };\n}\n\nfunction makeNodeErrorWithCode(Base\x2C key) {\n  return function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key\x2C args\x2C error);\n    ObjectDefineProperties(error\x2C {\n      [kIsNodeError]: {\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      toString: {\n        value() {\n          return `${this.name} [${key}]: ${this.message}`;\n        }\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n    captureLargerStackTrace(error);\n    error.code = key;\n    return error;\n  };\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...args: any[]) => any} T\n * @type {(fn: T) => T}\n */\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name;\n  ObjectDefineProperty(fn\x2C 'name'\x2C { value: hidden });\n  return fn;\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym\x2C val\x2C def\x2C ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym\x2C val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def\x2C sym);\n  }\n\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz\x2C sym);\n    });\n  }\n  codes[sym] = def;\n}\n\nfunction getMessage(key\x2C args\x2C self) {\n  const msg = messages.get(key);\n\n  if (assert === undefined) assert = require('internal/assert');\n\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length\x2C // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${msg.length}).`\n    );\n    return ReflectApply(msg\x2C self\x2C args);\n  }\n\n  const expectedLength =\n    (StringPrototypeMatch(msg\x2C /%[dfijoOs]/g) || []).length;\n  assert(\n    expectedLength === args.length\x2C\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return msg;\n\n  ArrayPrototypeUnshift(args\x2C msg);\n  return ReflectApply(lazyInternalUtilInspect().format\x2C null\x2C args);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  if (!uvBinding) {\n    uvBinding = internalBinding('uv');\n  }\n  return uvBinding;\n}\n\nconst uvUnmappedError = ['UNKNOWN'\x2C 'unknown error'];\n\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  if (!uvBinding.errmap) {\n    uvBinding.errmap = uvBinding.getErrorMap();\n  }\n  return MapPrototypeGet(uvBinding.errmap\x2C name);\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  function captureLargerStackTrace(err) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Infinity;\n    }\n    ErrorCaptureStackTrace(err);\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n\n    return err;\n  });\n\n/**\n * This creates an error compatible with errors produced in the C++\n * function UVException using a context object with data assembled in C++.\n * The goal is to migrate them to ERR_* errors later when compatibility is\n * not a concern.\n *\n * @param {Object} ctx\n * @returns {Error}\n */\nconst uvException = hideStackFrames(function uvException(ctx) {\n  const { 0: code\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}\x2C ${ctx.syscall}`;\n\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // Pass the message to the constructor instead of setting it on the object\n  // to make sure it is the same as the one created in C++\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n\n  return captureLargerStackTrace(err);\n});\n\n/**\n * This creates an error compatible with errors produced in the C++\n * This function should replace the deprecated\n * `exceptionWithHostPort()` function.\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @returns {Error}\n */\nconst uvExceptionWithHostPort = hideStackFrames(\n  function uvExceptionWithHostPort(err\x2C syscall\x2C address\x2C port) {\n    const { 0: code\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\n    const message = `${syscall} ${code}: ${uvmsg}`;\n    let details = '';\n\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${message}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.code = code;\n    ex.errno = err;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * This used to be util._errnoException().\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} [original]\n * @returns {Error}\n */\nconst errnoException = hideStackFrames(\n  function errnoException(err\x2C syscall\x2C original) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    const message = original ?\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(message);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * Deprecated\x2C new function is `uvExceptionWithHostPort()`\n * New function added the error description directly\n * from C++. this method for backwards compatibility\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @param {string} [additional]\n * @returns {Error}\n */\nconst exceptionWithHostPort = hideStackFrames(\n  function exceptionWithHostPort(err\x2C syscall\x2C address\x2C port\x2C additional) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    if (util === undefined) util = require('util');\n    const code = util.getSystemErrorName(err);\n    let details = '';\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n    if (additional) {\n      details += ` - Local (${additional})`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${syscall} ${code}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * @param {number|string} code - A libuv error number or a c-ares error code\n * @param {string} syscall\n * @param {string} [hostname]\n * @returns {Error}\n */\nconst dnsException = hideStackFrames(function(code\x2C syscall\x2C hostname) {\n  let errno;\n  // If `code` is of type number\x2C it is a libuv error number\x2C else it is a\n  // c-ares error code.\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\n  // make them available in a property that's not error.errno (since they\n  // can be in conflict with libuv error codes). Also make sure\n  // util.getSystemErrorName() can understand them when an being informed that\n  // the number is a c-ares error code.\n  if (typeof code === 'number') {\n    errno = code;\n    // ENOTFOUND is not a proper POSIX error\x2C but this error has been in place\n    // long enough that it's not practical to remove it.\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = 'ENOTFOUND'; // Fabricated error name.\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n\n  return captureLargerStackTrace(ex);\n});\n\nfunction connResetException(msg) {\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(msg);\n  ex.code = 'ECONNRESET';\n  return ex;\n}\n\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\n * Returns true if `err.name` and `err.message` are equal to engine-specific\n * values indicating max call stack size has been exceeded.\n * "Maximum call stack size exceeded" in V8.\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() { overflowStack(); }\n      overflowStack();\n    } catch (err) {\n      maxStack_ErrorMessage = err.message;\n      maxStack_ErrorName = err.name;\n    }\n  }\n\n  return err && err.name === maxStack_ErrorName &&\n         err.message === maxStack_ErrorMessage;\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${StringPrototypeSlice(val\x2C i - 3\x2C i)}${res}`;\n  }\n  return `${StringPrototypeSlice(val\x2C 0\x2C i)}${res}`;\n}\n\n// Used to enhance the stack that will be picked up by the inspector\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\n\n// These are supposed to be called only on fatal exceptions before\n// the process exits.\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\n      return error.stack;\n    }\n\n    try {\n      // Set the error.stack here so it gets picked up by the\n      // inspector.\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n      // We are just enhancing the error. If it fails\x2C ignore it.\n    }\n    return error.stack;\n  }\x2C\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    // Some consoles do not convert ANSI escape sequences to colors\x2C\n    // rather display them directly to the stdout. On those consoles\x2C\n    // libuv emulates colors by intercepting stdout stream and calling\n    // corresponding Windows API functions for setting console colors.\n    // However\x2C fatal error are handled differently and we cannot easily\n    // highlight them. On Windows\x2C detecting whether a console supports\n    // ANSI escape sequences is not reliable.\n    if (process.platform === 'win32') {\n      const info = internalBinding('os').getOSInformation();\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\x2C '.')\x2C\n                                    Number);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect\x2C\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors &&\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\n                   require('internal/tty').hasColors()) ||\n                   defaultColors);\n    try {\n      return inspect(error\x2C {\n        colors\x2C\n        customInspect: false\x2C\n        depth: MathMax(inspect.defaultOptions.depth\x2C 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\n\n// Ensures the printed error line is from user code.\nlet _kArrowMessagePrivateSymbol\x2C _setHiddenValue;\nfunction setArrowMessage(err\x2C arrowMessage) {\n  if (!_kArrowMessagePrivateSymbol) {\n    ({\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\x2C\n      setHiddenValue: _setHiddenValue\x2C\n    } = internalBinding('util'));\n  }\n  _setHiddenValue(err\x2C _kArrowMessagePrivateSymbol\x2C arrowMessage);\n}\n\n// Hide stack lines before the first user code line.\nfunction hideInternalStackFrames(error) {\n  overrideStackTrace.set(error\x2C (error\x2C stackFrames) => {\n    let frames = stackFrames;\n    if (typeof stackFrames === 'object') {\n      frames = ArrayPrototypeFilter(\n        stackFrames\x2C\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\x2C\n                                            'node:internal')\n      );\n    }\n    ArrayPrototypeUnshift(frames\x2C error);\n    return ArrayPrototypeJoin(frames\x2C '\\n    at ');\n  });\n}\n\n// Node uses an AbortError that isn't exactly the same as the DOMException\n// to make usage of the error in userland and readable-stream easier.\n// It is a regular error with `.code` and `.name`.\nclass AbortError extends Error {\n  constructor() {\n    super('The operation was aborted');\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n}\nmodule.exports = {\n  aggregateTwoErrors\x2C\n  codes\x2C\n  dnsException\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  getMessage\x2C\n  hideStackFrames\x2C\n  hideInternalStackFrames\x2C\n  isErrorStackTraceLimitWritable\x2C\n  isStackOverflowError\x2C\n  setArrowMessage\x2C\n  connResetException\x2C\n  uvErrmapGet\x2C\n  uvException\x2C\n  uvExceptionWithHostPort\x2C\n  SystemError\x2C\n  AbortError\x2C\n  // This is exported only to facilitate testing.\n  E\x2C\n  kNoOverride\x2C\n  prepareStackTrace\x2C\n  maybeOverridePrepareStackTrace\x2C\n  overrideStackTrace\x2C\n  kEnhanceStackBeforeInspector\x2C\n  fatalExceptionStackEnhancers\x2C\n  kIsNodeError\x2C\n  captureLargerStackTrace\x2C\n};\n\n// To declare an error message\x2C use the E(sym\x2C val\x2C def) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The def must be an error class.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1'\x2C 'This is the error value'\x2C Error);\n// E('EXAMPLE_KEY2'\x2C (a\x2C b) => return `${a} ${b}`\x2C RangeError);\n//\n// Once an error code has been assigned\x2C the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\n//\n// Note: Node.js specific errors must begin with the prefix ERR_\n\nE('ERR_AMBIGUOUS_ARGUMENT'\x2C 'The "%s" argument is ambiguous. %s'\x2C TypeError);\nE('ERR_ARG_NOT_ITERABLE'\x2C '%s must be iterable'\x2C TypeError);\nE('ERR_ASSERTION'\x2C '%s'\x2C Error);\nE('ERR_ASYNC_CALLBACK'\x2C '%s must be a function'\x2C TypeError);\nE('ERR_ASYNC_TYPE'\x2C 'Invalid name for async "type": %s'\x2C TypeError);\nE('ERR_BROTLI_INVALID_PARAM'\x2C '%s is not a valid Brotli parameter'\x2C RangeError);\nE('ERR_BUFFER_OUT_OF_BOUNDS'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name = undefined) => {\n    if (name) {\n      return `"${name}" is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n  }\x2C RangeError);\nE('ERR_BUFFER_TOO_LARGE'\x2C\n  'Cannot create a Buffer larger than %s bytes'\x2C\n  RangeError);\nE('ERR_CANNOT_WATCH_SIGINT'\x2C 'Cannot watch for SIGINT signals'\x2C Error);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\x2C\n  'Child closed before reply received'\x2C Error);\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\x2C\n  "Forked processes must have an IPC channel\x2C missing value 'ipc' in %s"\x2C\n  Error);\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\x2C '%s maxBuffer length exceeded'\x2C\n  RangeError);\nE('ERR_CONSOLE_WRITABLE_STREAM'\x2C\n  'Console expects a writable stream instance for %s'\x2C TypeError);\nE('ERR_CONTEXT_NOT_INITIALIZED'\x2C 'context used is not initialized'\x2C Error);\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\x2C\n  'Custom engines not supported by this OpenSSL'\x2C Error);\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\x2C 'Invalid ECDH format: %s'\x2C TypeError);\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\x2C\n  'Public key is not valid for specified curve'\x2C Error);\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\x2C 'Engine "%s" was not found'\x2C Error);\nE('ERR_CRYPTO_FIPS_FORCED'\x2C\n  'Cannot set FIPS mode\x2C it was forced with --force-fips at startup.'\x2C Error);\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\x2C 'Cannot set FIPS mode in a non-FIPS build.'\x2C\n  Error);\nE('ERR_CRYPTO_HASH_FINALIZED'\x2C 'Digest already called'\x2C Error);\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\x2C 'Hash update failed'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\x2C 'Incompatible %s: %s'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\x2C 'The selected key encoding %s %s.'\x2C\n  Error);\nE('ERR_CRYPTO_INVALID_DIGEST'\x2C 'Invalid digest: %s'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_JWK'\x2C 'Invalid JWK data'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\x2C\n  'Invalid key object type %s\x2C expected %s.'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_STATE'\x2C 'Invalid state for operation %s'\x2C Error);\nE('ERR_CRYPTO_PBKDF2_ERROR'\x2C 'PBKDF2 error'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\x2C 'Invalid scrypt parameter'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\x2C 'Scrypt algorithm not supported'\x2C Error);\n// Switch to TypeError. The current implementation does not seem right.\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\x2C 'No key provided to sign'\x2C Error);\nE('ERR_DEBUGGER_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DEBUGGER_STARTUP_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DIR_CLOSED'\x2C 'Directory handle was closed'\x2C Error);\nE('ERR_DIR_CONCURRENT_OPERATION'\x2C\n  'Cannot do synchronous work on directory handle with concurrent ' +\n  'asynchronous operations'\x2C Error);\nE('ERR_DNS_SET_SERVERS_FAILED'\x2C 'c-ares failed to set servers: "%s" [%s]'\x2C\n  Error);\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\x2C\n  'A callback was registered through ' +\n     'process.setUncaughtExceptionCaptureCallback()\x2C which is mutually ' +\n     'exclusive with using the `domain` module'\x2C\n  Error);\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\x2C\n  'The `domain` module is in use\x2C which is mutually exclusive with calling ' +\n     'process.setUncaughtExceptionCaptureCallback()'\x2C\n  Error);\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\x2C function(encoding\x2C ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}\x2C TypeError);\nE('ERR_ENCODING_NOT_SUPPORTED'\x2C 'The "%s" encoding is not supported'\x2C\n  RangeError);\nE('ERR_EVAL_ESM_CANNOT_PRINT'\x2C '--print cannot be used with ESM input'\x2C Error);\nE('ERR_EVENT_RECURSION'\x2C 'The event "%s" is already being dispatched'\x2C Error);\nE('ERR_FALSY_VALUE_REJECTION'\x2C function(reason) {\n  this.reason = reason;\n  return 'Promise was rejected with falsy value';\n}\x2C Error);\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\x2C\n  'The feature %s is unavailable on the current platform' +\n  '\x2C which is being used to run Node.js'\x2C\n  TypeError);\nE('ERR_FS_CP_DIR_TO_NON_DIR'\x2C\n  'Cannot overwrite directory with non-directory'\x2C SystemError);\nE('ERR_FS_CP_EEXIST'\x2C 'Target already exists'\x2C SystemError);\nE('ERR_FS_CP_EINVAL'\x2C 'Invalid src or dest'\x2C SystemError);\nE('ERR_FS_CP_FIFO_PIPE'\x2C 'Cannot copy a FIFO pipe'\x2C SystemError);\nE('ERR_FS_CP_NON_DIR_TO_DIR'\x2C\n  'Cannot overwrite non-directory with directory'\x2C SystemError);\nE('ERR_FS_CP_SOCKET'\x2C 'Cannot copy a socket file'\x2C SystemError);\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\x2C\n  'Cannot overwrite symlink in subdirectory of self'\x2C SystemError);\nE('ERR_FS_CP_UNKNOWN'\x2C 'Cannot copy an unknown file type'\x2C SystemError);\nE('ERR_FS_EISDIR'\x2C 'Path is a directory'\x2C SystemError);\nE('ERR_FS_FILE_TOO_LARGE'\x2C 'File size (%s) is greater than 2 GB'\x2C RangeError);\nE('ERR_FS_INVALID_SYMLINK_TYPE'\x2C\n  'Symlink type must be one of "dir"\x2C "file"\x2C or "junction". Received "%s"'\x2C\n  Error); // Switch to TypeError. The current implementation does not seem right\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN'\x2C\n  'HTTP/2 ALTSVC frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_ALTSVC_LENGTH'\x2C\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_CONNECT_AUTHORITY'\x2C\n  ':authority header is required for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_PATH'\x2C\n  'The :path header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_SCHEME'\x2C\n  'The :scheme header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_GOAWAY_SESSION'\x2C\n  'New streams cannot be created after receiving a GOAWAY'\x2C Error);\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND'\x2C\n  'Cannot specify additional headers after response initiated'\x2C Error);\nE('ERR_HTTP2_HEADERS_SENT'\x2C 'Response has already been initiated.'\x2C Error);\nE('ERR_HTTP2_HEADER_SINGLE_VALUE'\x2C\n  'Header field "%s" must only have a single value'\x2C TypeError);\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED'\x2C\n  'Informational status codes cannot be used'\x2C RangeError);\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS'\x2C\n  'HTTP/1 Connection specific headers are forbidden: "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_INFO_STATUS'\x2C\n  'Invalid informational status code: %s'\x2C RangeError);\nE('ERR_HTTP2_INVALID_ORIGIN'\x2C\n  'HTTP/2 ORIGIN frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH'\x2C\n  'Packed settings length must be a multiple of six'\x2C RangeError);\nE('ERR_HTTP2_INVALID_PSEUDOHEADER'\x2C\n  '"%s" is an invalid pseudoheader or is used incorrectly'\x2C TypeError);\nE('ERR_HTTP2_INVALID_SESSION'\x2C 'The session has been destroyed'\x2C Error);\nE('ERR_HTTP2_INVALID_SETTING_VALUE'\x2C\n  // Using default arguments here is important so the arguments are not counted\n  // towards `Function#length`.\n  function(name\x2C actual\x2C min = undefined\x2C max = undefined) {\n    this.actual = actual;\n    if (min !== undefined) {\n      this.min = min;\n      this.max = max;\n    }\n    return `Invalid value for setting "${name}": ${actual}`;\n  }\x2C TypeError\x2C RangeError);\nE('ERR_HTTP2_INVALID_STREAM'\x2C 'The stream has been destroyed'\x2C Error);\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK'\x2C\n  'Maximum number of pending settings acknowledgements'\x2C Error);\nE('ERR_HTTP2_NESTED_PUSH'\x2C\n  'A push stream cannot initiate another push stream.'\x2C Error);\nE('ERR_HTTP2_NO_MEM'\x2C 'Out of memory'\x2C Error);\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION'\x2C\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'\x2C\n  Error);\nE('ERR_HTTP2_ORIGIN_LENGTH'\x2C\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_OUT_OF_STREAMS'\x2C\n  'No stream ID is available because maximum stream ID has been reached'\x2C\n  Error);\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN'\x2C\n  'Responses with %s status must not have a payload'\x2C Error);\nE('ERR_HTTP2_PING_CANCEL'\x2C 'HTTP2 ping cancelled'\x2C Error);\nE('ERR_HTTP2_PING_LENGTH'\x2C 'HTTP2 ping payload must be 8 bytes'\x2C RangeError);\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED'\x2C\n  'Cannot set HTTP/2 pseudo-headers'\x2C TypeError);\nE('ERR_HTTP2_PUSH_DISABLED'\x2C 'HTTP/2 client has disabled push streams'\x2C Error);\nE('ERR_HTTP2_SEND_FILE'\x2C 'Directories cannot be sent'\x2C Error);\nE('ERR_HTTP2_SEND_FILE_NOSEEK'\x2C\n  'Offset or length can only be specified for regular files'\x2C Error);\nE('ERR_HTTP2_SESSION_ERROR'\x2C 'Session closed with error code %s'\x2C Error);\nE('ERR_HTTP2_SETTINGS_CANCEL'\x2C 'HTTP2 session settings canceled'\x2C Error);\nE('ERR_HTTP2_SOCKET_BOUND'\x2C\n  'The socket is already bound to an Http2Session'\x2C Error);\nE('ERR_HTTP2_SOCKET_UNBOUND'\x2C\n  'The socket has been disconnected from the Http2Session'\x2C Error);\nE('ERR_HTTP2_STATUS_101'\x2C\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2'\x2C Error);\nE('ERR_HTTP2_STATUS_INVALID'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP2_STREAM_CANCEL'\x2C function(error) {\n  let msg = 'The pending stream has been canceled';\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === 'string')\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}\x2C Error);\nE('ERR_HTTP2_STREAM_ERROR'\x2C 'Stream closed with error code %s'\x2C Error);\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY'\x2C\n  'A stream cannot depend on itself'\x2C Error);\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES'\x2C 'Too many invalid HTTP/2 frames'\x2C Error);\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT'\x2C\n  'Trailing headers have already been sent'\x2C Error);\nE('ERR_HTTP2_TRAILERS_NOT_READY'\x2C\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\n  'emitted'\x2C Error);\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL'\x2C 'protocol "%s" is unsupported.'\x2C Error);\nE('ERR_HTTP_HEADERS_SENT'\x2C\n  'Cannot %s headers after they are sent to the client'\x2C Error);\nE('ERR_HTTP_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP_INVALID_STATUS_CODE'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP_REQUEST_TIMEOUT'\x2C 'Request timeout'\x2C Error);\nE('ERR_HTTP_SOCKET_ENCODING'\x2C\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.'\x2C Error);\nE('ERR_HTTP_TRAILER_INVALID'\x2C\n  'Trailers are invalid with this transfer encoding'\x2C Error);\nE('ERR_ILLEGAL_CONSTRUCTOR'\x2C 'Illegal constructor'\x2C TypeError);\nE('ERR_INCOMPATIBLE_OPTION_PAIR'\x2C\n  'Option "%s" cannot be used in combination with option "%s"'\x2C TypeError);\nE('ERR_INPUT_TYPE_NOT_ALLOWED'\x2C '--input-type can only be used with string ' +\n  'input via --eval\x2C --print\x2C or STDIN'\x2C Error);\nE('ERR_INSPECTOR_ALREADY_ACTIVATED'\x2C\n  'Inspector is already activated. Close it with inspector.close() ' +\n  'before activating it again.'\x2C\n  Error);\nE('ERR_INSPECTOR_ALREADY_CONNECTED'\x2C '%s is already connected'\x2C Error);\nE('ERR_INSPECTOR_CLOSED'\x2C 'Session was closed'\x2C Error);\nE('ERR_INSPECTOR_COMMAND'\x2C 'Inspector error %d: %s'\x2C Error);\nE('ERR_INSPECTOR_NOT_ACTIVE'\x2C 'Inspector is not active'\x2C Error);\nE('ERR_INSPECTOR_NOT_AVAILABLE'\x2C 'Inspector is not available'\x2C Error);\nE('ERR_INSPECTOR_NOT_CONNECTED'\x2C 'Session is not connected'\x2C Error);\nE('ERR_INSPECTOR_NOT_WORKER'\x2C 'Current thread is not a worker'\x2C Error);\nE('ERR_INTERNAL_ASSERTION'\x2C (message) => {\n  const suffix = 'This is caused by either a bug in Node.js ' +\n    'or incorrect usage of Node.js internals.\\n' +\n    'Please open an issue with this stack trace at ' +\n    'https://github.com/nodejs/node/issues\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}\x2C Error);\nE('ERR_INVALID_ADDRESS_FAMILY'\x2C function(addressType\x2C host\x2C port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}\x2C RangeError);\nE('ERR_INVALID_ARG_TYPE'\x2C\n  (name\x2C expected\x2C actual) => {\n    assert(typeof name === 'string'\x2C "'name' must be a string");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (StringPrototypeEndsWith(name\x2C ' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n      msg += `"${name}" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string'\x2C\n             'All expected entries have to be of type string');\n      if (ArrayPrototypeIncludes(kTypes\x2C value)) {\n        ArrayPrototypePush(types\x2C StringPrototypeToLowerCase(value));\n      } else if (RegExpPrototypeTest(classRegExp\x2C value)) {\n        ArrayPrototypePush(instances\x2C value);\n      } else {\n        assert(value !== 'object'\x2C\n               'The value "object" should be written as "Object"');\n        ArrayPrototypePush(other\x2C value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = ArrayPrototypeIndexOf(types\x2C 'object');\n      if (pos !== -1) {\n        ArrayPrototypeSplice(types\x2C pos\x2C 1);\n        ArrayPrototypePush(instances\x2C 'Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = ArrayPrototypePop(types);\n        msg += `one of type ${ArrayPrototypeJoin(types\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = ArrayPrototypePop(instances);\n        msg +=\n          `an instance of ${ArrayPrototypeJoin(instances\x2C '\x2C ')}\x2C or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = ArrayPrototypePop(other);\n        msg += `one of ${ArrayPrototypeJoin(other\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = lazyInternalUtilInspect()\n          .inspect(actual\x2C { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = lazyInternalUtilInspect()\n        .inspect(actual\x2C { colors: false });\n      if (inspected.length > 25)\n        inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 25)}...`;\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_ARG_VALUE'\x2C (name\x2C value\x2C reason = 'is invalid') => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 128)}...`;\n  }\n  const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_ASYNC_ID'\x2C 'Invalid %s value: %s'\x2C RangeError);\nE('ERR_INVALID_BUFFER_SIZE'\x2C\n  'Buffer size must be a multiple of %s'\x2C RangeError);\nE('ERR_INVALID_CALLBACK'\x2C\n  'Callback must be a function. Received %O'\x2C TypeError);\nE('ERR_INVALID_CHAR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name\x2C field = undefined) => {\n    let msg = `Invalid character in ${name}`;\n    if (field !== undefined) {\n      msg += ` ["${field}"]`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_CURSOR_POS'\x2C\n  'Cannot set cursor row without setting its column'\x2C TypeError);\nE('ERR_INVALID_FD'\x2C\n  '"fd" must be a positive integer: %s'\x2C RangeError);\nE('ERR_INVALID_FD_TYPE'\x2C 'Unsupported fd type: %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_HOST'\x2C\n  'File URL host must be "localhost" or empty on %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_PATH'\x2C 'File URL path %s'\x2C TypeError);\nE('ERR_INVALID_HANDLE_TYPE'\x2C 'This handle type cannot be sent'\x2C TypeError);\nE('ERR_INVALID_HTTP_TOKEN'\x2C '%s must be a valid HTTP token ["%s"]'\x2C TypeError);\nE('ERR_INVALID_IP_ADDRESS'\x2C 'Invalid IP address: %s'\x2C TypeError);\nE('ERR_INVALID_MODULE_SPECIFIER'\x2C (request\x2C reason\x2C base = undefined) => {\n  return `Invalid module "${request}" ${reason}${base ?\n    ` imported from ${base}` : ''}`;\n}\x2C TypeError);\nE('ERR_INVALID_PACKAGE_CONFIG'\x2C (path\x2C base\x2C message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\n    ''}${message ? `. ${message}` : ''}`;\n}\x2C Error);\nE('ERR_INVALID_PACKAGE_TARGET'\x2C\n  (pkgPath\x2C key\x2C target\x2C isImport = false\x2C base = undefined) => {\n    const relError = typeof target === 'string' && !isImport &&\n      target.length && !StringPrototypeStartsWith(target\x2C './');\n    if (key === '.') {\n      assert(isImport === false);\n      return `Invalid "exports" main target ${JSONStringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${base ?\n          ` imported from ${base}` : ''}${relError ?\n          '; targets must start with "./"' : ''}`;\n    }\n    return `Invalid "${isImport ? 'imports' : 'exports'}" target ${\n      JSONStringify(target)} defined for '${key}' in the package config ${\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\n      '; targets must start with "./"' : ''}`;\n  }\x2C Error);\nE('ERR_INVALID_PROTOCOL'\x2C\n  'Protocol "%s" not supported. Expected "%s"'\x2C\n  TypeError);\nE('ERR_INVALID_REPL_EVAL_CONFIG'\x2C\n  'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'\x2C TypeError);\nE('ERR_INVALID_REPL_INPUT'\x2C '%s'\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY'\x2C (input\x2C name\x2C prop\x2C value) => {\n  return `Expected a valid ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${value}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY_VALUE'\x2C (input\x2C name\x2C prop\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${type}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_VALUE'\x2C (input\x2C name\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned from the "${name}"` +\n         ` function but got ${type}.`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_STATE'\x2C 'Invalid state: %s'\x2C Error\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_SYNC_FORK_INPUT'\x2C\n  'Asynchronous forks do not support ' +\n    'Buffer\x2C TypedArray\x2C DataView or string input: %s'\x2C\n  TypeError);\nE('ERR_INVALID_THIS'\x2C 'Value of "this" must be of type %s'\x2C TypeError);\nE('ERR_INVALID_TUPLE'\x2C '%s must be an iterable %s tuple'\x2C TypeError);\nE('ERR_INVALID_URI'\x2C 'URI malformed'\x2C URIError);\nE('ERR_INVALID_URL'\x2C function(input) {\n  this.input = input;\n  // Don't include URL in message.\n  // (See https://github.com/nodejs/node/pull/38614)\n  return 'Invalid URL';\n}\x2C TypeError);\nE('ERR_INVALID_URL_SCHEME'\x2C\n  (expected) => {\n    if (typeof expected === 'string')\n      expected = [expected];\n    assert(expected.length <= 2);\n    const res = expected.length === 2 ?\n      `one of scheme ${expected[0]} or ${expected[1]}` :\n      `of scheme ${expected[0]}`;\n    return `The URL must be ${res}`;\n  }\x2C TypeError);\nE('ERR_IPC_CHANNEL_CLOSED'\x2C 'Channel closed'\x2C Error);\nE('ERR_IPC_DISCONNECTED'\x2C 'IPC channel is already disconnected'\x2C Error);\nE('ERR_IPC_ONE_PIPE'\x2C 'Child process can have only one IPC pipe'\x2C Error);\nE('ERR_IPC_SYNC_FORK'\x2C 'IPC cannot be used with synchronous forks'\x2C Error);\nE('ERR_MANIFEST_ASSERT_INTEGRITY'\x2C\n  (moduleURL\x2C realIntegrities) => {\n    let msg = `The content of "${\n      moduleURL\n    }" does not match the expected integrity.`;\n    if (realIntegrities.size) {\n      const sri = ArrayPrototypeJoin(\n        ArrayFrom(realIntegrities.entries()\x2C\n                  ({ 0: alg\x2C 1: dgs }) => `${alg}-${dgs}`)\x2C\n        ' '\n      );\n      msg += ` Integrities found are: ${sri}`;\n    } else {\n      msg += ' The resource was not found in the policy.';\n    }\n    return msg;\n  }\x2C Error);\nE('ERR_MANIFEST_DEPENDENCY_MISSING'\x2C\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\n  'conditions: %s'\x2C\n  Error);\nE('ERR_MANIFEST_INTEGRITY_MISMATCH'\x2C\n  'Manifest resource %s has multiple entries but integrity lists do not match'\x2C\n  SyntaxError);\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD'\x2C\n  'Manifest resource %s has invalid property value for %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_INVALID_SPECIFIER'\x2C\n  'Manifest resource %s has invalid dependency mapping %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_TDZ'\x2C 'Manifest initialization has not yet run'\x2C Error);\nE('ERR_MANIFEST_UNKNOWN_ONERROR'\x2C\n  'Manifest specified unknown error behavior "%s".'\x2C\n  SyntaxError);\nE('ERR_METHOD_NOT_IMPLEMENTED'\x2C 'The %s method is not implemented'\x2C Error);\nE('ERR_MISSING_ARGS'\x2C\n  (...args) => {\n    assert(args.length > 0\x2C 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    const wrap = (a) => `"${a}"`;\n    args = ArrayPrototypeMap(\n      args\x2C\n      (a) => (ArrayIsArray(a) ?\n        ArrayPrototypeJoin(ArrayPrototypeMap(a\x2C wrap)\x2C ' or ') :\n        wrap(a))\n    );\n    switch (len) {\n      case 1:\n        msg += `${args[0]} argument`;\n        break;\n      case 2:\n        msg += `${args[0]} and ${args[1]} arguments`;\n        break;\n      default:\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args\x2C 0\x2C len - 1)\x2C '\x2C ');\n        msg += `\x2C and ${args[len - 1]} arguments`;\n        break;\n    }\n    return `${msg} must be specified`;\n  }\x2C TypeError);\nE('ERR_MISSING_OPTION'\x2C '%s is required'\x2C TypeError);\nE('ERR_MODULE_NOT_FOUND'\x2C (path\x2C base\x2C type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}\x2C Error);\nE('ERR_MULTIPLE_CALLBACK'\x2C 'Callback called multiple times'\x2C Error);\nE('ERR_NAPI_CONS_FUNCTION'\x2C 'Constructor must be a function'\x2C TypeError);\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS'\x2C\n  'byte_offset + byte_length should be less than or equal to the size in ' +\n    'bytes of the array passed in'\x2C\n  RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT'\x2C\n  'start offset of %s should be a multiple of %s'\x2C RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH'\x2C\n  'Invalid typed array length'\x2C RangeError);\nE('ERR_NO_CRYPTO'\x2C\n  'Node.js is not compiled with OpenSSL crypto support'\x2C Error);\nE('ERR_NO_ICU'\x2C\n  '%s is not supported on Node.js compiled without ICU'\x2C TypeError);\nE('ERR_OPERATION_FAILED'\x2C 'Operation failed: %s'\x2C Error\x2C TypeError);\nE('ERR_OUT_OF_RANGE'\x2C\n  (str\x2C range\x2C input\x2C replaceDefaultBoolean = false) => {\n    assert(range\x2C 'Missing "range" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of "${str}" is out of range.`;\n    let received;\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    } else {\n      received = lazyInternalUtilInspect().inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }\x2C RangeError);\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED'\x2C (specifier\x2C packagePath\x2C base) => {\n  return `Package import specifier "${specifier}" is not defined${packagePath ?\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}\x2C TypeError);\nE('ERR_PACKAGE_PATH_NOT_EXPORTED'\x2C (pkgPath\x2C subpath\x2C base = undefined) => {\n  if (subpath === '.')\n    return `No "exports" main defined in ${pkgPath}package.json${base ?\n      ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by "exports" in ${\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}\x2C Error);\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP'\x2C\n  '%d is not a valid timestamp'\x2C TypeError);\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS'\x2C '%s'\x2C TypeError);\nE('ERR_REQUIRE_ESM'\x2C\n  function(filename\x2C hasEsmSyntax\x2C parentPath = null\x2C packageJsonPath = null) {\n    hideInternalStackFrames(this);\n    let msg = `require() of ES Module ${filename}${parentPath ? ` from ${\n      parentPath}` : ''} not supported.`;\n    if (!packageJsonPath) {\n      if (StringPrototypeEndsWith(filename\x2C '.mjs'))\n        msg += `\\nInstead change the require of ${filename} to a dynamic ` +\n            'import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    const path = require('path');\n    const basename = parentPath && path.basename(filename) ===\n      path.basename(parentPath) ? filename : path.basename(filename);\n    if (hasEsmSyntax) {\n      msg += `\\nInstead change the require of ${basename} in ${parentPath} to` +\n        ' a dynamic import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    msg += `\\n${basename} is treated as an ES module file as it is a .js ` +\n      'file whose nearest parent package.json contains "type": "module" ' +\n      'which declares all .js files in that package scope as ES modules.' +\n      `\\nInstead rename ${basename} to end in .cjs\x2C change the requiring ` +\n      'code to use dynamic import() which is available in all CommonJS ' +\n      'modules\x2C or change "type": "module" to "type": "commonjs" in ' +\n      `${packageJsonPath} to treat all .js files as CommonJS (using .mjs for ` +\n      'all ES modules instead).\\n';\n    return msg;\n  }\x2C Error);\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED'\x2C\n  'Script execution was interrupted by `SIGINT`'\x2C Error);\nE('ERR_SERVER_ALREADY_LISTEN'\x2C\n  'Listen method has been called more than once without closing.'\x2C Error);\nE('ERR_SERVER_NOT_RUNNING'\x2C 'Server is not running.'\x2C Error);\nE('ERR_SOCKET_ALREADY_BOUND'\x2C 'Socket is already bound'\x2C Error);\nE('ERR_SOCKET_BAD_BUFFER_SIZE'\x2C\n  'Buffer size must be a positive integer'\x2C TypeError);\nE('ERR_SOCKET_BAD_PORT'\x2C (name\x2C port\x2C allowZero = true) => {\n  assert(typeof allowZero === 'boolean'\x2C\n         "The 'allowZero' argument must be of type boolean.");\n  const operator = allowZero ? '>=' : '>';\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}\x2C RangeError);\nE('ERR_SOCKET_BAD_TYPE'\x2C\n  'Bad socket type specified. Valid types are: udp4\x2C udp6'\x2C TypeError);\nE('ERR_SOCKET_BUFFER_SIZE'\x2C\n  'Could not get or set buffer size'\x2C\n  SystemError);\nE('ERR_SOCKET_CLOSED'\x2C 'Socket is closed'\x2C Error);\nE('ERR_SOCKET_DGRAM_IS_CONNECTED'\x2C 'Already connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED'\x2C 'Not connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_RUNNING'\x2C 'Not running'\x2C Error);\nE('ERR_SRI_PARSE'\x2C\n  'Subresource Integrity string %j had an unexpected %j at position %d'\x2C\n  SyntaxError);\nE('ERR_STREAM_ALREADY_FINISHED'\x2C\n  'Cannot call %s after a stream was finished'\x2C\n  Error);\nE('ERR_STREAM_CANNOT_PIPE'\x2C 'Cannot pipe\x2C not readable'\x2C Error);\nE('ERR_STREAM_DESTROYED'\x2C 'Cannot call %s after a stream was destroyed'\x2C Error);\nE('ERR_STREAM_NULL_VALUES'\x2C 'May not write null values to stream'\x2C TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE'\x2C 'Premature close'\x2C Error);\nE('ERR_STREAM_PUSH_AFTER_EOF'\x2C 'stream.push() after EOF'\x2C Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT'\x2C\n  'stream.unshift() after end event'\x2C Error);\nE('ERR_STREAM_WRAP'\x2C 'Stream has StringDecoder set or is in objectMode'\x2C Error);\nE('ERR_STREAM_WRITE_AFTER_END'\x2C 'write after end'\x2C Error);\nE('ERR_SYNTHETIC'\x2C 'JavaScript Callstack'\x2C Error);\nE('ERR_SYSTEM_ERROR'\x2C 'A system error occurred'\x2C SystemError);\nE('ERR_TLS_CERT_ALTNAME_FORMAT'\x2C 'Invalid subject alternative name string'\x2C\n  SyntaxError);\nE('ERR_TLS_CERT_ALTNAME_INVALID'\x2C function(reason\x2C host\x2C cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}\x2C Error);\nE('ERR_TLS_DH_PARAM_SIZE'\x2C 'DH parameter size %s is less than 2048'\x2C Error);\nE('ERR_TLS_HANDSHAKE_TIMEOUT'\x2C 'TLS handshake timeout'\x2C Error);\nE('ERR_TLS_INVALID_CONTEXT'\x2C '%s must be a SecureContext'\x2C TypeError);\nE('ERR_TLS_INVALID_PROTOCOL_VERSION'\x2C\n  '%j is not a valid %s TLS protocol version'\x2C TypeError);\nE('ERR_TLS_INVALID_STATE'\x2C 'TLS socket connection must be securely established'\x2C\n  Error);\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT'\x2C\n  'TLS protocol version %j conflicts with secureProtocol %j'\x2C TypeError);\nE('ERR_TLS_RENEGOTIATION_DISABLED'\x2C\n  'TLS session renegotiation disabled for this socket'\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_TLS_REQUIRED_SERVER_NAME'\x2C\n  '"servername" is required parameter for Server.addContext'\x2C Error);\nE('ERR_TLS_SESSION_ATTACK'\x2C 'TLS session renegotiation attack detected'\x2C Error);\nE('ERR_TLS_SNI_FROM_SERVER'\x2C\n  'Cannot issue SNI from a TLS server-side socket'\x2C Error);\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED'\x2C\n  'At least one category is required'\x2C TypeError);\nE('ERR_TRACE_EVENTS_UNAVAILABLE'\x2C 'Trace events are unavailable'\x2C Error);\n\n// This should probably be a `RangeError`.\nE('ERR_TTY_INIT_FAILED'\x2C 'TTY initialization failed'\x2C SystemError);\nE('ERR_UNAVAILABLE_DURING_EXIT'\x2C 'Cannot call function in process exit ' +\n  'handler'\x2C Error);\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET'\x2C\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\n    'callback was already active'\x2C\n  Error);\nE('ERR_UNESCAPED_CHARACTERS'\x2C '%s contains unescaped characters'\x2C TypeError);\nE('ERR_UNHANDLED_ERROR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (err = undefined) => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }\x2C Error);\nE('ERR_UNKNOWN_BUILTIN_MODULE'\x2C 'No such built-in module: %s'\x2C Error);\nE('ERR_UNKNOWN_CREDENTIAL'\x2C '%s identifier does not exist: %s'\x2C Error);\nE('ERR_UNKNOWN_ENCODING'\x2C 'Unknown encoding: %s'\x2C TypeError);\nE('ERR_UNKNOWN_FILE_EXTENSION'\x2C\n  'Unknown file extension "%s" for %s'\x2C\n  TypeError);\nE('ERR_UNKNOWN_MODULE_FORMAT'\x2C 'Unknown module format: %s'\x2C RangeError);\nE('ERR_UNKNOWN_SIGNAL'\x2C 'Unknown signal: %s'\x2C TypeError);\nE('ERR_UNSUPPORTED_DIR_IMPORT'\x2C "Directory import '%s' is not supported " +\n'resolving ES modules imported from %s'\x2C Error);\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME'\x2C (url) => {\n  let msg = 'Only file and data URLs are supported by the default ESM loader';\n  if (isWindows && url.protocol.length === 2) {\n    msg +=\n      '. On Windows\x2C absolute paths must be valid file:// URLs';\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE'\x2C\n  'At least one valid performance entry type is required'\x2C Error);\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'\x2C\n  'A dynamic import callback was not specified.'\x2C TypeError);\nE('ERR_VM_MODULE_ALREADY_LINKED'\x2C 'Module has already been linked'\x2C Error);\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA'\x2C\n  'Cached data cannot be created for a module which has been evaluated'\x2C Error);\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT'\x2C\n  'Linked modules must use the same context'\x2C Error);\nE('ERR_VM_MODULE_LINKING_ERRORED'\x2C\n  'Linking has already failed for the provided module'\x2C Error);\nE('ERR_VM_MODULE_NOT_MODULE'\x2C\n  'Provided module is not an instance of Module'\x2C Error);\nE('ERR_VM_MODULE_STATUS'\x2C 'Module status %s'\x2C Error);\nE('ERR_WASI_ALREADY_STARTED'\x2C 'WASI instance has already started'\x2C Error);\nE('ERR_WORKER_INIT_FAILED'\x2C 'Worker initialization failure: %s'\x2C Error);\nE('ERR_WORKER_INVALID_EXEC_ARGV'\x2C (errors\x2C msg = 'invalid execArgv flags') =>\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors\x2C '\x2C ')}`\x2C\n  Error);\nE('ERR_WORKER_NOT_RUNNING'\x2C 'Worker instance not running'\x2C Error);\nE('ERR_WORKER_OUT_OF_MEMORY'\x2C\n  'Worker terminated due to reaching memory limit: %s'\x2C Error);\nE('ERR_WORKER_PATH'\x2C (filename) =>\n  'The worker script or module filename must be an absolute path or a ' +\n  'relative path starting with \\'./\\' or \\'../\\'.' +\n  (StringPrototypeStartsWith(filename\x2C 'file://') ?\n    ' Wrap file:// URLs with `new URL`.' : ''\n  ) +\n  (StringPrototypeStartsWith(filename\x2C 'data:text/javascript') ?\n    ' Wrap data: URLs with `new URL`.' : ''\n  ) +\n  ` Received "${filename}"`\x2C\n  TypeError);\nE('ERR_WORKER_UNSERIALIZABLE_ERROR'\x2C\n  'Serializing an uncaught exception failed'\x2C Error);\nE('ERR_WORKER_UNSUPPORTED_OPERATION'\x2C\n  '%s is not supported in workers'\x2C TypeError);\nE('ERR_ZLIB_INITIALIZATION_FAILED'\x2C 'Initialization failed'\x2C Error);\n
code-source-info,0x3157152ce8f6,11,22107,22483,C0O22121C2O22138C4O22137C11O22205C15O22211C19O22317C21O22337C23O22336C27O22366C31O22329C41O22473C45O22479,,
tick,0x7ff803e80ead,184335,0,0x0,3,0x1077801f0,0x1070da090,0x315766fb37b8,0x107af4847
tick,0x7ff803d551ca,184351,0,0x0,3,0x1077801f0,0x1070da090,0x315766fb37b8,0x107af4847
tick,0x7ff803e80ed4,184359,0,0x0,3,0x1077801f0,0x1070da090,0x315766fb37b8,0x107af4847
tick,0x1076d876a,184434,0,0x0,2,0x1077801f0,0x1072c0f00,0x3157152ce901,0x1070da090,0x315766fb37b8,0x107af4847
code-creation,LazyCompile,10,184479,0x3157152d1e4e,343,prepareStackTrace node:internal/errors:90:27,0x31575b563068,~
code-source-info,0x3157152d1e4e,11,2163,3651,C0O2305C5O2328C10O2328C17O2356C22O2375C27O2375C33O2391C38O2410C43O2416C48O2436C53O2452C54O2479C55O2484C61O2487C66O2489C74O2510C78O2528C83O2566C86O2528C93O2612C97O2619C101O2626C102O2626C107O2656C109O2661C115O2664C120O2666C128O2691C132O2701C137O2731C140O2701C147O2762C156O2795C163O2762C168O2809C170O2633C175O2593C178O2994C185O3003C187O3001C192O3030C199O3058C202O3030C207O3114C221O3114C227O3174C229O3197C231O3193C236O3210C238O3232C239O3340C241O3355C248O3372C253O3411C265O3426C280O3442C291O3468C296O3482C301O3529C307O3536C312O3549C314O3568C315O3575C327O3608C333O3608C342O3649,,
code-creation,LazyCompile,10,184563,0x3157152d2146,70,maybeOverridePrepareStackTrace node:internal/errors:135:40,0x31575b563ee8,~
code-source-info,0x3157152d2146,11,3693,4400,C0O3921C7O3926C18O3986C23O3992C28O3992C34O4024C35O4247C40O4275C48O4315C53O4339C58O4339C64O4371C65O4379C69O4398,,
code-creation,LazyCompile,10,184678,0x3157152d245e,243,afterInspector node:internal/errors:752:17,0x31575b564b90,~
code-source-info,0x3157152d245e,11,22501,23889,C0O22543C5O22570C7O23052C10O23064C17O23073C22O23107C28O23107C33O23128C38O23129C43O23167C50O23185C55O23210C62O23185C70O23257C73O23167C79O23272C80O23279C86O23283C93O23296C101O23300C106O23319C108O23456C111O23456C115O23370C125O23426C130O23502C140O23536C145O23559C153O23560C161O23579C172O23611C177O23634C182O23635C194O23717C201O23734C207O23787C210O23803C215O23818C223O23787C232O23709C237O23837C240O23858C242O23879,,
code-creation,LazyCompile,10,184738,0x3157152d26b6,30,lazyInternalUtilInspect node:internal/errors:184:33,0x31575b563fd8,~
code-source-info,0x3157152d26b6,11,5224,5354,C0O5231C6O5263C12O5285C19O5283C25O5325C29O5352,,
code-creation,Eval,10,185012,0x3157152d2dc6,5, node:internal/tty:1:1,0x3157152d2b70,~
script-source,138,node:internal/tty,// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a copy\n// of this software and associated documentation files (the "Software")\x2C to deal\n// in the Software without restriction\x2C including without limitation the rights\n// to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C distribute\x2C sublicense\x2C and/or sell\n// copies of the Software\x2C and to permit persons to whom the Software is\n// furnished to do so\x2C subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS OR\n// IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\x2C\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C DAMAGES OR OTHER\n// LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR OTHERWISE\x2C ARISING FROM\x2C\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSome\x2C\n  RegExpPrototypeTest\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst { validateInteger } = require('internal/validators');\n\nlet OSRelease;\n\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\n\n// Some entries were taken from `dircolors`\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\n// support more than 16 colors\x2C but this was not tested for.\n//\n// Copyright (C) 1996-2016 Free Software Foundation\x2C Inc. Copying and\n// distribution of this file\x2C with or without modification\x2C are permitted\n// provided the copyright notice and this notice are preserved.\nconst TERM_ENVS = {\n  'eterm': COLORS_16\x2C\n  'cons25': COLORS_16\x2C\n  'console': COLORS_16\x2C\n  'cygwin': COLORS_16\x2C\n  'dtterm': COLORS_16\x2C\n  'gnome': COLORS_16\x2C\n  'hurd': COLORS_16\x2C\n  'jfbterm': COLORS_16\x2C\n  'konsole': COLORS_16\x2C\n  'kterm': COLORS_16\x2C\n  'mlterm': COLORS_16\x2C\n  'mosh': COLORS_16m\x2C\n  'putty': COLORS_16\x2C\n  'st': COLORS_16\x2C\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\n  'rxvt-unicode-24bit': COLORS_16m\x2C\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\n  'terminator': COLORS_16m\n};\n\nconst TERM_ENVS_REG_EXP = [\n  /ansi/\x2C\n  /color/\x2C\n  /linux/\x2C\n  /^con[0-9]*x[0-9]/\x2C\n  /^rxvt/\x2C\n  /^screen/\x2C\n  /^xterm/\x2C\n  /^vt100/\x2C\n];\n\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = '';\n  if (env.NODE_DISABLE_COLORS !== undefined)\n    name = 'NODE_DISABLE_COLORS';\n  if (env.NO_COLOR !== undefined) {\n    if (name !== '') {\n      name += "' and '";\n    }\n    name += 'NO_COLOR';\n  }\n\n  if (name !== '') {\n    process.emitWarning(\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`\x2C\n      'Warning'\n    );\n    warned = true;\n  }\n}\n\n// The `getColorDepth` API got inspired by multiple sources such as\n// https://github.com/chalk/supports-color\x2C\n// https://github.com/isaacs/color-support.\nfunction getColorDepth(env = process.env) {\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\n  // consistency throughout the ecosystem.\n  if (env.FORCE_COLOR !== undefined) {\n    switch (env.FORCE_COLOR) {\n      case '':\n      case '1':\n      case 'true':\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case '2':\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case '3':\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n\n  if (env.NODE_DISABLE_COLORS !== undefined ||\n      // See https://no-color.org/\n      env.NO_COLOR !== undefined ||\n      // The "dumb" special terminal\x2C as defined by terminfo\x2C doesn't support\n      // ANSI color control codes.\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n      env.TERM === 'dumb') {\n    return COLORS_2;\n  }\n\n  if (process.platform === 'win32') {\n    // Lazy load for startup performance.\n    if (OSRelease === undefined) {\n      const { release } = require('os');\n      OSRelease = StringPrototypeSplit(release()\x2C '.');\n    }\n    // Windows 10 build 10586 is the first Windows release that supports 256\n    // colors. Windows 10 build 14931 is the first release that supports\n    // 16m/TrueColor.\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n\n    return COLORS_16;\n  }\n\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n\n  if (env.CI) {\n    if ([\n      'APPVEYOR'\x2C\n      'BUILDKITE'\x2C\n      'CIRCLECI'\x2C\n      'DRONE'\x2C\n      'GITHUB_ACTIONS'\x2C\n      'GITLAB_CI'\x2C\n      'TRAVIS'\x2C\n    ].some((sign) => sign in env) || env.CI_NAME === 'codeship') {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return RegExpPrototypeTest(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2\x2C}\\.)/\x2C env.TEAMCITY_VERSION) ?\n      COLORS_16 : COLORS_2;\n  }\n\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      if (!env.TERM_PROGRAM_VERSION ||\n        RegExpPrototypeTest(/^[0-2]\\./\x2C env.TERM_PROGRAM_VERSION)\n      ) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case 'HyperTerm':\n    case 'MacTerm':\n      return COLORS_16m;\n    case 'Apple_Terminal':\n      return COLORS_256;\n  }\n\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\n    return COLORS_16m;\n  }\n\n  if (env.TERM) {\n    if (RegExpPrototypeTest(/^xterm-256/\x2C env.TERM)) {\n      return COLORS_256;\n    }\n\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP\x2C\n                           (term) => RegExpPrototypeTest(term\x2C termEnv))) {\n      return COLORS_16;\n    }\n  }\n  // Move 16 color COLORTERM below 16m and 256\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\n\nfunction hasColors(count\x2C env) {\n  if (env === undefined &&\n      (count === undefined || (typeof count === 'object' && count !== null))) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count\x2C 'count'\x2C 2);\n  }\n\n  return count <= 2 ** getColorDepth(env);\n}\n\nmodule.exports = {\n  getColorDepth\x2C\n  hasColors\n};\n
code-source-info,0x3157152d2dc6,138,0,6446,C0O0C4O6446,,
code-creation,Function,10,185543,0x3157152d3226,358, node:internal/tty:1:1,0x3157152d2d40,~
code-source-info,0x3157152d3226,138,0,6446,C0O0C69O1186C75O1208C81O1231C87O1255C93O1329C99O1329C104O1309C110O1366C111O1366C113O1395C115O1395C117O1416C119O1416C121O1438C123O1438C125O1460C127O1460C129O1877C136O1890C142O1913C148O1937C154O1960C160O1983C166O2005C172O2026C178O2050C184O2074C190O2096C196O2119C202O2140C208O2163C214O2182C220O2287C226O2379C232O1877C234O2420C328O2420C330O2541C331O2541C333O6395C340O6416C346O6433C352O6410C357O6445,,
tick,0x107acd2b1,185671,0,0x0,0,0x3157152d326b,0x10f8c4be3,0x10f8c4865,0x3157152d250a,0x1070da090,0x315766fb37b8,0x107af4847
code-creation,LazyCompile,10,185723,0x3157152d3cfe,63,hasColors node:internal/tty:222:19,0x3157152d2e98,~
code-source-info,0x3157152d3cfe,138,6138,6393,C0O6155C18O6264C21O6281C27O6308C41O6308C46O6351C52O6372C56O6369C59O6364C62O6391,,
code-creation,LazyCompile,10,185853,0x3157152d4bde,762,getColorDepth node:internal/tty:106:23,0x3157152d2e48,~
code-source-info,0x3157152d4bde,138,3180,6118,C0O3180C17O3195C27O3327C30O3335C36O3368C39O3380C81O3453C89O3453C93O3491C99O3508C100O3533C108O3533C112O3571C118O3589C119O3614C127O3614C131O3652C137O3670C138O3694C144O3710C145O3724C148O3732C157O3814C166O4044C173O4049C178O4067C184O4083C185O4091C190O4103C197O4112C202O4173C210O4230C218O4230C223O4218C228O4251C235O4284C242O4263C252O4261C260O4483C268O4497C271O4487C276O4501C281O4530C290O4540C293O4530C296O4551C300O4561C305O4579C311O4597C312O4604C316O4614C321O4632C327O4650C328O4662C334O4679C335O4687C338O4695C344O4707C350O4725C351O4733C354O4741C360O4751C365O4892C375O4892C385O4927C392O4935C397O4959C403O4977C404O4988C410O5004C411O5012C416O5035C421O5049C436O5113C441O5056C452O5139C460O5151C462O5160C463O5168C466O5180C501O5224C504O5233C514O5265C525O5301C530O5265C537O5341C543O5359C544O5374C550O5392C551O5441C557O5459C558O5493C564O5511C565O5519C568O5527C575O5537C583O5560C590O5570C595O5589C601O5607C602O5615C605O5623C618O5635C635O5677C640O5639C647O5692C653O5710C654O5738C666O5769C671O5738C675O5738C677O5781C686O5794C691O5813C700O5829C703O5839C704O5850C715O5873C723O5854C730O5974C736O5991C739O6051C742O6059C748O6076C754O6093C755O6100C761O6116,,
code-creation,LazyCompile,10,186065,0x3157152d513e,5,get node:internal/util/inspect:345:6,0x315735254ef0,~
script-source,14,node:internal/util/inspect,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeUnshift\x2C\n  BigIntPrototypeValueOf\x2C\n  BooleanPrototypeValueOf\x2C\n  DatePrototypeGetTime\x2C\n  DatePrototypeToISOString\x2C\n  DatePrototypeToString\x2C\n  ErrorPrototypeToString\x2C\n  FunctionPrototypeCall\x2C\n  FunctionPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGetSize\x2C\n  MapPrototypeEntries\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMin\x2C\n  MathRound\x2C\n  MathSqrt\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseFloat\x2C\n  NumberParseInt\x2C\n  NumberPrototypeValueOf\x2C\n  Object\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectIs\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectPrototypePropertyIsEnumerable\x2C\n  ObjectSeal\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectOwnKeys\x2C\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  RegExpPrototypeToString\x2C\n  SafeStringIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SetPrototypeGetSize\x2C\n  SetPrototypeValues\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeNormalize\x2C\n  StringPrototypePadEnd\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  StringPrototypeValueOf\x2C\n  SymbolPrototypeToString\x2C\n  SymbolPrototypeValueOf\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n  Uint8Array\x2C\n  globalThis\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties\x2C\n  getPromiseDetails\x2C\n  getProxyDetails\x2C\n  kPending\x2C\n  kRejected\x2C\n  previewEntries\x2C\n  getConstructorName: internalGetConstructorName\x2C\n  getExternalValue\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol\x2C\n  isError\x2C\n  join\x2C\n  removeColors\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\n  }\x2C\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction\x2C\n  isGeneratorFunction\x2C\n  isAnyArrayBuffer\x2C\n  isArrayBuffer\x2C\n  isArgumentsObject\x2C\n  isBoxedPrimitive\x2C\n  isDataView\x2C\n  isExternal\x2C\n  isMap\x2C\n  isMapIterator\x2C\n  isModuleNamespaceObject\x2C\n  isNativeError\x2C\n  isPromise\x2C\n  isSet\x2C\n  isSetIterator\x2C\n  isWeakMap\x2C\n  isWeakSet\x2C\n  isRegExp\x2C\n  isDate\x2C\n  isTypedArray\x2C\n  isStringObject\x2C\n  isNumberObject\x2C\n  isBooleanObject\x2C\n  isBigIntObject\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nlet hexSlice;\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis)\x2C\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\x2C e)\n  )\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false\x2C\n  depth: 2\x2C\n  colors: false\x2C\n  customInspect: true\x2C\n  showProxy: false\x2C\n  maxArrayLength: 100\x2C\n  maxStringLength: 10000\x2C\n  breakLength: 80\x2C\n  compact: 3\x2C\n  sorted: false\x2C\n  getters: false\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern\x2C 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx\x2C isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize\x2C\n    showHidden: ctx.showHidden\x2C\n    depth: ctx.depth\x2C\n    colors: ctx.colors\x2C\n    customInspect: ctx.customInspect\x2C\n    showProxy: ctx.showProxy\x2C\n    maxArrayLength: ctx.maxArrayLength\x2C\n    maxStringLength: ctx.maxStringLength\x2C\n    breakLength: ctx.breakLength\x2C\n    compact: ctx.compact\x2C\n    sorted: ctx.sorted\x2C\n    getters: ctx.getters\x2C\n    ...ctx.userOptions\n  };\n\n  // Typically\x2C the target value will be an instance of `Object`. If that is\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\n  // to avoid passing it objects from this Context in that case\x2C so we remove\n  // the prototype from the returned object itself + the `stylize()` function\x2C\n  // and remove all other non-primitives\x2C including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret\x2C null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\n      } catch {}\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\n      return stylized;\n    }\x2C null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\nfunction inspect(value\x2C opts) {\n  // Default options\n  const ctx = {\n    budget: {}\x2C\n    indentationLvl: 0\x2C\n    seen: []\x2C\n    currentDepth: 0\x2C\n    stylize: stylizeNoColor\x2C\n    showHidden: inspectDefaultOptions.showHidden\x2C\n    depth: inspectDefaultOptions.depth\x2C\n    colors: inspectDefaultOptions.colors\x2C\n    customInspect: inspectDefaultOptions.customInspect\x2C\n    showProxy: inspectDefaultOptions.showProxy\x2C\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\n    breakLength: inspectDefaultOptions.breakLength\x2C\n    compact: inspectDefaultOptions.compact\x2C\n    sorted: inspectDefaultOptions.sorted\x2C\n    getters: inspectDefaultOptions.getters\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx\x2C value\x2C 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\n  get() {\n    return inspectDefaultOptions;\n  }\x2C\n  set(options) {\n    validateObject(options\x2C 'options');\n    return ObjectAssign(inspectDefaultOptions\x2C options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null)\x2C {\n  reset: [0\x2C 0]\x2C\n  bold: [1\x2C 22]\x2C\n  dim: [2\x2C 22]\x2C // Alias: faint\n  italic: [3\x2C 23]\x2C\n  underline: [4\x2C 24]\x2C\n  blink: [5\x2C 25]\x2C\n  // Swap foreground and background colors\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\n  hidden: [8\x2C 28]\x2C // Alias: conceal\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\n  black: [30\x2C defaultFG]\x2C\n  red: [31\x2C defaultFG]\x2C\n  green: [32\x2C defaultFG]\x2C\n  yellow: [33\x2C defaultFG]\x2C\n  blue: [34\x2C defaultFG]\x2C\n  magenta: [35\x2C defaultFG]\x2C\n  cyan: [36\x2C defaultFG]\x2C\n  white: [37\x2C defaultFG]\x2C\n  bgBlack: [40\x2C defaultBG]\x2C\n  bgRed: [41\x2C defaultBG]\x2C\n  bgGreen: [42\x2C defaultBG]\x2C\n  bgYellow: [43\x2C defaultBG]\x2C\n  bgBlue: [44\x2C defaultBG]\x2C\n  bgMagenta: [45\x2C defaultBG]\x2C\n  bgCyan: [46\x2C defaultBG]\x2C\n  bgWhite: [47\x2C defaultBG]\x2C\n  framed: [51\x2C 54]\x2C\n  overlined: [53\x2C 55]\x2C\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\n  redBright: [91\x2C defaultFG]\x2C\n  greenBright: [92\x2C defaultFG]\x2C\n  yellowBright: [93\x2C defaultFG]\x2C\n  blueBright: [94\x2C defaultFG]\x2C\n  magentaBright: [95\x2C defaultFG]\x2C\n  cyanBright: [96\x2C defaultFG]\x2C\n  whiteBright: [97\x2C defaultFG]\x2C\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\n  bgRedBright: [101\x2C defaultBG]\x2C\n  bgGreenBright: [102\x2C defaultBG]\x2C\n  bgYellowBright: [103\x2C defaultBG]\x2C\n  bgBlueBright: [104\x2C defaultBG]\x2C\n  bgMagentaBright: [105\x2C defaultBG]\x2C\n  bgCyanBright: [106\x2C defaultBG]\x2C\n  bgWhiteBright: [107\x2C defaultBG]\x2C\n});\n\nfunction defineColorAlias(target\x2C alias) {\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\n    get() {\n      return this[target];\n    }\x2C\n    set(value) {\n      this[target] = value;\n    }\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray'\x2C 'grey');\ndefineColorAlias('gray'\x2C 'blackBright');\ndefineColorAlias('bgGray'\x2C 'bgGrey');\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\ndefineColorAlias('dim'\x2C 'faint');\ndefineColorAlias('strikethrough'\x2C 'crossedout');\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\ndefineColorAlias('hidden'\x2C 'conceal');\ndefineColorAlias('inverse'\x2C 'swapColors');\ndefineColorAlias('inverse'\x2C 'swapcolors');\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\n  special: 'cyan'\x2C\n  number: 'yellow'\x2C\n  bigint: 'yellow'\x2C\n  boolean: 'yellow'\x2C\n  undefined: 'grey'\x2C\n  null: 'bold'\x2C\n  string: 'green'\x2C\n  symbol: 'green'\x2C\n  date: 'magenta'\x2C\n  // "name": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red'\x2C\n  module: 'underline'\n});\n\nfunction addQuotes(str\x2C quotes) {\n  if (quotes === -1) {\n    return `"${str}"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nconst escapeFn = (str) => meta[StringPrototypeCharCodeAt(str)];\n\n// Escape control characters\x2C single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present\x2C do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\n  // backticks. If they do not exist\x2C use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str\x2C "'")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str\x2C '"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\n               !StringPrototypeIncludes(str\x2C '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\x2C str))\n    return addQuotes(str\x2C singleQuote);\n  if (str.length > 100) {\n    str = StringPrototypeReplace(str\x2C escapeReplace\x2C escapeFn);\n    return addQuotes(str\x2C singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  const lastIndex = str.length;\n  for (let i = 0; i < lastIndex; i++) {\n    const point = StringPrototypeCharCodeAt(str\x2C i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\n      }\n      last = i + 1;\n    }\n  }\n\n  if (last !== lastIndex) {\n    result += StringPrototypeSlice(str\x2C last);\n  }\n  return addQuotes(result\x2C singleQuote);\n}\n\nfunction stylizeWithColor(str\x2C styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object\x2C proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp\x2C descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\n      }\n      return descriptor.value.name;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto\x2C {\n      ...ctx\x2C\n      customInspect: false\x2C\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen\x2C main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output\x2C value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here\x2C because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value\x2C showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys\x2C symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module\x2C but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor\x2C tag\x2C fallback);\n}\n\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null'\x2C 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (ctx.showProxy) {\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module\x2C its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom\x2C context\x2C depth\x2C getUserOptions(ctx\x2C isCrossContext));\n      // If the custom inspection method returned `this`\x2C don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\n        }\n        return ret.replace(/\\n/g\x2C `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value\x2C index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value\x2C index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\n  }\n\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\n}\n\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value\x2C SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (value[SymbolIterator] || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null\x2C value) :\n        formatSet.bind(null\x2C SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null\x2C value) :\n        formatMap.bind(null\x2C MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null\x2C bound\x2C size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Map'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Set'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value\x2C ctx.showHidden);\n    braces = ['{'\x2C '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base\x2C 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base\x2C 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base\x2C 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\n      // .buffer goes last\x2C it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null\x2C keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\n        }\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName\x2C 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx\x2C value\x2C recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length\x2C keys.length\x2C ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type\x2C tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`\x2C '}'];\n}\n\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0\x2C value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value\x2C constructor\x2C tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.slice(0\x2C 5) === 'class' && stringified.endsWith('}')) {\n    const slice = stringified.slice(5\x2C -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0\x2C bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value\x2C constructor\x2C tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let len = name.length;\n  let stack = err.stack ? String(err.stack) : ErrorPrototypeToString(err);\n\n  // Do not "duplicate" error properties that are already included in the output\n  // otherwise.\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index\x2C 1);\n      }\n    }\n  }\n\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for "regular errors" (errors that "look normal") for now.\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor\x2C tag\x2C fallback).slice(0\x2C -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at'\x2C pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else if (ctx.colors) {\n    // Highlight userland code and node modules.\n    let newStack = stack.slice(0\x2C stackStart);\n    const lines = stack.slice(stackStart + 1).split('\\n');\n    for (const line of lines) {\n      const core = line.match(coreModuleRegExp);\n      if (core !== null && NativeModule.exists(core[1])) {\n        newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\n      } else {\n        // This adds underscores to all node_modules to quickly identify them.\n        let nodeModule;\n        newStack += '\\n';\n        let pos = 0;\n        while (nodeModule = nodeModulesRegExp.exec(line)) {\n          // '/node_modules/'.length === 14\n          newStack += line.slice(pos\x2C nodeModule.index + 14);\n          newStack += ctx.stylize(nodeModule[1]\x2C 'module');\n          pos = nodeModule.index + nodeModule[0].length;\n        }\n        newStack += pos === 0 ? line : line.slice(pos);\n      }\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g\x2C `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx\x2C output\x2C value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the "... n more items" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first\x2C\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i]\x2C ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      )\x2C\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4\x2C\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns\x2C outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp\x2C str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]'\x2C\n      'special'\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction formatNumber(fn\x2C value) {\n  // Format -0 as '-0'. Checking `value === -0` won't distinguish 0 from -0.\n  return fn(ObjectIs(value\x2C -0) ? '-0' : `${value}`\x2C 'number');\n}\n\nfunction formatBigInt(fn\x2C value) {\n  return fn(`${value}n`\x2C 'bigint');\n}\n\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0\x2C ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n        // function.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line)\x2C 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value)\x2C 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn\x2C value);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn\x2C value);\n  if (typeof value === 'boolean')\n    return fn(`${value}`\x2C 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined'\x2C 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\n}\n\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned\x2C even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0\x2C pos + 1) +\n                  ctx.stylize('<uninitialized>'\x2C 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx\x2C value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)'\x2C 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(StringPrototypeReplace(\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\n    /(.{2})/g\x2C '$1 '));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i)\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]);\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last\x2C it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT'\x2C\n      'length'\x2C\n      'byteLength'\x2C\n      'byteOffset'\x2C\n      'buffer'\x2C\n    ]) {\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k\x2C 1: v } of value) {\n    output.push(\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength\x2C len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\n      ];\n      output[i] = reduceToSingleString(\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\n}\n\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/\x2C ' Entries] {');\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\n  }\n\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\n}\n\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\n  let output;\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>'\x2C 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\n        str\x2C\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\n                        original = value) {\n  let name\x2C str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\n    { value: value[key]\x2C enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`\x2C sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]'\x2C 'special');\n  } else {\n    str = ctx.stylize('undefined'\x2C 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = StringPrototypeReplace(\n      SymbolPrototypeToString(key)\x2C\n      strEscapeSequencesReplacer\x2C escapeFn\n    );\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = "['__proto__']";\n  } else if (desc.enumerable === false) {\n    const tmp = StringPrototypeReplace(key\x2C\n                                       strEscapeSequencesReplacer\x2C escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeTest(keyStrRegExp\x2C key)) {\n    name = ctx.stylize(key\x2C 'name');\n  } else {\n    name = ctx.stylize(strEscape(key)\x2C 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\n  // length of at least `output.length`. In addition\x2C some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped\x2C\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx\x2C output\x2C value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`\x2C as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\n          return `${base ? `${base} ` : ''}${braces[0]} ${join(output\x2C '\x2C ')}` +\n            ` ${braces[1]}`;\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\n  if (proxyTarget !== undefined) {\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) =>\n  StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (err) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(err);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined\x2C args);\n}\n\nfunction formatWithOptions(inspectOptions\x2C ...args) {\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'inspectOptions'\x2C 'object'\x2C inspectOptions);\n  }\n  return formatWithOptionsInternal(inspectOptions\x2C args);\n}\n\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumber(stylizeNoColor\x2C tempArg);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = `${tempArg}n`;\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg\x2C {\n                  ...inspectOptions\x2C\n                  compact: 3\x2C\n                  colors: false\x2C\n                  depth: 0\n                });\n              }\n              break;\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = `${tempNum}n`;\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor\x2C Number(tempNum));\n              }\n              break;\n            case 79: // 'O'\n              tempStr = inspect(args[++a]\x2C inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a]\x2C {\n                ...inspectOptions\x2C\n                showHidden: true\x2C\n                showProxy: true\x2C\n                depth: 4\n              });\n              break;\n            case 105: // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = `${tempInteger}n`;\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor\x2C\n                                       NumberParseInt(tempInteger));\n              }\n              break;\n            case 102: // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumber(stylizeNoColor\x2C\n                                       NumberParseFloat(tempFloat));\n              }\n              break;\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first\x2C lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment\x2C since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str\x2C 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char\x2C 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str\x2C 'str');\n\n  return str.replace(ansi\x2C '');\n}\n\nmodule.exports = {\n  inspect\x2C\n  format\x2C\n  formatWithOptions\x2C\n  getStringWidth\x2C\n  inspectDefaultOptions\x2C\n  stripVTControlCharacters\n};\n
code-source-info,0x3157152d513e,14,10110,10152,C0O10119C4O10148,,
tick,0x7ff803e8095f,191204,0,0x0,3,0x1077801f0,0x3157152d2530,0x1070da090,0x315766fb37b8,0x107af4847
tick,0x7ff803d61c6a,191226,0,0x0,3,0x1077801f0,0x3157152d2530,0x1070da090,0x315766fb37b8,0x107af4847
tick,0x7ff803e80c77,191234,0,0x0,3,0x1077801f0,0x3157152d2530,0x1070da090,0x315766fb37b8,0x107af4847
tick,0x7ff803df1f21,191241,0,0x0,3,0x1077801f0,0x3157152d2530,0x1070da090,0x315766fb37b8,0x107af4847
code-creation,LazyCompile,10,191344,0x3157152d973e,382,inspect node:internal/util/inspect:286:17,0x315735254ea0,~
code-source-info,0x3157152d973e,14,8068,10015,C0O8068C2O8119C9O8208C15O8240C18O8262C28O8285C31O8307C41O8326C44O8348C54O8375C57O8397C67O8427C70O8449C80O8480C83O8502C93O8539C96O8561C106O8595C109O8617C119O8643C122O8665C132O8686C135O8708C145O8729C148O8751C159O8780C166O8787C171O8829C178O8836C183O8849C185O8862C190O8891C192O8912C195O8901C199O8945C206O8952C213O8968C218O8997C220O9019C223O9008C227O9076C233O9115C235O9130C241O9149C245O9183C250O9183C255O9220C257O9235C261O9225C266O9270C268O9277C272O9471C279O9516C282O9486C291O9561C296O9588C298O9603C301O9597C307O9633C313O9741C315O9757C319O9245C324O9207C327O9803C333O9811C335O9823C339O9853C345O9899C348O9897C352O9919C358O9967C361O9965C365O9979C376O9986C381O10013,,
code-creation,LazyCompile,10,191543,0x3157152d9c9e,460,formatValue node:internal/util/inspect:726:21,0x3157352554c0,~
code-source-info,0x3157152d9c9e,14,21561,24106,C0O21649C14O21726C17O21726C23O21761C26O21788C37O21768C42O21809C43O21816C47O21853C58O21853C64O21877C65O21961C68O22089C73O22118C80O22089C86O22132C88O22171C94O22190C106O22197C111O22235C112O22246C117O22401C123O22442C125O22448C127O22447C131O22474C137O22607C142O22713C148O22734C153O22746C160O22756C165O22902C174O22930C181O22936C185O22989C188O22995C193O23033C195O23022C200O23060C208O23120C223O23060C229O23265C231O23273C236O23296C242O23337C254O23344C259O23380C260O23410C276O23434C281O23445C286O23434C296O23410C302O23464C303O23650C308O23655C313O23655C320O23690C323O23705C329O23737C331O23756C334O23752C339O23750C343O23777C348O23786C353O23786C361O23836C366O23845C371O23845C377O23863C379O23910C384O23919C388O23924C392O23941C397O23950C402O23950C408O23998C418O24020C432O23998C438O24041C439O24049C454O24056C459O24104,,
tick,0x7ff803d50d2a,191628,0,0x0,3,0x1077801f0,0x3157152d98b6,0x3157152d2546,0x1070da090,0x315766fb37b8,0x107af4847
code-creation,LazyCompile,10,191982,0x3157152da796,3322,formatRaw node:internal/util/inspect:796:19,0x315735255510,~
code-source-info,0x3157152da796,14,24126,34631,C0O24173C2O24185C4O24207C10O24242C14O24235C19O24255C25O24278C28O24322C44O24322C50O24434C54O24477C61O24484C66O24497C68O24538C70O24544C72O24543C76O24678C82O24720C87O24741C95O24762C101O24802C107O24855C111O24838C118O24889C121O24916C124O24938C127O24965C129O24992C131O25008C133O25032C141O25045C147O25062C150O25099C155O25313C157O25323C159O25322C168O25370C170O25394C176O25398C182O25517C184O25530C191O25549C208O25614C231O25567C242O25645C248O25652C254O25699C265O25712C280O25745C287O25752C292O25766C299O25773C308O25816C309O25832C320O25839C321O25846C326O25883C331O25919C337O25923C343O25958C349O25958C355O26007C369O26046C388O26007C395O26062C399O26088C405O26069C411O26107C419O26160C428O26160C440O26198C451O26209C455O26209C461O26198C468O26243C469O26252C474O26266C481O26273C490O26316C500O26337C501O26344C512O26357C531O26385C537O26389C543O26424C549O26424C555O26473C569O26512C588O26473C595O26528C599O26554C605O26535C611O26573C619O26626C628O26626C640O26664C651O26675C655O26675C661O26664C668O26710C669O26719C674O26733C681O26740C690O26783C700O26804C701O26811C712O26824C731O26852C737O26856C743O26885C749O26892C755O26951C758O26979C762O26989C766O27025C772O27036C778O27138C784O27161C791O27146C798O27207C804O27207C810O27265C820O27307C842O27265C849O27323C860O27336C875O27369C882O27376C887O27390C894O27397C899O27411C905O27431C906O27447C917O27454C918O27610C922O27639C937O27639C943O27670C950O27712C956O27716C962O27746C966O27772C972O27753C978O27791C986O27800C992O27886C996O27913C1005O27913C1014O27944C1020O27948C1026O27978C1030O28004C1036O27985C1042O28023C1050O28032C1056O28118C1060O28145C1069O28145C1078O28184C1080O28215C1084O28237C1088O28263C1094O28244C1100O28280C1105O28305C1107O28321C1112O28343C1118O28347C1124O28383C1129O28393C1135O28425C1137O28433C1142O28451C1159O28466C1172O28461C1176O28531C1183O28538C1192O28583C1193O28599C1204O28606C1207O28626C1213O28667C1226O28674C1232O28731C1239O28738C1248O28792C1258O28792C1264O28817C1267O28829C1273O28833C1279O28906C1295O28981C1301O28977C1308O28913C1313O29025C1327O29025C1334O29070C1336O29081C1341O29104C1348O29123C1353O29147C1360O29154C1369O29222C1373O29216C1378O29235C1384O29273C1394O29273C1400O29297C1403O29317C1409O29321C1415O29399C1423O29418C1427O29418C1433O29406C1441O29457C1445O29457C1453O29496C1457O29496C1462O29550C1476O29550C1483O29593C1485O29604C1490O29625C1497O29644C1502O29667C1509O29674C1518O29730C1528O29730C1534O29752C1537O29772C1543O29776C1549O29800C1568O29807C1574O29871C1581O29878C1590O29921C1592O29933C1595O29945C1601O29949C1607O30184C1613O30184C1627O30273C1640O30273C1647O30319C1651O30359C1656O30412C1663O30419C1672O30464C1680O30528C1686O30543C1692O30511C1708O30478C1711O30559C1712O30574C1717O30589C1725O30584C1729O30606C1739O30606C1746O30660C1752O30664C1758O30691C1775O30706C1788O30701C1792O30822C1813O30822C1820O30900C1826O30904C1832O30930C1849O30945C1862O30940C1866O30994C1871O31032C1877O31036C1883O31062C1900O31077C1913O31072C1917O31142C1932O31204C1938O31208C1944O31234C1961O31249C1974O31244C1978O31314C1993O31376C1999O31380C2005O31420C2022O31435C2035O31430C2039O31535C2043O31569C2052O31569C2061O31598C2067O31602C2073O31635C2092O31642C2098O31707C2105O31714C2117O31759C2119O31771C2122O31808C2129O31815C2141O31860C2147O31864C2157O31911C2163O31911C2173O31934C2187O31935C2199O31970C2211O31992C2234O31970C2246O32015C2247O32034C2260O32044C2281O32085C2282O32100C2298O32115C2319O32110C2327O32192C2331O32186C2339O32205C2345O32249C2358O32249C2370O32285C2387O32286C2401O32304C2405O32336C2411O32358C2430O32393C2440O32393C2452O32429C2453O32436C2463O32462C2473O32467C2483O32467C2493O32482C2495O32499C2503O32521C2505O32558C2517O32586C2526O32595C2537O32641C2539O32657C2543O32650C2551O32685C2567O32744C2587O32699C2599O32685C2609O32666C2616O32636C2619O32773C2623O32818C2639O32818C2664O32891C2679O32891C2691O32927C2708O32928C2722O32946C2741O32953C2751O33019C2752O33034C2762O33082C2772O33091C2782O33091C2794O33107C2796O33162C2808O33179C2831O33162C2845O33282C2856O33290C2864O33310C2866O33322C2880O33346C2895O33359C2905O33390C2910O33405C2924O33424C2937O33400C2945O33455C2955O33460C2965O33460C2973O33478C2983O33515C2994O33522C3005O33549C3015O33561C3017O33580C3019O33576C3027O33617C3037O33617C3050O33655C3058O33662C3066O33697C3076O33710C3086O33724C3090O33717C3098O33697C3110O33731C3120O33732C3132O33763C3142O33777C3152O33791C3156O33784C3164O33804C3176O33763C3186O33849C3211O33849C3222O33957C3232O33968C3240O33963C3250O34023C3258O34017C3265O34037C3275O34048C3287O34064C3295O34565C3301O34579C3309O34596C3311O34606C3319O34618C3321O34629,,
code-creation,LazyCompile,10,192286,0x3157152dbb36,311,getConstructorName node:internal/util/inspect:548:28,0x3157352552e0,~
code-source-info,0x3157152dbb36,14,15972,17205,C0O16017C2O16043C7O16061C13O16064C16O16064C22O16116C30O16116C36O16172C38O16230C46O16273C51O16279C58O16284C66O16331C71O16302C78O16347C84O16400C91O16421C94O16436C99O16451C104O16457C109O16436C116O16475C127O16519C138O16475C143O16597C148O16603C152O16608C153O16620C158O16626C164O16657C168O16695C173O16050C176O16726C180O16757C181O16769C182O16789C187O16789C192O16848C196O16842C201O16861C207O16883C216O16919C217O16947C222O17001C235O16947C241O17022C243O17054C256O17103C262O17129C268O17149C272O17072C287O17162C288O17170C300O17188C310O17203,,
code-creation,LazyCompile,10,192355,0x3157152dbdfe,13,isInstanceof node:internal/util/inspect:540:22,0x315735255290,~
code-source-info,0x3157152dbdfe,14,15846,15943,C3O15876C5O15890C8O15907C11O15924C12O15937,,
code-creation,LazyCompile,10,192439,0x3157152dc006,223,getKeys node:internal/util/inspect:669:17,0x3157352553d0,~
code-source-info,0x3157152dc006,14,19667,20642,C0O19667C9O19695C11O19719C21O19719C26O19757C30O19779C40O19786C45O19836C51O19843C56O19856C63O19856C73O20216C83O20223C91O20221C101O20268C112O20275C118O20275C127O20301C134O20306C143O20343C151O20343C156O20268C160O20382C172O20389C179O20445C185O20452C190O20482C195O20546C206O20576C209O20576C215O20546C220O20628C222O20640,,
code-creation,LazyCompile,10,192497,0x3157152dc246,19,isError node:internal/util:80:17,0x31575b569c70,~
code-source-info,0x3157152dc246,12,1846,2080,C0O2032C5O2039C13O2072C15O2061C18O2078,,
code-creation,LazyCompile,10,192655,0x3157152dc646,1166,formatError node:internal/util/inspect:1165:21,0x3157352556a0,~
code-source-info,0x3157152dc646,14,37724,40825,C0O37780C9O37795C13O37806C19O37795C28O37840C33O37866C41O37874C45O37885C51O37874C59O37894C63O37894C68O38032C74O38051C81O38058C86O38090C120O38082C151O38082C154O38147C160O38147C167O38240C169O38250C177O38266C185O38278C190O38266C197O38302C207O38302C213O38071C284O38478C288O38518C298O38518C305O38551C311O38551C318O38584C326O38591C333O38607C340O38613C347O38629C354O38635C359O38668C362O38681C366O38735C378O38735C385O38804C397O38804C404O38844C408O38870C416O38903C421O38917C428O38974C441O38974C448O39011C461O39012C469O39030C471O39039C476O39070C482O39070C489O39096C490O39104C495O39123C509O39145C516O39181C521O39207C527O39207C539O39254C553O39276C566O39290C572O39290C582O39401C588O39418C594O39430C600O39418C610O39449C612O39457C617O39480C623O39488C634O39586C644O39586C651O39614C653O39629C658O39643C664O39655C678O39682C684O39766C693O39766C700O39812C708O39829C713O39812C720O39833C730O39834C736O39870C764O39862C795O39862C798O39903C806O39909C810O39903C816O39934C820O39955C824O39968C832O39979C837O39968C844O39995C848O40016C858O40016C877O40152C879O40172C888O40208C890O40237C896O40257C902O40257C908O40237C910O40342C916O40364C920O40370C925O40342C938O40403C946O40421C955O40403C968O40464C975O40482C980O40486C984O40470C988O40219C991O40512C992O40528C1004O40548C1010O40548C1019O39851C1093O40578C1098O40670C1105O40685C1110O40718C1114O40722C1120O40733C1126O40722C1132O40768C1150O40788C1156O40768C1163O40810C1165O40823,,
tick,0x7ff803e10316,192767,0,0x0,3,0x1077801f0,0x3157152dadb6,0x3157152d9e64,0x3157152d98b6,0x3157152d2546,0x1070da090,0x315766fb37b8,0x107af4847
code-creation,LazyCompile,10,192807,0x3157152dcdfe,158,getPrefix node:internal/util/inspect:654:19,0x315735255380,~
code-source-info,0x3157152dcdfe,14,19245,19614,C20O19289C24O19321C26O19329C33O19348C38O19365C43O19376C50O19387C63O19413C73O19421C74O19432C79O19443C86O19454C96O19479C97O19487C99O19495C106O19517C111O19532C117O19556C130O19565C140O19573C141O19580C147O19604C157O19612,,
code-creation,RegExp,3,192999,0x10f8cb900,2052,^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$
code-creation,LazyCompile,10,193042,0x3157152dd076,21,exists node:internal/bootstrap/loaders:236:16,0x31575b54f5f0,~
code-source-info,0x3157152dd076,9,7275,7322,C0O7286C5O7306C10O7310C15O7310C20O7318,,
code-creation,LazyCompile,10,193098,0x3157152dd1ce,82,stylizeWithColor node:internal/util/inspect:521:26,0x3157352551a0,~
code-source-info,0x3157152dd1ce,14,15408,15649,C0O15443C3O15451C10O15457C14O15472C16O15517C19O15525C26O15531C30O15544C32O15575C36O15597C52O15604C65O15622C78O15629C79O15636C81O15647,,
code-creation,LazyCompile,10,193137,0x3157152dd306,6,get node:internal/util/inspect:409:8,0x315735254f90,~
code-source-info,0x3157152dd306,14,12107,12144,C0O12118C2O12129C5O12138,,
code-creation,RegExp,3,193194,0x10f8cc180,1288,[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])
tick,0x7ff803ca3ae0,193934,1,0x1070da090,6,0x1077a4bf0,0x315766fb37b8,0x107af4847
